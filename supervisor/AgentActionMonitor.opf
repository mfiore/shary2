;; -*-Lisp-*-
;;author: Michelangelo Fiore
;;this files contains procedures to monitor actions by other agentsÃ¹




(

 (defop |init|
   :invocation(!(AgentActionMonitor.init))
   :documentation "Inits the module"
   :body (
	  (IF(?(AgentActionMonitor.isStarted FALSE))
	     (!(SEM-CREATE AgentActionMonitor.sem 1 SEM-FIFO))
	     (!(AgentActionMonitor.cleanMonitorSpheres))              
	     (=>(AgentActionMonitor.startMonitorSphereLoop))
	     (=>(AgentActionMonitor.isStarted TRUE))
	     
	     )
	  )
   )

 (defop |startMonitoringAgent|
   :invocation(!(AgentActionMonitor.startMonitoringAgent @agent))
   :documentation "Starts monitoring an agent"
   :body (
	  (IF(?(~(AgentActionMonitor.isMonitoringAgent (VAL @agent) @id)))
	     (!(MonitorManager.getFreeId @monitorId))

	  
	     ;;set the parameters for the monitor manager. We stop when the human has completed his actions and we fail if he fails or he's stopped
	     (!(= @successConditions (. (.(PlanManager.agentReport (VAL @agent) OK) .) (. .) .)))
	     (!(= @failureConditions (. (. .) (. (PlanManager.agentReport (VAL @agent) FAILURE) (PlanManager.agentReport (VAL @agent) STOPPED) .) .) )) 		   
	     (?(Spark.humanHead @sparkHumanHead))
	     
	     ;;start the monitoring
	     (!(MonitorManager.monitorTarget @agent @sparkHumanHead @successConditions @failureConditions MEDIUM @monitorId))
	     (=>(AgentActionMonitor.isMonitoringAgent @agent @monitorId))
	     )
	  
	  )
   )

 (defop |stopMonitoringAgent|
   :invocation(!(AgentActionMonitor.stopMonitoringAgent @agent))
   :documentation "Stops monitoring the agent"
   :body (
	  (IF(?(AgentActionMonitor.isMonitoringAgent (VAL @agent) @monitorId))
	     ;;we cancel even when the monitoring manager is not monitoring the agent because maybe the module has the agent in it's queue but it's currently monitoring something else. With the current implementation there could be some problems, like the monitoring manager looking for a second at the agent before stopping.
	     (=>(MonitorManager.cancelMonitoring (VAL @monitorId)))
	     (~>(AgentActionMonitor.isMonitoringAgent (VAL @agent) (VAL @monitorId)))
	     (WHILE(?(AgentActionMonitor.monitorAction (VAL @agent) @action @sphere))   ;;since we are not monitoring the agent anymore we are not monitoring his actions anymore
		   (~>(AgentActionMonitor.monitorAction (VAL @agent) (VAL @action) (VAL @sphere)))
		   )
	     )
	  )
   )




 (defop |cleanMonitorSpheres|
   :invocation(!(AgentActionMonitor.cleanMonitorSpheres))
   :documentation "Erase every monitor sphere"
   :body (
	  (!(SEM-P AgentActionMonitor.sem))
	  (!(= @sphereId 0))        
	  (WHILE(?(< @sphereId 10))   ;from 0 to 10 (indexes of the monitor spheres in spark)
		(!(Spark.getFreeId @sparkId))
		;we use a fake item and agent
		(=>(Spark.request updateSphereMonitor (VAL @sphereId) GEN_FALSE GREY_TAPE 0 HERAKLES_HUMAN1 0 0 0 SPARK_PICK_OBJECT (VAL @sparkId)))
		(^(Spark.report (VAL @sparkId) @report))
		(~>(Spark.report (VAL @sparkId) @report))
		(IF(?(AgentActionMonitor.sphere @agent @object (VAL @sphereId)))  ;we erase the spheres from the db
		   (~>(AgentActionMonitor.sphere (VAL @agent) (VAL @object) (VAL @sphereId)))
		   )
		(!(= @sphereId (+ @sphereId 1)))
		)
	  (!(SEM-V AgentActionMonitor.sem))
	  )

   )

 (defop |cleanAgentMonitorSpheres|
   :invocation(!(AgentActionMonitor.cleanAgentMonitorSpheres @agent))
   :documentation "Erase the monitor spheres of a particular agent"
   :body (
	  (!(SEM-P AgentActionMonitor.sem))
	  (!(= @sphereId 0))
	  (WHILE(?(< @sphereId 10))  ;from 0 to 9 (index of the monitor spheres in spark)
		(IF(?(AgentActionMonitor.sphere (VAL @agent) @object (VAL @sphereId)))  ;if there is a sphere for an agent if we cancel it
		   (!(Spark.getFreeId @sparkId))
		   (=>(Spark.request updateSphereMonitor (VAL @sphereId) GEN_FALSE GREY_TAPE 0 HERAKLES_HUMAN1 0 0 0 SPARK_PICK_OBJECT (VAL @sparkId)))
		   (^(Spark.report (VAL @sparkId) @report))
		   (~>(Spark.report (VAL @sparkId) @report))
		   (~>(AgentActionMonitor.sphere (VAL @agent) (VAL @object) (VAL @sphereId)))
		   )
		(!(= @sphereId (+ @sphereId 1)))
		)
	  (!(SEM-V AgentActionMonitor.sem))
	  )
   )

 (defop |cleanObjectMonitorSpheres|
   :invocation(!(AgentActionMonitor.cleanObjectMonitorSpheres @object))
   :documentation "erases all the monitor spheres associated to an object"
   :body (
	  (WHILE(?(AgentActionMonitor.sphere @agent (VAL @object) @sphereId))   ;while there are still object associated to a monitor sphere
		(?(AgentActionMonitor.sphere @agent (VAL @object) @sphereId))
		(!(AgentActionMonitor.cleanMonitorSphere (VAL @sphereId)))
		)
	  )
   )
 (defop |cleanMonitorSphere|
   :invocation (!(AgentActionMonitor.cleanMonitorSphere @sphereId))
   :documentation "Erase a particular monitor sphere"
   :body (
	  (!(SEM-P AgentActionMonitor.sem))
	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request updateSphereMonitor (VAL @sphereId) GEN_FALSE GREY_TAPE 0 HERAKLES_HUMAN1 0 0 0 SPARK_PICK_OBJECT (VAL @sparkId)))
	  (^(Spark.report (VAL @sparkId) @report))
	  (~>(Spark.report (VAL @sparkId) @report))
	  (IF(?(AgentActionMonitor.sphere @agent @object (VAL @sphereId)))
	     (~>(AgentActionMonitor.sphere @agent @object (VAL @sphereId)))
	     )
	     
	  (!(SEM-V AgentActionMonitor.sem))
	  )
   )
 (defop |activateMonitorSpheres|
   :invocation (!(AgentActionMonitor.activateMonitorSpheres @objectList @agent))
   :documentation "Activate monitor spheres for an agent on the objects present in objectList"
   :body (

	  (!(SEM-P AgentActionMonitor.sem))
	  (WHILE(?(~(NULL @objectList)))
		(!(= @currentObject (CAR @objectList)))
		(!(= @objectList (CDR @objectList)))
		(IF(?(~(AgentActionMonitor.sphere (VAL @agent) (VAL @currentObject) @sphereId))) ;if the sphere is not already activated
		   ;;get the coordinates of the object
		   (!(Spark.getFreeId @sparkId))
		   (=>(Spark.request getJointAbsPose @currentObject NO_NAME @sparkId))
		   (^(Spark.report (VAL @sparkId) @report))
		   (^(Spark.result (VAL @sparkId) @x @y @z @yaw @pitch @roll))
		   (~>(Spark.report (VAL @sparkId) @report))
		   (~>(Spark.result (VAL @sparkId) (VAL @x) (VAL @y) (VAL @z) (VAL @yaw) (VAL @pitch) (VAL @roll)))		
		   ;;activate a monitor sphere
		   (!(Spark.getFreeId @sparkId))
		   (!(Spark.getFreeSphereId @sphereId))
		   (?(Spark.humanHand RIGHT @sparkHand))
		   ;;different objects have different affordances associated to them, which translate to different kinds of monitor spheres.
		   (?(Spark.typeMonitorSphere (VAL @currentObject) @sphereType)) 
		   (=>(Spark.request updateSphereMonitor (VAL @sphereId) GEN_TRUE (VAL @currentObject) (VAL @sparkHand)
				     (VAL @agent) (VAL @x) (VAL @y) (VAL @z) (VAL @sphereType) (VAL @sparkId)))
		   (^(Spark.report (VAL @sparkId) @report))
		   (~>(Spark.report (VAL @sparkId) @report))
		   
		   
		   (=>(AgentActionMonitor.sphere @agent @currentObject @sphereId))
		   )
		)
	  (!(SEM-V AgentActionMonitor.sem))	  
		
	  )
   
   )
 
 
(defop |AddPlaceThrowInference|
  :invocation(Agent.hasObject @agent @object)
  :documentation "when an agent takes an object we add throw inference to the trashbins. Should be generalized"
  :body (
	 
	 (!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT PINK_TRASHBIN @predicate @value) (. @predicate @value .) @result)) ;used to see if the trashbin is there
	 (!(= @list (. .)))
	 (IF(?(~(NULL @result)))
	    (IF(?(~(AgentActionMonitor.sphere (VAL @agent) PINK_TRASHBIN @sphereId)))  
	       (!(= @list (CONS-TAIL PINK_TRASHBIN @list))) 
	       )
	    )
	 (!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT PLACEMAT_RED @predicate @value) (. @predicate @value .) @result)) ;used to see if the trashbin is there
	 (IF(?(~(NULL @result)))
	    (IF(?(~(AgentActionMonitor.sphere (VAL @agent) PLACEMAT_RED @sphereId)))  
	       (!(= @list (CONS-TAIL PLACEMAT_RED @list)))
	       )
	    )
	 (!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT PLACEMAT_GREEN @predicate @value) (. @predicate @value .) @result)) ;used to see if the trashbin is there
	 (IF(?(~(NULL @result)))
	    (IF(?(~(AgentActionMonitor.sphere (VAL @agent) PLACEMAT_GREEN @sphereId)))  
	       (!(= @list (CONS-TAIL PLACEMAT_GREEN @list)))

	       )
	    )
	 (!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT PLACEMAT_BLUE @predicate @value) (. @predicate @value .) @result)) ;used to see if the trashbin is there
	 (IF(?(~(NULL @result)))
	    (IF(?(~(AgentActionMonitor.sphere (VAL @agent) PLACEMAT_BLUE @sphereId)))  
	       (!(= @list (CONS-TAIL PLACEMAT_BLUE @list)))
	       )
	    )
	 (!(AgentActionMonitor.activateMonitorSpheres @list @agent))

	 )
  )
  

(defop |removeAgentinferencesOnExit|
  :invocation(Monitor.agentDisappears @agent)
  :documentation "remove the inferences when an agent exits the scene"
  :body (

	 (!(AgentActionMonitor.cleanAgentMonitorSpheres @agent))
 
	 )
  )

(defop |addAgentInferencesOnEnter|
  :invocation(Monitor.agentAppears @agent)
  :documentation "add the pick inferences when an agent enters the scene"
  :body (

	 (!(AgentActionMonitor.calculateInferencesForAgent @agent))

	 )
  )

(defop |calculateInferencesforAgent|
  :invocation(!(AgentActionMonitor.calculateInferencesForAgent @agent))
  :documentation "add inferences for an agent for object already present in the scene"
  :body (


	 (!(= @putThrowInference FALSE))

	 ;if the pink thrashbin is present we can add throw inferences
	 (!(DatabaseInterface.find (AGENT-STATEMENT PR2_ROBOT PINK_TRASHBIN isVisible true) @result))
	 (IF(?(~(NULL @result)))
	    (!(= @result (CAR @result)))

	    (IF(?(EQUAL @result TRUE))
	       (!(= @putThrowInference TRUE))
	       ) 
	    )
	 
	 (IF(?(Agent.hasObject (VAL @agent) @object))   ;;if the agent has an item in his hands we add throw inferences
	    (IF(?(EQUAL @putThrowInference TRUE))
	       (!(AgentActionMonitor.activateMonitorSpheres (. PINK_TRASHBIN .) @agent))
	       )
	    ELSE
	    (!(= @result (. .)))  ;;else we add inferences for items on TABLE_4 
	    (!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT @object isOn TABLE_4) (. @object .) @objects))  ;table should not be hardcoded
	    (WHILE(?(~(NULL @objects)))
		  (!(= @object (CAR(CAR @objects))))
		  (!(= @objects (CDR @objects)))
		  (IF(?(~(AgentActionMonitor.sphere (VAL @agent) (VAL @object) @sphereId)))
		     (!(AgentActionMonitor.activateMonitorSpheres (. @object .) @agent))
		     )
		  )
	       )
	    
	 
	 
	 )
  )

(defop |calculateInferences|
  :invocation(!(AgentActionMonitor.calculateInferences))
  :documentation "adds inferences for all agents for objects already present in the scene. We duplicate code here but we save some time since if we looped on the calculateInferencesForAgent op we would have done again
 the requestes to the DB"
  :body (
	 
	 (!(= @list (. .)))
					;get all objects present on TABLE_4
 	 (!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT @object isOn TABLE_4) (. @object .) @result))  ;table should not be hardcoded
	 (IF(?(NULL @result))
	    (!(= @objects (. .)))
	    ELSE
	    (!(= @objects @result))
	    )
	 
	 ;get the table presence
	 (!(DatabaseInterface.find (AGENT-STATEMENT PR2_ROBOT PINK_TRASHBIN isVisible true) @result))
	 (!(= @putThrowInference FALSE))
	 (IF(?(~(NULL @result)))
	    (IF(?(EQUAL @result TRUE))
	       (!(= @putThrowInference TRUE))
	       ) 
	    )
	 ;;activate monitor spheres for every present agent
	 (!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT @presentAgents isPresent true) (. @presentAgents .) @agents))     
	 (WHILE(?(~(NULL @agents)))
	       (!(= @agent (CAR (CAR @agents))))
	       (!(= @agents (CDR @agents)))
	       (!(= @objectList @objects))
	       (IF(?(Agent.hasObject (VAL @agent) @object))
		  (IF(?(EQUAL @putThrowInference TRUE))
		     (!(= @list (CONS-TAIL PINK_TRASHBIN @list)))

		     )
		  ELSE
		  (WHILE(?(~(NULL @objectList)))
			(!(= @object(CAR (CAR @objectList))))
			(!(= @objectList (CDR @objectList)))
			(IF(?(~(AgentActionMonitor.sphere (VAL @agent) (VAL @object) @sphereId)))
			   (!(= @list (CONS-TAIL @object @list)))
			   )
			)
		  )
	       
	       (!(AgentActionMonitor.activateMonitorSpheres @list @agent))
	       )
	 
	 )  
  
  )	 

 (defop |addNewPickInference|
   :invocation(Monitor.objectAppears @object)
   :documentation "change inferences when the robot sees an item" 
   :body (
	  (!(SEM-P AgentActionMonitor.sem ))
	  (IF(~(AgentActionMonitor.blockObjectReappears))  ;sometimes we don't want to consider the object , for example when it's in the thrashbin because it could generate errors.
	     (IF(?(Agent.hasObject @agent (VAL @object))) ;if the agent has the object remove the inference, since it means that he doesn't have it anymore
		(~>(Agent.hasObject (VAL @agent) (VAL @object)))
		(!(Spark.getFreeId @sparkId))
		(?(Spark.humanHand RIGHT @sparkHand))
		(=>(Spark.request setInferrenceForObject @object 0 @agent @sparkHand SPARK_HUMAN_HAND 1.0 @sparkId))
		(^(Spark.report (VAL @sparkId) @report))
		)
	     
	     
	     ;;activate monitor spheres for every present agent
	     (!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT @presentAgents isPresent true) (. @presentAgents .) @agents))   
	     (WHILE(?(~(NULL @agents)))
		   (!(= @agent (CAR(CAR@agents))))
		   (!(= @agents (CDR @agents)))
		   (IF(?(~(AgentActionMonitor.sphere (VAL @agent) (VAL @object) @sphereId)))
		      (!(AgentActionMonitor.activateMonitorSpheres (. @object .) @agent))
		      )
		   )
	     )
	  (!(SEM-V AgentActionMonitor.sem ))
	  )

   )


 (defop |MonitorSphereLoop|
   :invocation(AgentActionMonitor.startMonitorSphereLoop) 
   :documentation "Loop to read the poster of the monitor spheres"
   :body (
	  (WHILE(?(~(AgentActionMonitor.stopMonitorSphereLoop)))
		(!(AgentActionMonitor.readMonitorSpheresPoster))
		(^ (ELAPSED-TIME (TIME) 1))
		)
	  (~>(AgentActionMonitor.stopMonitorSphereLoop))
	  )
   
   )
 

 (defop |readMonitorSpherePoster|
   :invocation(!(AgentActionMonitor.readMonitorSpheresPoster))
   :documentation "Reads the monitor sphere poster and updates knowledge"
   :body (
	  (!(READ-POSTER-INTERNAL SPARK_MONITORINGSPHERES @poster))
	  (IF(! (==  (VAL @poster) (SPARK_MONITORINGSPHERES_POSTER_STR (monitoringSpheres @spheres (modifIndex @currentSpheresModifIndex)))))
	     (!(= @sphereId 0))
	     (!(= @spheresList (BUILD-LLISP-FROM-TERM-COMP @spheres)))
	     (!(= @spheresList (CDR @spheresList)))
	     (WHILE(?(< @sphereId 10)) ;for all the spheres get the parameters
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (isSphereActive @isSphereActive)))
		   (!(= @spheresList (CDR @spheresList)))
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (agentName (name @agentFactName))))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (agentIndex @agentIndex)))
		   (!(= @spheresList (CDR @spheresList)))
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (objectName (name @objectFactName))))
		   (!(= @spheresList (CDR @spheresList)))
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (entityIndex @entityIndex)))
		   (!(= @spheresList (CDR @spheresList)))
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (handIndexInput @handIndexInput)))
		   (!(= @spheresList (CDR @spheresList)))
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (sphereCenter (x @x) (y @y) (z @z))))
		   (!(= @spheresList (CDR @spheresList)))
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (sphereRadius @radius)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (filteringTimeThreshold @timeThreshold)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (sphereType @sphereType)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (monitorEnterInResult @monitorEnterInResult)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (monitorGetOutResult @monitorGetOutResult)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (handIndexResult @handIndexResult)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (modifIndex @modifIndex)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (dummy @dummy)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   

		   (!(= @agentName (MAKE-ATOM @agentFactName)))
		   (!(= @objectName (MAKE-ATOM @objectFactName)))	   
		   ;;if this sphere is active
		   (IF(?(EQUAL @isSphereActive 1))
		      (IF(?(EQUAL @monitorGetOutResult 1)) ;if the target has exited the sphere
				 (IF(?(EQUAL @sphereType SPARK_SIMPLE_ENTRY))

			    (IF(?(Agent.hasObject (VAL @agentName) @heldObject))
			       (!(AgentActionMonitor.checkActionMonitoring @agentName @sphereId))
			       
			       ;;recalculate monitor spheres
			       (!(AgentActionMonitor.cleanAgentMonitorSpheres @agentName))
			       

			       (!(Spark.getFreeId @sparkId))
			       (?(Spark.humanHand RIGHT @sparkHand))
			       (=>(Spark.request setInferrenceForObject @heldObject 0 @agentName @sparkHand SPARK_HUMAN_HAND 1.0 @sparkId))
			       (^(Spark.report (VAL @sparkId) @report))
				  
			       (!(Spark.getFreeId @sparkId))
			       (=>(Spark.request placeObject @heldObject @x @y @z 0 0 0 @sparkId))
			       (^(Spark.report (VAL @sparkId) @report))
				  
			       (~>(Agent.hasObject (VAL @agentName) (VAL @heldObject)))
			       (!(DatabaseInterface.remove (AGENT-STATEMENT PR2_ROBOT @agentName hasInHand (VAL @heldObject)) @result))				  
			       (!(AgentActionMonitor.calculateInferencesForAgent @agentName))
			       (!(AgentActionMonitor.activateMonitorSpheres (. @heldObject .) HERAKLES_HUMAN1))
			       ) 
			    ELSEIF(?(EQUAL @sphereType SPARK_PICK_OBJECT))
			    
			    (IF(?(~(Agent.hasObject (VAL @agentName) @object)))
			       ;;if we were monitoring this action then we say it was completed, else it was an unexpected action
			       (!(AgentActionMonitor.checkActionMonitoring @agentName @sphereId))
			       
			       ;;erase this monitor sphere
			       (!(AgentActionMonitor.cleanAgentMonitorSpheres @agentName))

			       ;;update spark inferences and knowledge
			       (!(Spark.getFreeId @sparkId))
			       (?(Spark.humanHand RIGHT @sparkHand))
			       (=>(Spark.request setInferrenceForObject @objectName 1 @agentName @sparkHand SPARK_HUMAN_HAND 1.0 @sparkId))
			       (^(Spark.report (VAL @sparkId) @report))
			       (=>(Agent.hasObject @agentName @objectName))

			       (!(DatabaseInterface.add (AGENT-STATEMENT PR2_ROBOT @agentName hasInHand (VAL @objectName)) @result))
			       (!(AgentActionMonitor.calculateInferencesForAgent @agentName))

			       
			       )			 
			    )
			 )
		      ;;same as for pick
		      (IF(?(EQUAL @monitorEnterInResult 1))		
			    

			 (IF(?(EQUAL @sphereType SPARK_THROW_IN_CONTAINER))
			    (IF(?(Agent.hasObject (VAL @agentName) @heldObject))
			       (=>(AgentActionMonitor.blockObjectReappears @heldObject )) ;we block the item because we don't want pick inferences on it when it's in the trashbin
			       (!(AgentActionMonitor.checkActionMonitoring @agentName @sphereId))			       
			       
			       ;;erase this monitor sphere
			       (!(AgentActionMonitor.cleanAgentMonitorSpheres @agentName))

			       

			       (!(Spark.getFreeId @sparkId))
			       (?(Spark.humanHand RIGHT @sparkHand))
			       (=>(Spark.request setInferrenceForObject @heldObject 0 @agentName @sparkHand SPARK_HUMAN_HAND 1.0 @sparkId))
			       (^(Spark.report (VAL @sparkId) @report))
				  
			       (!(Spark.getFreeId @sparkId))
			       (=>(Spark.request setInferrenceForObject @heldObject 1 @objectName 0 SPARK_IS_IN 1.0 @sparkId))
			       (^(Spark.report (VAL @sparkId) @report))
				  
			       (~>(Agent.hasObject (VAL @agentName) (VAL @heldObject)))
			       (!(DatabaseInterface.remove (AGENT-STATEMENT PR2_ROBOT @agentName hasInHand (VAL @heldObject)) @result))				  
			       (!(AgentActionMonitor.calculateInferencesForAgent @agentName))
			       )
			    )
			 )
		      )
		   (!(= @sphereId (+ @sphereId 1)))	 
		   )
	     
	     )
	  
	  )  	  
   )

(defop |checkActionMonitoring|
  :invocation (!(AgentActionMonitor.checkActionMonitoring @agentName @sphereId))
  :body (
	 (IF(?(AgentActionMonitor.isMonitoringAgent (VAL @agentName) @monitorId))
	    (IF(?(AgentActionMonitor.monitorAction (VAL @agentName) @actionId (VAL @sphereId)))
	       (~>(AgentActionMonitor.monitorAction (VAL @agentName) (VAL @actionId) (VAL @sphereId)))
	       (=>(AgentActionMonitor.actionCompleted (VAL @agentName) (VAL @actionId)))
	       ELSE
	       (=>(AgentActionMonitor.unexpectedAction (VAL @agentName)))
	       )
	    )

	 )
  

  )
)