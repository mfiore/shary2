;; -*-Lisp-*-
;;author: Michelangelo Fiore
;;this files contains procedures to monitor actions by other agentsÃ¹




(

 (defop |init|
   :invocation(!(AgentActionMonitor.init))
   :documentation "Inits the module"
   :body (
	  (!(SEM-CREATE AgentActionMonitor.sem 1 SEM-FIFO))
	  (!(AgentActionMonitor.cleanMonitorSpheres))
	  (=>(AgentActionMonitor.startMonitorSphereLoop))
	  )
   )

 (defop |startMonitoringAgent|
   :invocation(!(AgentActionMonitor.startMonitoringAgent @agent))
   :documentation "Starts monitoring an agent"
   :body (

	  (!(MonitorManager.getFreeId @monitorId))

	  
	  ;;set the parameters for the monitor manager. We stop when the human has completed his actions
	  (!(= @successConditions (. (.(PlanManager.agentReport (VAL @agent) OK) .) (. .) .)))
	  (!(= @failureConditions (. (. (PlanManager.agentReport (VAL @agent) FAILURE) .) (. .) .) )) 		    
	  (?(Spark.humanHead @sparkHumanHead))
	  
	  ;;start the monitoring
	  (!(MonitorManager.monitorTarget @agent @sparkHumanHead @successConditions @failureConditions MEDIUM @monitorId))
	  (=>(AgentActionMonitor.isMonitoringAgent @agent @monitorId))
	  
	  )
   )

 (defop |stopMonitoringAgent|
   :invocation(!(AgentActionMonitor.stopMonitoringAgent @agent))
   :documentation "Stops monitoring the agent"
   :body (
	  (IF(?(AgentActionMonitor.isMonitoringAgent (VAL @agent) @monitorId))
	     ;;we cancel even when the monitoring manager is not monitor the agent because it could be that the module has the agent in it's queue but it's currently monitoring something else. With the current implementation there could be some problems, like the monitoring manager looking for a second at the agent before stopping.
	     (=>(MonitorManager.cancelMonitoring (VAL @monitorId)))
	     (~>(AgentActionMonitor.isMonitoringAgent (VAL @agent) (VAL @monitorId)))
	     )
	  )
   )






 (defop |cleanMonitorSpheres|
   :invocation(!(AgentActionMonitor.cleanMonitorSpheres))
   :documentation "Erase every monitor sphere"
   :body (
	  
	  (!(= @sphereId 0))
	  (WHILE(?(< @sphereId 10))
		(!(Spark.getFreeId @sparkId))
		(=>(Spark.request updateSphereMonitor (VAL @sphereId) GEN_FALSE GREY_TAPE 0 HERAKLES_HUMAN1 0 0 0 SPARK_PICK_OBJECT (VAL @sparkId)))
		(^(Spark.report (VAL @sparkId) @report))
		(~>(Spark.report (VAL @sparkId) @report))
		(IF(?(AgentActionMonitor.sphere @agent @object (VAL @sphereId)))
		   (~>(AgentActionMonitor.sphere (VAL @agent) (VAL @object) (VAL @sphereId)))
		   )
		(!(= @sphereId (+ @sphereId 1)))
		)
	  )
   )

 (defop |cleanAgentMonitorSpheres|
   :invocation(!(AgentActionMonitor.cleanAgentMonitorSpheres @agent))
   :documentation "Erase the monitor spheres of a particular agent"
   :body (
	  
	  (!(= @sphereId 0))
	  (WHILE(?(< @sphereId 10))
		(IF(?(AgentActionMonitor.sphere (VAL @agent) @object (VAL @sphereId)))
		   (!(Spark.getFreeId @sparkId))
		   (=>(Spark.request updateSphereMonitor (VAL @sphereId) GEN_FALSE GREY_TAPE 0 HERAKLES_HUMAN1 0 0 0 SPARK_PICK_OBJECT (VAL @sparkId)))
		   (^(Spark.report (VAL @sparkId) @report))
		   (~>(Spark.report (VAL @sparkId) @report))
		   (~>(AgentActionMonitor.sphere (VAL @agent) (VAL @object) (VAL @sphereId)))
		   )
		(!(= @sphereId (+ @sphereId 1)))
		)
	  )
   )
 (defop |cleanMonitorSphere|
   :invocation (!(AgentActionMonitor.cleanMonitorSphere @sphereId))
   :documentation "Erase a particular monitor sphere"
   :body (
	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request updateSphereMonitor (VAL @sphereId) GEN_FALSE GREY_TAPE 0 HERAKLES_HUMAN1 0 0 0 SPARK_PICK_OBJECT (VAL @sparkId)))
	  (^(Spark.report (VAL @sparkId) @report))
	  (~>(Spark.report (VAL @sparkId) @report))
	  (IF(?(AgentActionMonitor.sphere @agent @object (VAL @sphereId)))
	     (~>(AgentActionMonitor.sphere @agent @object (VAL @sphereId)))
	     )
	     
	  )
   )
 (defop |activateMonitorSpheres|
   :invocation (!(AgentActionMonitor.activateMonitorSpheres @objectList @agent))
   :documentation "Activate monitor spheres for an agent on the objects present in objectList"
   :body (


	  (WHILE(?(~(NULL @objectList)))
		(!(= @currentObject (CAR @objectList)))
		(!(= @objectList (CDR @objectList)))

		   ;;get the coordinates of the object
		   (!(Spark.getFreeId @sparkId))
		   (=>(Spark.request getJointAbsPose @currentObject NO_NAME @sparkId))
		   (^(Spark.report (VAL @sparkId) @report))
		   (^(Spark.result (VAL @sparkId) @x @y @z @yaw @pitch @roll))
		   (~>(Spark.report (VAL @sparkId) @report))
		   (~>(Spark.result (VAL @sparkId) (VAL @x) (VAL @y) (VAL @z) (VAL @yaw) (VAL @pitch) (VAL @roll)))		
		   ;;activate a monitor sphere
		   (!(Spark.getFreeId @sparkId))
		   (!(Spark.getFreeSphereId @sphereId))
		   (?(Spark.humanHand RIGHT @sparkHand))
		   ;;different objects have different affordances associated to them, which translate to different kinds of monitor spheres.
		   (?(Spark.typeMonitorSphere (VAL @currentObject) @sphereType)) 
		   
		   (=>(Spark.request updateSphereMonitor (VAL @sphereId) GEN_TRUE (VAL @currentObject) (VAL @sparkHand)
				     (VAL @agent) (VAL @x) (VAL @y) (VAL @z) (VAL @sphereType) (VAL @sparkId)))
		   (^(Spark.report (VAL @sparkId) @report))
		   (~>(Spark.report (VAL @sparkId) @report))
		   
		   
		   (=>(AgentActionMonitor.sphere @agent @currentObject @sphereId))
		   )
	  
		
	  )
   
   )
 
 
 
 (defop |objectAppears|
   :invocation(objectAppears @object)
   :documentation "when an object appears we check if a human had it and in that case remove the inference" 
   :body (
	  (!(SEM-P AgentActionMonitor.sem ))
	  (IF(~(AgentActionMonitor.blockObjectReappears))  ;sometimes we don't want to consider the object
	     (IF(?(Agent.hasObject @agent (VAL @object))) ;if the agent has the object remove hte inference
		(~>(Agent.hasObject (VAL @agent) (VAL @object)))
		(!(Spark.getFreeId @sparkId))
		(?(Spark.humanHand RIGHT @sparkHand))
		(=>(Spark.request setInferrenceForObject @object 0 @agent @sparkHand SPARK_HUMAN_HAND 1.0 @sparkId))
		)
	     
	     
	     ;;activate monitor spheres for every present agent
	     (!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT @presentAgents isPresent true) (. @presentAgents .) @result))   
	     (!(= @agents (CAR @result)))
	     (WHILE(?(~(NULL @agents)))
		   (!(= @agent (CAR @agents)))
		   (!(= @agents (CDR @agents)))
		   (IF(?(~(AgentActionMonitor.sphere (VAL @agent) (VAL @object) @sphereId)))
		      (!(AgentActionMonitor.activateMonitorSpheres (. @object .) @agent))
		      )
		   )
	     )
	  (!(SEM-V AgentActionMonitor.sem ))
	  )
   )

 (defop |MonitorSphereLoop|
   :invocation(AgentActionMonitor.startMonitorSphereLoop) 
   :documentation "Loop to read the poster of the monitor spheres"
   :body (
	  (WHILE(?(~(AgentActionMonitor.stopMonitorSphereLoop)))
		(!(AgentActionMonitor.readMonitorSpheresPoster))
		(^ (ELAPSED-TIME (TIME) 1))
		)
	  (~>(AgentActionMonitor.stopMonitorSphereLoop))
	  )
   
   )
 

 (defop |readMonitorSpherePoster|
   :invocation(!(AgentActionMonitor.readMonitorSpheresPoster))
   :documentation "Reads the monitor sphere poster and updates knowledge"
   :body (
	  (!(READ-POSTER-INTERNAL SPARK_MONITORINGSPHERES @poster))
	  (IF(! (==  (VAL @poster) (SPARK_MONITORINGSPHERES_POSTER_STR (monitoringSpheres @spheres (modifIndex @currentSpheresModifIndex)))))
	     (!(= @sphereId 0))
	     (!(= @spheresList (BUILD-LLISP-FROM-TERM-COMP @spheres)))
	     (!(= @spheresList (CDR @spheresList)))
	     (WHILE(?(< @sphereId 10)) ;for all the spheres get the parameters
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (isSphereActive @isSphereActive)))
		   (!(= @spheresList (CDR @spheresList)))
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (agentName (name @agentFactName))))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (agentIndex @agentIndex)))
		   (!(= @spheresList (CDR @spheresList)))
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (objectName (name @objectFactName))))
		   (!(= @spheresList (CDR @spheresList)))
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (entityIndex @entityIndex)))
		   (!(= @spheresList (CDR @spheresList)))
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (handIndexInput @handIndexInput)))
		   (!(= @spheresList (CDR @spheresList)))
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (sphereCenter (x @x) (y @y) (z @z))))
		   (!(= @spheresList (CDR @spheresList)))
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (sphereRadius @radius)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (filteringTimeThreshold @timeThreshold)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (sphereType @sphereType)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (monitorEnterInResult @monitorEnterInResult)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (monitorGetOutResult @monitorGetOutResult)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (handIndexResult @handIndexResult)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (modifIndex @modifIndex)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (dummy @dummy)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   

		   (!(= @agentName (MAKE-ATOM @agentFactName)))
		   (!(= @objectName (MAKE-ATOM @objectFactName)))	   
		   ;;if this sphere is active
		   (IF(?(EQUAL @isSphereActive 1))
		      (IF(?(EQUAL @monitorGetOutResult 1)) ;if the target has entered the sphere
			 
			 (IF(?(EQUAL @sphereType SPARK_PICK_OBJECT))
			    (IF(?(~(Agent.hasObject (VAL @agentName) @object)))
			       ;;if we were monitoring this action then we say it was completed, else it was an unexpected action
			       (!(Tester.breakpoint))
			       (IF(?(AgentActionMonitor.isMonitoringAgent (VAL @agentName) @monitorId))
				  (IF(?(AgentActionMonitor.monitorAction (VAL @agentName) @actionId (VAL @sphereId)))
				     (~>(AgentActionMonitor.monitorAction (VAL @agentName) (VAL @actionId) (VAL @sphereId)))
				     (=>(AgentActionMonitor.actionCompleted (VAL @agentName) (VAL @actionId)))
				     ELSE
				     (=>(AgentActionMonitor.unexpectedAction (VAL @agentName)))
				     )
				  )
			       
			       ;;erase this monitor sphere
			       (!(AgentActionMonitor.cleanMonitorSphere (VAL @sphereId)))

			       ;;update spark inferences and knowledge
			       (!(Spark.getFreeId @sparkId))
			       (?(Spark.humanHand RIGHT @sparkHand))
			       (=>(Spark.request setInferrenceForObject @objectName 1 @agentName @sparkHand SPARK_HUMAN_HAND 1.0 @sparkId))
			       (^(Spark.report (VAL @sparkId) @report))
			       (=>(Agent.hasObject @agentName @objectName))
			       )			 
			    )
			 )
		      ;;same as for pick
		      (IF(?(EQUAL @monitorEnterInResult 1))
			 (IF(?(EQUAL @sphereType SPARK_THROW_IN_CONTAINER))
			    (IF(?(Agent.hasObject (VAL @agentName) @heldObject))
			       (=>(AgentActionMonitor.blockObjectReappears @heldObject )) ;we block the item because we don't want pick inferences on it when it's in the trashbin
			       (IF(?(AgentActionMonitor.isMonitoringAgent (VAL @agentName) @monitorId))
				  (IF(?(AgentActionMonitor.monitorAction (VAL @agentName) @actionId (VAL @sphereId)))
				     (~>(AgentActionMonitor.monitorAction (VAL @agentName) (VAL @actionId) (VAL @sphereId)))
				     (=>(AgentActionMonitor.actionCompleted (VAL @agentName) (VAL @actionId)))
				     ELSE
				     (=>(AgentActionMonitor.unexpectedAction (VAL @agentName)))
				     )
				  )
			       
				  (!(Spark.getFreeId @sparkId))
				  (?(Spark.humanHand RIGHT @sparkHand))
				  (=>(Spark.request setInferrenceForObject @heldObject 0 @agentName @sparkHand SPARK_HUMAN_HAND 1.0 @sparkId))
				  (^(Spark.report (VAL @sparkId) @report))
				  
				  (!(Spark.getFreeId @sparkId))
				  (=>(Spark.request setInferrenceForObject @heldObject 1 @objectName 0 SPARK_IS_IN 1.0 @sparkId))
				  (^(Spark.report (VAL @sparkId) @report))
				  
				  (~>(Agent.hasObject (VAL @agentName) (VAL @heldObject)))
				  
				  )
			    )
			 )
		      )
		   (!(= @sphereId (+ @sphereId 1)))	 
		   )
	     
	     )
	  
	  )  	  
   )
 )




