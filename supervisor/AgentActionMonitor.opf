;; -*-Lisp-*-
;;author: Michelangelo Fiore
;;this files contains procedures to monitor actions by other agentsÃ¹




(

 (defop |init|
   :invocation(!(AgentActionMonitor.init))
   :documentation "Inits the module"
   :body (
	  (!(SEM-CREATE AgentActionMonitor.sem 1 SEM-FIFO))
	  (!(AgentActionMonitor.cleanMonitorSpheres))
	  (=>(AgentActionMonitor.startMonitorSphereLoop))
	  )
   )

 (defop |startMonitoringAgent|
   :invocation(!(AgentActionMonitor.startMonitoringAgent @agent))
   :documentation "Starts monitoring an agent"
   :body (

	  (!(MonitorManager.getFreeId @monitorId))

	  
	  ;;set the parameters for the monitor manager. We stop when the human has completed his actions
	  (!(= @successConditions (. (.(PlanManager.agentReport (VAL @agent) OK) .) (. .) .)))
	  (!(= @failureConditions (. (. (PlanManager.agentReport (VAL @agent) FAILURE) .) (. .) .) )) 		    
	  (?(Spark.humanHead @sparkHumanHead))
	  
	  ;;start the monitoring
	  (!(MonitorManager.monitorTarget @agent @sparkHumanHead @successConditions @failureConditions MEDIUM @monitorId))
	  (=>(AgentActionMonitor.isMonitoringAgent @agent @monitorId))
	  
	  )
   )

 (defop |stopMonitoringAgent|
   :invocation(!(AgentActionMonitor.stopMonitoringAgent @agent))
   :documentation "Stops monitoring the agent"
   :body (
	  (IF(?(AgentActionMonitor.isMonitoringAgent (VAL @agent) @monitorId))
	     ;;we cancel even when the monitoring manager is not monitor the agent because it could be that the module has the agent in it's queue but it's currently monitoring something else. With the current implementation there could be some problems, like the monitoring manager looking for a second at the agent before stopping.
	     (=>(MonitorManager.cancelMonitoring (VAL @monitorId)))
	     (~>(AgentActionMonitor.isMonitoringAgent (VAL @agent) (VAL @monitorId)))
	     (WHILE(?(AgentActionMonitor.monitorAction (VAL @agent) @action @sphere))
		   (~>(AgentActionMonitor.monitorAction (VAL @agent) (VAL @action) (VAL @sphere)))
		   )
	     )
	  )
   )






 (defop |cleanMonitorSpheres|
   :invocation(!(AgentActionMonitor.cleanMonitorSpheres))
   :documentation "Erase every monitor sphere"
   :body (
	  (!(SEM-P AgentActionMonitor.sem))
	  (!(= @sphereId 0))
	  (WHILE(?(< @sphereId 10))
		(!(Spark.getFreeId @sparkId))
		(=>(Spark.request updateSphereMonitor (VAL @sphereId) GEN_FALSE GREY_TAPE 0 HERAKLES_HUMAN1 0 0 0 SPARK_PICK_OBJECT (VAL @sparkId)))
		(^(Spark.report (VAL @sparkId) @report))
		(~>(Spark.report (VAL @sparkId) @report))
		(IF(?(AgentActionMonitor.sphere @agent @object (VAL @sphereId)))
		   (~>(AgentActionMonitor.sphere (VAL @agent) (VAL @object) (VAL @sphereId)))
		   )
		(!(= @sphereId (+ @sphereId 1)))
		)
	  (!(SEM-V AgentActionMonitor.sem))
	  )

   )

 (defop |cleanAgentMonitorSpheres|
   :invocation(!(AgentActionMonitor.cleanAgentMonitorSpheres @agent))
   :documentation "Erase the monitor spheres of a particular agent"
   :body (
	  (!(SEM-P AgentActionMonitor.sem))
	  (!(= @sphereId 0))
	  (WHILE(?(< @sphereId 10))
		(IF(?(AgentActionMonitor.sphere (VAL @agent) @object (VAL @sphereId)))
		   (!(Spark.getFreeId @sparkId))
		   (=>(Spark.request updateSphereMonitor (VAL @sphereId) GEN_FALSE GREY_TAPE 0 HERAKLES_HUMAN1 0 0 0 SPARK_PICK_OBJECT (VAL @sparkId)))
		   (^(Spark.report (VAL @sparkId) @report))
		   (~>(Spark.report (VAL @sparkId) @report))
		   (~>(AgentActionMonitor.sphere (VAL @agent) (VAL @object) (VAL @sphereId)))
		   )
		(!(= @sphereId (+ @sphereId 1)))
		)
	  (!(SEM-v AgentActionMonitor.sem))
	  )
   )
 (defop |cleanMonitorSphere|
   :invocation (!(AgentActionMonitor.cleanMonitorSphere @sphereId))
   :documentation "Erase a particular monitor sphere"
   :body (
	  (!(SEM-P AgentActionMonitor.sem))
	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request updateSphereMonitor (VAL @sphereId) GEN_FALSE GREY_TAPE 0 HERAKLES_HUMAN1 0 0 0 SPARK_PICK_OBJECT (VAL @sparkId)))
	  (^(Spark.report (VAL @sparkId) @report))
	  (~>(Spark.report (VAL @sparkId) @report))
	  (IF(?(AgentActionMonitor.sphere @agent @object (VAL @sphereId)))
	     (~>(AgentActionMonitor.sphere @agent @object (VAL @sphereId)))
	     )
	     
	  (!(SEM-V AgentActionMonitor.sem))
	  )
   )
 (defop |activateMonitorSpheres|
   :invocation (!(AgentActionMonitor.activateMonitorSpheres @objectList @agent))
   :documentation "Activate monitor spheres for an agent on the objects present in objectList"
   :body (

	  (!(SEM-P AgentActionMonitor.sem))
	  (WHILE(?(~(NULL @objectList)))
		(!(= @currentObject (CAR @objectList)))
		(!(= @objectList (CDR @objectList)))

		   ;;get the coordinates of the object
		   (!(Spark.getFreeId @sparkId))
		   (=>(Spark.request getJointAbsPose @currentObject NO_NAME @sparkId))
		   (^(Spark.report (VAL @sparkId) @report))
		   (^(Spark.result (VAL @sparkId) @x @y @z @yaw @pitch @roll))
		   (~>(Spark.report (VAL @sparkId) @report))
		   (~>(Spark.result (VAL @sparkId) (VAL @x) (VAL @y) (VAL @z) (VAL @yaw) (VAL @pitch) (VAL @roll)))		
		   ;;activate a monitor sphere
		   (!(Spark.getFreeId @sparkId))
		   (!(Spark.getFreeSphereId @sphereId))
		   (?(Spark.humanHand RIGHT @sparkHand))
		   ;;different objects have different affordances associated to them, which translate to different kinds of monitor spheres.
		   (?(Spark.typeMonitorSphere (VAL @currentObject) @sphereType)) 
		   
		   (=>(Spark.request updateSphereMonitor (VAL @sphereId) GEN_TRUE (VAL @currentObject) (VAL @sparkHand)
				     (VAL @agent) (VAL @x) (VAL @y) (VAL @z) (VAL @sphereType) (VAL @sparkId)))
		   (^(Spark.report (VAL @sparkId) @report))
		   (~>(Spark.report (VAL @sparkId) @report))
		   
		   
		   (=>(AgentActionMonitor.sphere @agent @currentObject @sphereId))
		   )
	  (!(SEM-V AgentActionMonitor.sem))	  
		
	  )
   
   )
 
 
(defop |addThrowInference|
  :invocation(Agent.hasObject @agent @object)
  :documentation "when an agent takes an object we add throw inference to the trashbins. Should be generalized"
  :body (

	 (!(DatabaseInterface.find (AGENT-STATEMENT PR2_ROBOT PINK_TRASHBIN isVisible true) @result))
	 (IF(?(~(NULL @result)))
	    (!(= @result (CAR @result)))
	    )
	 (IF(?(EQUAL @result TRUE))
	    (!(AgentActionMonitor.activateMonitorSpheres (. PINK_TRASHBIN .) @agent))
	    )
	 

	 )
  )

(defop |removeAgentinferencesOnExit|
  :invocation(Monitor.agentDisappears @agent)
  :documentation "remove the pick inferences when an agent exits the scene"
  :body (

	 (!(AgentActionMonitor.cleanAgentMonitorSpheres @agent))

  
	 )
  )

(defop |addAgentInferencesOnEnter|
  :invocation(Monitor.agentAppears @agent)
  :documentation "add the pick inferences when an agent enters the scene"
  :body (

	 (!(AgentActionMonitor.calculateInferences @agent))

	 )
  )

(defop |calculateInferencesforAgent|
  :invocation(!(AgentActionMonitor.calculateInferences @agent))
  :documentation "add inferences for an agent for object already present in the scene"
  :body (


	 (!(= @putThrowInference FALSE))
	 (!(DatabaseInterface.find (AGENT-STATEMENT PR2_ROBOT PINK_TRASHBIN isVisible true) @result))
	 (IF(?(~(NULL @result)))
	    (!(= @result (CAR @result)))

	    (IF(?(EQUAL @result TRUE))
	       (!(= @putThrowInference TRUE))
	       ) 
	    )
	 
	 (IF(?(Agent.hasObject (VAL @agent) @object))
	    (IF(?(EQUAL @putThrowInference TRUE))
	       (!(AgentActionMonitor.activateMonitorSpheres (. PINK_TRASHBIN .) @agent))
	       )
	    ELSE
	    (!(= @result (. .)))
	    (!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT @object isOn TABLE_4) (. @object .) @objects))  ;table should not be hardcoded
	    (WHILE(?(~(NULL @objects)))
		  (!(= @object (CAR(CAR @objects))))
		  (!(= @objects (CDR @objects)))
		  (IF(?(~(AgentActionMonitor.sphere (VAL @agent) (VAL @object) @sphereId)))
		     (!(AgentActionMonitor.activateMonitorSpheres (. @object .) @agent))
		     )
		  )
	       )
	    
	 
	 
	 )
  )

(defop |calculateInferences|
  :invocation(!(AgentActionMonitor.calculateInferences))
  :documentation "adds  inferences for all agents for objects already present in the scene"
  :body (

	 

	 (!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT @object isOn TABLE_4) (. @object .) @result))  ;table should not be hardcoded
	 (IF(?(NULL @result))
	    (!(= @objects (. .)))
	    ELSE
	    (!(= @objects @result))
	    )
	 
	 (!(DatabaseInterface.find (AGENT-STATEMENT PR2_ROBOT PINK_TRASHBIN isVisible true) @result))
	 (!(= @putThrowInference FALSE))
	 (IF(?(~(NULL @result)))
	    (IF(?(EQUAL @result TRUE))
	       (!(= @putThrowInference TRUE))
	       ) 
	    )
	 ;;activate monitor spheres for every present agent
	 (!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT @presentAgents isPresent true) (. @presentAgents .) @agents))     
	 (WHILE(?(~(NULL @agents)))
	       (!(= @agent (CAR (CAR @agents))))
	       (!(= @agents (CDR @agents)))
	       (!(= @objectList @objects))
	       (IF(?(Agent.hasObject (VAL @agent) @object))
		  (IF(?(EQUAL @putThrowInference TRUE))
		     (!(AgentActionMonitor.activateMonitorSpheres (. PINK_TRASHBIN .) @agent))
		     )
		  ELSE
		  (WHILE(?(~(NULL @objectList)))
			(!(= @object(CAR (CAR @objectList))))
			(!(= @objectList (CDR @objectList)))
			(IF(?(~(AgentActionMonitor.sphere (VAL @agent) (VAL @object) @sphereId)))
			   (!(AgentActionMonitor.activateMonitorSpheres (. @object .) @agent))
			   )
			)
		  )
	       
	       
	       )
	 
	 )  
  
  )	 

 (defop |addNewPickInference|
   :invocation(Monitor.objectAppears @object)
   :documentation "when an object appears we check if a human had it and in that case remove the inference" 
   :body (
	  (!(SEM-P AgentActionMonitor.sem ))
	  (IF(~(AgentActionMonitor.blockObjectReappears))  ;sometimes we don't want to consider the object
	     (IF(?(Agent.hasObject @agent (VAL @object))) ;if the agent has the object remove hte inference
		(~>(Agent.hasObject (VAL @agent) (VAL @object)))
		(!(Spark.getFreeId @sparkId))
		(?(Spark.humanHand RIGHT @sparkHand))
		(=>(Spark.request setInferrenceForObject @object 0 @agent @sparkHand SPARK_HUMAN_HAND 1.0 @sparkId))
		(^(Spark.report (VAL @sparkId) @report))
		)
	     
	     
	     ;;activate monitor spheres for every present agent
	     (!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT @presentAgents isPresent true) (. @presentAgents .) @agents))   
	     (WHILE(?(~(NULL @agents)))
		   (!(= @agent (CAR(CAR@agents))))
		   (!(= @agents (CDR @agents)))
		   (IF(?(~(AgentActionMonitor.sphere (VAL @agent) (VAL @object) @sphereId)))
		      (!(AgentActionMonitor.activateMonitorSpheres (. @object .) @agent))
		      )
		   )
	     )
	  )
   (!(SEM-V AgentActionMonitor.sem ))
   )


 (defop |MonitorSphereLoop|
   :invocation(AgentActionMonitor.startMonitorSphereLoop) 
   :documentation "Loop to read the poster of the monitor spheres"
   :body (
	  (WHILE(?(~(AgentActionMonitor.stopMonitorSphereLoop)))
		(!(AgentActionMonitor.readMonitorSpheresPoster))
		(^ (ELAPSED-TIME (TIME) 1))
		)
	  (~>(AgentActionMonitor.stopMonitorSphereLoop))
	  )
   
   )
 

 (defop |readMonitorSpherePoster|
   :invocation(!(AgentActionMonitor.readMonitorSpheresPoster))
   :documentation "Reads the monitor sphere poster and updates knowledge"
   :body (
	  (!(READ-POSTER-INTERNAL SPARK_MONITORINGSPHERES @poster))
	  (IF(! (==  (VAL @poster) (SPARK_MONITORINGSPHERES_POSTER_STR (monitoringSpheres @spheres (modifIndex @currentSpheresModifIndex)))))
	     (!(= @sphereId 0))
	     (!(= @spheresList (BUILD-LLISP-FROM-TERM-COMP @spheres)))
	     (!(= @spheresList (CDR @spheresList)))
	     (WHILE(?(< @sphereId 10)) ;for all the spheres get the parameters
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (isSphereActive @isSphereActive)))
		   (!(= @spheresList (CDR @spheresList)))
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (agentName (name @agentFactName))))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (agentIndex @agentIndex)))
		   (!(= @spheresList (CDR @spheresList)))
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (objectName (name @objectFactName))))
		   (!(= @spheresList (CDR @spheresList)))
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (entityIndex @entityIndex)))
		   (!(= @spheresList (CDR @spheresList)))
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (handIndexInput @handIndexInput)))
		   (!(= @spheresList (CDR @spheresList)))
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (sphereCenter (x @x) (y @y) (z @z))))
		   (!(= @spheresList (CDR @spheresList)))
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (sphereRadius @radius)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (filteringTimeThreshold @timeThreshold)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (sphereType @sphereType)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (monitorEnterInResult @monitorEnterInResult)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (monitorGetOutResult @monitorGetOutResult)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (handIndexResult @handIndexResult)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (modifIndex @modifIndex)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   (!(= @element (CAR @spheresList)))
		   (!(== (VAL @element) (dummy @dummy)))
		   (!(= @spheresList (CDR @spheresList)))		   
		   

		   (!(= @agentName (MAKE-ATOM @agentFactName)))
		   (!(= @objectName (MAKE-ATOM @objectFactName)))	   
		   ;;if this sphere is active
		   (IF(?(EQUAL @isSphereActive 1))
		      (IF(?(EQUAL @monitorGetOutResult 1)) ;if the target has entered the sphere
			 
			 (IF(?(EQUAL @sphereType SPARK_PICK_OBJECT))

			    (IF(?(~(Agent.hasObject (VAL @agentName) @object)))
			       ;;if we were monitoring this action then we say it was completed, else it was an unexpected action

			       (IF(?(AgentActionMonitor.isMonitoringAgent (VAL @agentName) @monitorId))

				  (IF(?(AgentActionMonitor.monitorAction (VAL @agentName) @actionId (VAL @sphereId)))

				     (~>(AgentActionMonitor.monitorAction (VAL @agentName) (VAL @actionId) (VAL @sphereId)))
				     (=>(AgentActionMonitor.actionCompleted (VAL @agentName) (VAL @actionId)))
				     ELSE

				     (=>(AgentActionMonitor.unexpectedAction (VAL @agentName)))
				     )
				  )
			       
			       ;;erase this monitor sphere
			       (!(AgentActionMonitor.cleanMonitorSphere (VAL @sphereId)))

			       ;;update spark inferences and knowledge
			       (!(Spark.getFreeId @sparkId))
			       (?(Spark.humanHand RIGHT @sparkHand))
			       (=>(Spark.request setInferrenceForObject @objectName 1 @agentName @sparkHand SPARK_HUMAN_HAND 1.0 @sparkId))
			       (^(Spark.report (VAL @sparkId) @report))
			       (=>(Agent.hasObject @agentName @objectName))

			       (!(DatabaseInterface.add (AGENT-STATEMENT PR2_ROBOT @agentName hasInHand (VAL @objectName)) @result))
			       )			 
			    )
			 )
		      ;;same as for pick
		      (IF(?(EQUAL @monitorEnterInResult 1))
			 (IF(?(EQUAL @sphereType SPARK_THROW_IN_CONTAINER))

			    (IF(?(Agent.hasObject (VAL @agentName) @heldObject))

			       (=>(AgentActionMonitor.blockObjectReappears @heldObject )) ;we block the item because we don't want pick inferences on it when it's in the trashbin
			       (IF(?(AgentActionMonitor.isMonitoringAgent (VAL @agentName) @monitorId))

				  (IF(?(AgentActionMonitor.monitorAction (VAL @agentName) @actionId (VAL @sphereId)))

				     (~>(AgentActionMonitor.monitorAction (VAL @agentName) (VAL @actionId) (VAL @sphereId)))
				     (=>(AgentActionMonitor.actionCompleted (VAL @agentName) (VAL @actionId)))

				     ELSE

				     (=>(AgentActionMonitor.unexpectedAction (VAL @agentName)))
				     )
				  )

			       ;;erase this monitor sphere
			       (!(AgentActionMonitor.cleanMonitorSphere (VAL @sphereId)))

				  (!(Spark.getFreeId @sparkId))
				  (?(Spark.humanHand RIGHT @sparkHand))
				  (=>(Spark.request setInferrenceForObject @heldObject 0 @agentName @sparkHand SPARK_HUMAN_HAND 1.0 @sparkId))
				  (^(Spark.report (VAL @sparkId) @report))
				  
				  (!(Spark.getFreeId @sparkId))
				  (=>(Spark.request setInferrenceForObject @heldObject 1 @objectName 0 SPARK_IS_IN 1.0 @sparkId))
				  (^(Spark.report (VAL @sparkId) @report))
				  
				  (~>(Agent.hasObject (VAL @agentName) (VAL @heldObject)))
				  (!(DatabaseInterface.remove (AGENT-STATEMENT PR2_ROBOT @agentName hasInHand (VAL @heldObject)) @result))				  
				  )
			    )
			 )
		      )
		   (!(= @sphereId (+ @sphereId 1)))	 
		   )
	     
	     )
	  
	  )  	  
   )
 )




