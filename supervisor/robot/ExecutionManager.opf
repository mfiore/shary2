
;; -*-Lisp-*-
;;author: Michelangelo Fiore
;;this module contains high-level actions like take an item, give, drop.
(

 (defop |init|
   :invocation(!(ExecutionManager.init))
   :documentation "Inits the module"
   :body (
          (!(SEM-CREATE ExecutionManager.sem 1 SEM-FIFO))
          (=>(ExecutionManager.freeId 0))

	  )

   )
 
 (defop |getFreeId|
   :invocation(!(ExecutionManager.getFreeId $id))
   :documentation "Returns an id to use in executions"
   :body (
	  (!(SEM-P ExecutionManager.sem))
	  (?(ExecutionManager.freeId $id))
	  (=>(ExecutionManager.freeId (+ $id 1)))
	  (!(SEM-V ExecutionManager.sem))
	 
	 )
   )


(defop |chooseArmForTake|
  :invocation(!(ExecutionManager.chooseArmForTake @object @executionId $armForTake))
  :documentation "Utility procedure to choose an arm for grasping. Returns the arm for the take action"
  :body (
	 (?(Spark.robotName @robotName)) 
	 (?(Spark.robotTorso @torso))

     (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) (VAL @robotName) RIGHT @o) (. @o .) @resultRight))
     (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) (VAL @robotName) LEFT @o) (. @o2 .) @resultLeft))

     ;;If the robot has only one free arm try the take action with that arm.
     (IF(?(~(NULL @resultRight)))
        (!(= $armForTake LEFT))

        ELSEIF(?(~(NULL @resultLeft)))
        (!(= $armForTake RIGHT))

        ELSE
         ;;otherwise calculate which is the best arm to use based on the object position relative to the robot
	     
	     (!(Spark.getFreeId @sparkId))
         (=>(Spark.request getJointAbsPose (VAL @object) "NO_NAME" (VAL @sparkId)))
         (!(ReportManager.sub Spark.report @sparkId))
         (^(Spark.report (VAL @sparkId) @sparkReport))
         (!(ReportManager.unsub Spark.report @sparkId))
         (IF(?(~(EQUAL @sparkReport "OK")))
            (!(ReportManager.publish ExecutionManager.report @executionId @sparkReport))

            (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
            (!(FAILED))
		)
	     (^(Spark.result (VAL @sparkId) @xOb @yOb @zOb @yawOb @pitchOb @rollOb))
	     (~>(Spark.result (VAL @sparkId) @xOb @yOb @zOb @yawOb @pitchOb @rollOb))

	     
	     (!(Spark.getFreeId @sparkId))
         (=>(Spark.request getJointAbsPose (VAL @robotName ) (VAL @torso) (VAL @sparkId)))
         (!(ReportManager.sub Spark.report @sparkId))
         (^(Spark.report (VAL @sparkId) @sparkReport))
         (!(ReportManager.unsub Spark.report @sparkId))

         (IF(?(~(EQUAL @sparkReport "OK")))
            (!(ReportManager.publish @executionId @sparkReport))


            (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
            (!(FAILED))
		)
	     (^(Spark.result (VAL @sparkId) @xTorso @yTorso @zTorso @yawTorso @pitchTorso @rollTorso))
	     (~>(Spark.result (VAL @sparkId) @xTorso @yTorso @zTorso @yawTorso @pitchTorso @rollTorso))

	      
	     (IF(?(> @yOb @yTorso))
		(!(= $armForTake RIGHT))
		
		ELSE
		(!(= $armForTake LEFT))
		)
	     )
	  
	  )
  )


(defop |cleanModuleRequestes|
  :invocation(!(ExecutionManager.cleanModuleRequestes))
  :documentation "When we stop an action we want to stop all the living requestes like detectPression"
  :body (

	 (IF(?(Robot.joints RIGHT_ARM))
	    (IF(?(ArmActions.hasDetectPressionRequest @gripper @mode @smId))
	       (~>(ArmActions.hasDetectPressionRequest (VAL @gripper) (VAL @mode) (VAL @smId)))
	       (?(Softmotion.gripperCancel (VAL @gripper) @state))
           (!(Softmotion.getFreeId @smId))
           (!(ReportManager.sub Softmotion.report @smId))
	       (=>(Softmotion.request useGripper @state @smId))
           (^(Softmotion.report (VAL @smId) @report))
           (!(ReportManager.unsub Softmotion.report @smId))
	       )
	    (^(Robot.isMoving RIGHT_ARM FALSE))
	    (^(Robot.isMoving LEFT_ARM FALSE))
	    )
	 )
  )


 (defop |handleReport|
   :invocation(!(ExecutionManager.handleReport @module @id @executionId @stoppable @haltable @failureConditions))
   :documentation "Utility function to avoid some code duplication when waiting for the response of a genom module. This can't be used when we don't want to fail if the genom request fails
                   @module is the name of the module we are waiting a report (Spark, Softmotion...)
                   @id is the id of the request we are waiting a report
                   @executionId is the id of the current execution
                   @stoppable is TRUE when we want to be able to stop while waiting for a report
                   @haltable is not currently used but we keep it since this crap changed a lot of times ^^
                   @failureConditions (. .) or ( @addConditions @removeConditions) where the two var are lists of database facts is used to set a fact into the database if the report is a failure "
   :body (
	  (!(= @reportName (TERM-STRING-CAT (VAL @module) ".report")))   ;we create the real report name
	  (!(= @reportName (MAKE-ATOM @reportName)))

      ;;we wait until we have a report, we are stopped or paused.
      (!(ReportManager.sub @reportName @id))
      (^(||
         (@reportName (VAL @id) @report)
         (& (EQUAL @stoppable TRUE)
            (|| (Monitor.handPositionDanger TRUE) (ExecutionManager.stop (VAL @executionId))))

            ))
	 
     (IF(?(@reportName (VAL @id) @report))   ;if we have a report
        (!(ReportManager.unsub @reportName @id))

	    (IF(?(~(EQUAL @report "OK")))   ; if we have a negative report we quit
           (!(PRINT @report))
           (!(ReportManager.publish ExecutionManager.report @executionId "FAILURE"))
           (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
	       (!(ExecutionManager.cleanModuleRequestes))
           (IF(?(~(NULL @failureConditions)))
              (!(== (VAL @failureConditions) (. @addConditions @removeConditions .))) ;;the con

              (!(DatabaseInterface.addSetRemoveFacts @addConditions (. .) @removeConditions @result))
              )
	       (!(FAILED))
	       )
	     
        ELSEIF(?(&(|| (ExecutionManager.stop (VAL @executionId) (Monitor.handPositionDanger TRUE ))) (EQUAL @stoppable TRUE)))
	    
	    (~>(ExecutionManager.stop (VAL @executionId)))
	    (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
        (IF(?(EQUAL @module ArmActions)) ;;we stop the corresponding module (only for some modules actually)
	       (=>(ArmActions.stop @id))

           ELSEIF(?(EQUAL @module Gtp))
	       (=>(GtpActions.stop @id))

	       ELSEIF(?(EQUAL @module BaseActions))
	       (=>(BaseActions.stop @id))
	       )       
	    
        (^(@reportName (VAL @id) @report))
        (!(ReportManager.unsub @reportName @id))

        (!(ReportManager.publish ExecutionManager.report @executionId "STOPPED")) ;;and publish a stopped report

	    (!(ExecutionManager.cleanModuleRequestes))

	    (!(FAILED))
	    )
	 )
   )


   

 (defop |take|
   :invocation(ExecutionManager.execute take @parameters @executionId)
   :documentation "this procedure takes the object @object. @arm can be setted to one of the two arms (RIGHT or LEFT) or to NO_NAME. In that case the robot chooses the arm to compute the action"
   :body (
          (!(= @object (CAR @parameters)))
          (!(= @parameters (CDR @parameters)))
          (!(= @arm (CAR(@parameters))))
          (!(= @parameters (CDR @parameters)))

          (?(Robot.name @robotName))
          (!(= @preCondParameters (. (VAL @robotName) (VAL @object) .)))
          (!(Actions.checkPreconditions take @preCondParameters @result))

          (IF(?(ExecutionManager.isActive execution SIM))  ;;if we are in sim we don't execute the action but just set the postconditions
             (IF(?(EQUAL @result TRUE))
                (!(= @postParameters (. (VAL @robotName) (VAL @object) RIGHT .)))
                (!(Actions.setPostconditions take @postParameters))
                (!(ReportManager.publish ExecutionManager.report @executionId "OK"))

                ELSE
                (!(ReportManager.publish ExecutionManager.report @executionId FAILED))
                )
             (!(FAILED))
             )


          (=>(ExecutionManager.isExecutingAction (VAL @executionId)))

          ;;we move to manipulation pose
          (!(= @moveToPoseParams (. MANIP .)))
          (!(ExecutionManager.getFreeId @moveToPoseId))
          (=>(ExecutionManager.execute moveToPose @moveToPoseParams @moveToPoseId ))
          (!(ExecutionManager.handleReport ExecutionManager @moveToPoseId @executionId TRUE TRUE (. .)))



	  ;;set the parameters for the monitor manager
       (!(= @failureConditions (. (. .)  (. (ExecutionManager.report (VAL @executionId) "FAILURE") (ExecutionManager.report (VAL @executionId) "STOPPED") .) .) )) 	 ; stops monitoring if we fail or if we are stopped
      (!(= @successConditions (. (. (ExecutionManager.report (VAL @executionId) "OK") .)  (. .) .) ))     ; look at the item until execution is completed
	  

      (!(MonitorManager.getFreeId @monitorId))
      (!(MonitorManager.sub ExecutionManager.report @executionId @monitorId))

      ;;start the monitoring
	  (!(MonitorManager.monitorTarget @object "NO_NAME" @successConditions @failureConditions HIGH @monitorId))
	  
	  (WHILE(?(~(MonitorManager.isMonitoringTarget (VAL @monitorId)))) ;until the monitor starts
		(^(|| (MonitorManager.isMonitoringTarget (VAL @monitorId)) (MonitorManager.report (VAL @monitorId) @monitorReport ))) ;wait until the monitoring starts or it returns a value (which would be an error, a cancel or a stopped status since it can't succed before execution starts.
		
        (IF(?(MonitorManager.report (VAL @monitorId) @report)) ;;there's an error (like object not present) or the monitoring has been stopped or canceled
		   (~>(MonitorManager.report (VAL @monitorId) @report))
           (IF(?(EQUAL @report "STOPPED"))

              (!(ReportManager.publish ExecutionManager.report  (VAL @executionId) "STOPPED")) ;pause the execution and go back to the loop
              ELSEIF(?(EQUAL @report "CANCELED"))
              (!(ReportManager.publish ExecutionManager.report @executionId "FAILURE"))


		      (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
		      (!(FAILED))
		      
              ELSE  ;unhandled report
              (!(ReportManager.publish ExecutionManager.report @executionId @report))


		      (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
		      (!(FAILED))
		      )
		   )	
		)
	  ;;everything is good. Monitoring has started. We can choose an arm for take if needed
 
	  (IF(?(EQUAL @arm NO_NAME)) 
	     (!(ExecutionManager.chooseArmForTake @object @executionId @armForPick))
	    
	     ELSE
	     (!(= @armForPick @arm))
	     )


	  ;;open gripper if needed
	  (IF(?(Robot.gripperStatus (VAL @armForPick) CLOSE))
	     (!(ArmActions.getFreeId @actionId))
	     (=>(ArmActions.action openGripper @armForPick @actionId))
	     (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE (. .)))
	     )


	  ;; ;;plan and execute the trajectory
      (IF(?(Module.isActive gtp TRUE)) ;;execute in gtp or armsactions
         (!(GtpActions.getFreeId @gtpId))
         (=>(GtpActions.action pick @object @armForPick @gtpId))
         ;;if we fail we set the object as not reachable
         (!(ExecutionManager.handleReport GtpActions @gtpId @executionId TRUE TRUE (. (. (AGENT-STATEMENT PR2_ROBOT (VAL @object) isReachable false) .) (. (AGENT-STATEMENT PR2_ROBOT (VAL @object) isReachableBy PR2_ROBOT) (AGENT-STATEMENT PR2_ROBOT (VAL @object) isReachable true) .) .)))
	  
	   ELSE
	   ;;plan and execute the trajectory
	   (!(ArmActions.getFreeId @actionId))
	   (=>(ArmActions.action moveToObject @armForPick @object @actionId))

	   (!(ExecutionManager.handleReport ArmActions @actionId @executionId TRUE TRUE @object)) 

	   ;;close the gripper
	   (!(ArmActions.getFreeId @actionId))
	   (=>(ArmActions.action closeGripper @armForPick @actionId))
	   (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE NO_NAME))

	   )
      (!(ReportManager.publish ExecutionManager.report  (VAL @executionId) "OK"))
      (~>(ExecutionManager.isExecutingAction (VAL @executionId)))


	  )
   
   )



 (defop |getHandoverObservations|
   :invocation(!(ExecutionManager.getHandoverObservations @agent @executionId @oldArmPosition @oldDistance @oldOrientation $armPosition $distance $orientation))
   :documentation "utility procedure that calculates the observations for the handover pomdp."
   :body (
          (?(Robot.name @robotName))

      (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) (VAL @agent) agentPresent @isPresent) (. @isPresent .) @result))
	  (IF(?(~(NULL @result)))
	     (!(= @isPresent (CAR(CAR @result))))
	     
	     ELSE
	     (!(= @isPresent FALSE))
	     )

	  (IF(?(EQUAL @isPresent TRUE))
         (IF(?(EQUAL @oldDistance outOfRange))
            (!(= @newDistance closer))
            (!(= @actualDistance CLOSE))
            (IF(?(EQUAL @oldArmPosition unknown))
               (!(= @newArmPosition closer))
               (!(= @actualArmPosition EXTENDED))
               )
		
            ELSE
            (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) (VAL @agent) distance @actualDistance) (. @actualDistance .) @result))
            (IF(?(~(NULL @result)))
               (!(= @actualDistance (CAR(CAR @result))))
               (IF(?(EQUAL @oldDistance CLOSE))
                  (IF(?(EQUAL @actualDistance FAR))
                     (!(= @newDistance farther))
                     ELSE
                     (!(= @newDistance still))
                     )
                  ELSEIF(?(EQUAL @oldDistance FAR))
                  (IF(?(EQUAL @actualDistance CLOSE))
                     (!(= @newDistance closer))

                     ELSE
                     (!(= @newDistance still))
                     )
                  )
               ELSE
               (!(= @newDistance outOfRange))
               )

	       	
            (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) (VAL @agent)  armPosition @armPosition) (. @armPosition .) @result))
            (IF(?(~(NULL @result)))
               (!(= @actualArmPosition (CAR(CAR @result))))
               (IF(?(EQUAL @oldArmPosition CLOSE))
                  (IF(?(EQUAL @actualArmPosition EXTENDED))
                     (!(= @newArmPosition closer))
                     ELSE
                     (!(= @newArmPosition still))
                     )
                  ELSEIF(?(EQUAL @oldArmPosition EXTENDED))
                  (IF(?(EQUAL @actualArmPosition EXTENDED))
                     (!(= @newArmPosition still))

                     ELSE
                     (!(= @newArmPosition farther))
                     )
                  )
               ELSE
               (!(= @newArmPosition unknown))
               )
            )
	     (!(= @newOrientation still))
	     ELSE
	     (!(= @newDistance outOfRange))
	     (!(= @newArmPosition unknown))
	     (!(= @newOrientation unknown))
	     )
	  (!(= $distance (VAL @newDistance)))
	  (!(= $armPosition (VAL @newArmPosition)))
	  (!(= $orientation (VAL @newOrientation)))

	  (=>(ExecutionManager.oldDistance @actualDistance))
	  (=>(ExecutionManager.oldOrientation STILL))
	  (=>(ExecutionManager.oldArmPosition @actualArmPosition))
	  
	  )
   )


(defop |getQForHuman|
  :invocation (!(ExecutionManager.getQForHuman @arm @agent $finalQ0))
  :documentation "calculates a q0 value so that the arm is oriented toward the agent. This procedure at the moment is implemented only for the right arm. NEEDS TO BEUPDATED"
  :body (
	 (?(Spark.robotName @sparkRobotName))
	 (?(Spark.humanTorso @hTorso))
	 (?(Robot.position TORSO @robotTorsoX @robotTorsoY @robotTorsoZ @robotTorsoYaw @robotTorsoPitch @robotTorsoRoll))
	 ;;get the human position
     (!(Spark.getFreeId @sparkId))
     (!(ReportManager.sub Spark.report @sparkId))
	 (=>(Spark.request getJointAbsPose (VAL @agent) (VAL @hTorso) (VAL @sparkId)))
	 (^(Spark.report (VAL @sparkId) @report))
     (!(ReportManager.unsub Spark.report @sparkId))

	 
	 (^(Spark.result (VAL @sparkId) @humanTorsoX @humanTorsoY @humanTorsoZ @humanTorsoYaw @humanTorsoPitch @humanTorsoRoll))
	 (~>(Spark.result (VAL @sparkId) (VAL @humanTorsoX) (VAL @humanTorsoY) (VAL @humanTorsoZ) (VAL @humanTorsoYaw) (VAL @humanTorsoPitch) (VAL @humanTorsoRoll)))
	 (!(= @q0 0.4))
	 (!(= @difference (- @robotTorsoX @humanTorsoX)))
	 (!(= @q0 (- @q0 @difference)))

	 (IF(?(> @q0 0.7))
	    (!(= @q0 0.7))
	    ELSEIF(?(< @q0 -0.7))
	    (!(= @q0 0.7))
	    )
	 (!(= $finalQ0 (VAL @q0)))
	 
	 )
  
  )

(defop |simpleHandover|
  :invocation(ExecutionManager.execute simpleHandover @parameters @executionId)
  :documentation "a simple version of the handover that doesn't use pomdps"
  :body (
         (?(Robot.name @robotName))
         (!(= @type (CAR @parameters)))
         (!(= @parameters (CDR @parameters)))
         (!(= @object (CAR @parameters)))
         (!(= @parameters (CDR @parameters)))
         (!(= agent (CAR @parameters)))
         (!(= @parameters (CDR @parameters)))

         (IF(?(EQUAL @type GRAB))
            (!(= @preCondParameters (. @agent @object @robotName .)))

            ELSE
            (!(= @preCondParameters (. @robotName @agent @object .)))
            )

         (!(Actions.checkPreconditions handover @preCondParameters @result))
         (IF(?(EQUAL @result FALSE))
            (!(ReportManager.publish ExecutionManager.report @executionId "FAILURE"))
            (!(FAILED))
            )

         (IF(?(ExecutionManager.isActive execution SIM))
            (^(ELAPSED-TIME (TIME) 1))
            (IF(?(EQUAL @type GRAB))
               (!(= @postParameters (. @agent @object @robotName RIGHT .)))
               ELSE
               (!(= @postParameters (. @robotName @agent @object .)))
               )

            (!(Actions.setPostconditions handover @postParameters))
            (!(ReportManager.publish ExecutionManager.report @executionId "OK"))
            (!(FAILED))
            )




         (?(Spark.robotTorso @rTorso))
         (?(Spark.humanHead @humanHead))

         (!(= @monitorSuccessConditions (. (. (ExecutionManager.report (VAL @executionId) "OK") .) (. .) .)))
         (!(= @monitorFailureConditions  (. (. .) (. (ExecutionManager.report (VAL @executionId) "FAILURE") (ExecutionManager.report (VAL @executionId) "STOPPED") .) .)))


         ;;choose arm. We are sure that the robot has a free arm and has the object since we looked for that in the preconditions
         (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) RIGHT @o) (. @o .) @result))
         (IF(?(EQUAL @type GRAB))
            (IF(?(NULL @result))
               (!(= @arm RIGHT))
               ELSE
               (!(= @armLeft))
               )
            ;;open the gripper to grab
            (!(ArmActions.getFreeId @gripperId))
            (!(ArmActions.execute openGripper @arm @gripperId))
            (!(ArmACtions.handleReport ArmActions @gripperId @executionId FALSE FALSE (. .)))


            ELSE
            (IF(?(NULL @result))
               (!(= @arm LEFT))
               ELSE
               (!(= @arm RIGHT))
               )
         )
         (=>(ExecutionManager.isExecutingAction (VAL @executionId)))
         (?(Spark.robotName @sparkRobotName))

         (!(GtpActions.getFreeId @gtpId))
         (=>(GtpActions.action  moveTo take @gtpId))
         (!(ExecutionManager.handleReport GtpActions @gtpId @executionId FALSE TRUE (. .)))

         (!(ArmActions.getFreeId @detectPressionId))
         (=>(ArmActions.action detectPression @arm @type @detectPressionId))
         (!(ExecutionManager.handleReport ArmActions @detectPressionId @executionId FALSE TRUE (. .)))

         (IF(?(EQUAL @type GIVE))
            (!(ArmActions.getFreeId @actionId))
            (!(ReportManager.sub ArmActions.report @actionId))
            (=>(ArmActions.action openGripper @arm @actionId))
            (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE (. .)))
            (!(= @postParams (. @robotName @object @agent @arm .)))

            ELSEIF(?(EQUAL @type GRAB))
            (!(ArmActions.getFreeId @actionId))
            (=>(ArmActions.action closeGripper @arm @actionId))
            (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE (. .)))
            (!(= @postParams (. @agent @object @robotName @arm .)))
            )


         (!(Actions.setPostconditions handover @postParams))
         (!(ExecutionManager.cleanModuleRequestes))

         (!(ReportManager.publish ExecutionManager.report  @executionId "OK"))


         (~>(ExecutionManager.isExecutingAction (VAL @executionId)))



         )


  )



(defop |give|
  :invocation(ExecutionManager.execute handover @parameters @executionId)
  :documentation "this procedure gives the object @object to the agent @agent. If the robot doesn't have the @item it fails"
  :body (
         (?(Robot.name @robotName))

         (!(= @type (CAR @parameters)))
         (!(= @parameters (CDR @parameters)))
         (!(= @object (CAR @parameters)))
         (!(= @parameters (CDR @parameters)))
         (!(= agent (CAR @parameters)))
         (!(= @parameters (CDR @parameters)))

         (IF(?(EQUAL @type GRAB))
            (!(= @preCondParameters (. (VAL @agent) (VAL @object) (VAL @robotName) .)))
            ELSE
            (!(= @preCondParameters (. (VAL @robotName) (VAL @object) (VAL @agent) .)))
            )

         (!(Actions.checkPreconditions handover @preCondParameters @result))
         (IF(?(EQUAL @result FALSE))
            (!(ReportManager.publish ExecutionManager.report @executionId "FAILURE"))
            (!(FAILED))
            )
         (IF(?(EQUAL @type GRAB))
            (!(= @postParameters (. (VAL @agent) (VAL @object) (VAL @robotName) RIGHT .)))
            ELSE
            (!(= @postParameters (. (VAL @robotName) (VAL @object) (VAL @agent) RIGHT .)))
            )
         (IF(?(ExecutionManager.isActive execution SIM))
            (^(ELAPSED-TIME (TIME) 1))
               (!(Actions.setPostconditions handover @postParameters))
               (!(ReportManager.publish ExecutionManager.report @executionId "OK"))
               (!(FAILED))
            )




         (!(= @observationWaitTime 0)) ;time to wait to get new observations
         (!(= @maxEngage 3))           ;number of times the robot will try to re-engage the user before understanding he's not interested
         (!(= @nEngage 0))             ;number of times the robot has engaged the user
         (!(= @waitTime 20))          ;time to wait before engaging the user
	 
         (?(Spark.robotTorso @rTorso))
         (?(Spark.humanHead @humanHead))
         (!(= @monitorSuccessConditions (. (. (ExecutionManager.report (VAL @executionId) "OK") .) (. .) .)))
         (!(= @monitorFailureConditions  (. (. .) (. (ExecutionManager.report (VAL @executionId) "FAILURE") (ExecutionManager.report (VAL @executionId) "STOPPED") .) .)))

         ;;choose arm. We are sure that the robot has a free arm and has the object since we looked for that in the preconditions
         (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) RIGHT @o) (. @o .) @result))
         (IF(?(EQUAL @type GRAB))
            (IF(?(NULL @result))
               (!(= @arm RIGHT))
               ELSE
               (!(= @armLeft))
               )
            ;;open the gripper to grab
            (!(ArmActions.getFreeId @gripperId))
            (!(ArmActions.execute openGripper @arm @gripperId))
            (!(ArmACtions.handleReport ArmActions @gripperId @executionId FALSE FALSE (. .)))

            ELSE
            (IF(?(NULL @result))
               (!(= @arm LEFT))
               ELSE
               (!(= @arm RIGHT))
               )
            )

         (=>(ExecutionManager.isExecutingAction (VAL @executionId)))
         (?(Spark.robotName @sparkRobotName))

         ;;starting values of observations
         (!(= @oldArmPosition UNKNOWN))
         (!(= @oldDistance outOfRange))
         (!(= @oldOrientation UNKNOWN))
         ;;Set the starting variables. We only compute observations to set inRange at the start.
         (!(ExecutionManager.getHandoverObservations @agent @oldArmPosition @oldDistance @oldOrientation  @executionId @armPosition @distance @orientation))
         (IF(?(EQUAL @distance outOfRange))
            (!(= @inRange false))
            (!(= @q0 0))  ;set the starting q0. This manouvres the robot arm horizontal position so that it can follow the human when it moves.
            ELSE
            (!(= @inRange true))
            (!(ExecutionManager.getQForHuman @arm @agent @q0))
            (IF(?(~(AgentActionMonitor.isMonitoringAgent (VAL @agent) @monitorId)))
               (!(AgentActionMonitor.startMonitoringAgent @agent))
               )

            )
	 
         (!(= @task notCompleted))
         (!(= @time ok))
         (!(= @xState (TERM-STRING-CAT @inRange @task @time)))
	 
         ;;init the POMDP
         (!(POMDP.init Handover @xState @action @yState))
         (!(= @robotState armRest))  ;;possible states are armRest armReady and armExtended
	 
         (WHILE(?(& (~(ExecutionManager.stop (VAL @executionId))) (~(ExecutionManager.report (VAL @executionId) @anyReport)) (~(EQUAL @action ABANDON)))) ;loop until we are stopped, we get a report (means we fail basically) or we abandon the task
	       
	       ;;we extend the arm if:
	       ;;the arm is not extended and:
	       ;;-we get a continue action
	       ;;we get a wait action and the user is engaged.
	       
               (IF(?(& (~(EQUAL @robotState armExtended)) (|| (EQUAL @action CONTINUE) (& (EQUAL @action WAIT) (EQUAL @yState engaged)))))  ;if user is engaged and arm is not extended extend it
                  (IF(?(ArmActions.detectPression (VAL @arm) @mode @smId)) ;if we are waiting for grasp we close the gripper, move and then relaunch release to avoid it opening because of the arm moving.
                     (!(ArmActions.getFreeId @detectPressionId))
                     (=>(ArmActions.action stopDetectPression @arm @mode @detectPressionId))
                     (!(ExecutionManager.handleReport ArmActions @detectPressionId @executionId FALSE FALSE (. .)))
		  )

                  (!(ArmActions.getFreeId @actionId))
                  (=>(ArmActions.action moveToPose EXTENDED @arm @q0 @actionId))
                  (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE TRUE (. .)))
		       
                  (!(ArmActions.getFreeId @detectPressionId))
                  (=>(ArmActions.action detectPression @arm @type @detectPressionId))

		    		  
                  (!(= @task waitingGrasp))
                  (!(= @robotState armExtended))
		  
		  
                  ;;we put the arm to ready if:
                  ;;the arm is not ready and:
                  ;;the user is not engaged and in range
                  ;;we get a WAIT or ENGAGE command
                  ;;task state is not modified here
                  ELSEIF(?(&(~(EQUAL @robotState armReady)) (EQUAL @yState notEngaged) (EQUAL @inRange true) (|| (EQUAL @action WAIT) (EQUAL @action ENGAGE))))
                  (^(Robot.isMoving (VAL @armJoint) FALSE))
                  (IF(?(ArmActions.detectPression (VAL @arm) @mode @smId)) ;if we are waiting for grasp we close the gripper, move and then relaunch release to avoid it opening because of the arm moving.
                     (!(ArmActions.getFreeId @detectPressionId))
                     (=>(ArmActions.action stopDetectPression @arm @mode @detectPressionId))
                     (!(ExecutionManager.handleReport ArmActions @detectPressionId @executionId FALSE FALSE (. .)))
                     )
                  (!(ArmActions.getFreeId @actionId))
                  (=>(ArmActions.action moveToPose READY (VAL @arm) @q0 @actionId))
                  (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE TRUE (. .)))

                  (!(ArmActions.getFreeId @detectPressionId))
                  (=>(ArmActions.action detectPression @arm @type @detectPressionId))


                  (!(= @robotState armReady))
                  (!(= @task waitingGrasp))
		
                  ;;we go to rest state if
                  ;;we receive a wait command and the user is out of range and the the robot is not in restState
                  ELSEIF(?(& (~(EQUAL @robotState armRest)) (EQUAL @inRange false) (EQUAL @action WAIT)))
                  (^(Robot.isMoving (VAL @armJoint) FALSE))
                  (IF(?(ArmActions.detectPression (VAL @arm) @mode @smId)) ;if we are waiting for grasp we close the gripper, move and then relaunch release to avoid it opening because of the arm moving.
                     (!(ArmActions.getFreeId @detectPressionId))
                     (=>(ArmActions.action stopDetectPression @arm @mode @detectPressionId))
                     (!(ExecutionManager.handleReport ArmActions @detectPressionId @executionId FALSE FALSE (. .)))
		  )
		  
                  (!(ArmActions.getFreeId @actionId))
                  (=>(ArmActions.action moveToPose MANIPULATION 0 @actionId))
                  (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE TRUE (. .)))
                  (!(= @robotState armRest))
                  (!(= @task notCompleted))
		  )
	       
	       
               (IF(?(EQUAL @action WAIT)) ;if the action is wait we start the timer (if it's not started already)
                  (IF(?(~(Timer.isRunning (VAL @timerId))))
                     (!(Timer.getFreeId @timerId))                  ;start a timer to edit the state variable time.
                     (=>(Timer.start @waitTime @timerId))
                     )

                  ELSEIF(?(EQUAL @action ENGAGE))   ;if the action is engage we stop the timer (if started) and talk to the user
                  (IF(?(Timer.isRunning (VAL @timerId)))
                     (=>(Timer.stopTimer (VAL @timerId)))
                     )
                  (IF(?(Timer.elapsedTime (VAL @timerId)))
                     (~>(Timer.elapsedTime (VAL @timerId)))
                     )
                  (!(= @time ok))
                  (IF(?(EQUAL @type GIVE))
                     (!(Acapela.say "Are you sure you want it?"))
		  
                     ELSEIF(?(EQUAL @type GRAB))
             (!(Acapela.say "Can you give that ;TODO: o me?"))
		     )
                  )
	       ;;WAIT before getting the new observations
               (^(ELAPSED-TIME (TIME) @observationWaitTime))
               (!(= @oldArmPosition @armPosition))
               (!(= @oldDistance @distance))
               (!(= @oldOrientation @orientation))
               (!(ExecutionManager.getHandoverObservations @agent @executionId @oldArmPosition @oldDistance @oldOrientation @armPosition @distance @orientation))
	       

               (IF(?(EQUAL @distance outOfRange))
                  (!(= @inRange false))
                  (!(= @q0 0))
                  ELSE
                  (!(= @inRange true))
                  (!(ExecutionManager.getQForHuman @arm @agent @qo))
                  )
	       
               (IF(?(EQUAL @task waitingGrasp)) ;if we are waiting a grasp and detecting pressure we open or close the gripper depending on the kind of handover
                  (IF(?(Robot.gripperStatus (VAL @arm) DETECTED_PRESSION))
                     (~>(Robot.gripperStatus (VAL @arm) DETECTED_PRESSION))
                     (!(ReportManager.unsub ArmActions.report @detectPressionId))


                     (IF(?(EQUAL @type GIVE))
                        (!(ArmActions.getFreeId @actionId))
                        (!(ReportManager.sub ArmActions.report @actionId))
                        (=>(ArmActions.action openGripper @arm @actionId))

                        (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE (. .)))
					     	     
                        ELSEIF(?(EQUAL @type GRAB))
                        (!(ArmActions.getFreeId @actionId))
                        (=>(ArmActions.action closeGripper @arm @actionId))
                        (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE (. .)))
                        )
                     (!(= @task completed))
                     (IF(?(EQUAL @type GIVE))
                        (!(= @postParams (. @robotName @object @agent @arm .)))

                        ELSEIF(?(EQUAL @type GRAB))
                        (!(= @postParams (. @agent @object @robotName @arm .)))
                        )
                     (!(Actions.setPostconditions @action @postParams))
                     )
                  )
               (IF(?(&(Timer.elapsedTime (VAL @timerId)) (~(EQUAL @task completed))))  ;check the timer
                  (!(= @time expired))
                  (~>(Timer.elapsedTime (VAL @timer)))
		  
                  ELSE
                  (!(= @time ok))
                  )
	 
               ;;update the pomdp
               (!(= @xState (TERM-STRING-CAT @inRange @task @time)))
               (!(= @obs (TERM-STRING-CAT @armPosition @distance @orientation)))
	       
               (!(POMDP.update Handover @obs @xState @action @yState))

	       )

                                        ;task is over. We go to rest state
         (!(ExecutionManager.cleanModuleRequestes))
	 
         (IF(?(EQUAL @task completed))
            (!(Acapela.say "Good! Thank you!"))

            (!(ReportManager.publish ExecutionManager.report  @executionId "OK"))

            ELSE
            (!(ReportManager.publish ExecutionManager.report  @executionId "FAILURE"))
            )
         (IF(?(Timer.isRunning (VAL @timerId)))
            (=>(Timer.stopTimer @timerId))
            )
         (IF(?(Timer.elapsedTime (VAL @timerId)))
            (~>(ExecutionManager.elapsedTime (VAL @timerId)))
            )

         (~>(ExecutionManager.isExecutingAction (VAL @executionId)))

         )
  )

(defop |getGuideObservations|
  :invocation(!(ExecutionManager.getGuideObservations @group  $distance $info $orientation $speed $inRange))
  :documentation "calculates observations for a group
at the moment this works only with groups of one person called (VAL @agent) and $info is not computed

@group (. @human1 @human2 ... @humann .)
$distance , $info, $orientation, $speed, $inRange  the output observations"
  :body (
      (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) (VAL @agent) agentPresent @isPresent) (. @isPresent .) @result))
	  (IF(?(~(NULL @result)))
	     (!(= @isPresent (CAR(CAR @result))))
	     
	     ELSE
	     (!(= @isPresent FALSE))
	     )

	  (IF(?(EQUAL @isPresent TRUE))
	     (!(= $info none))
         (!(Database.findList (AGENT-STATEMENT (VAL @robotName) (VAL @agent) distance @distance) (. @distance .) @result))
	     (IF(?(~(NULL @result)))
		(!(= $inRange true))
		(!(= @actualDistance (CAR(CAR @result))))
		(IF(?(EQUAL @actualDistance CLOSE))
		   (!(= $distance close))
		   
		   ELSE
		   (!(= $distance far))
		   )
		
		(!(= $distance outOfRange))
	     )
         (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) (VAL @agent) orientation @orientation) (. @orientation .) @result))
	     (IF(?(~(NULL @result)))
		(!(= @actualOrientation (CAR(CAR @result))))
		(IF(?(EQUAL @actualOrientation TOWARD_ROBOT))
		   (!(= $orientation towardRobot))
		   
		   ELSE
		   (!(= $orientation other))
		   )
		
		(!(= $orientation unknown))
	     )
         (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) (VAL @agent) speed @speed) (. @speed .) @result))
	     (IF(?(~(NULL @result)))
		(!(= @actualSpeed (CAR(CAR @result))))
		(IF(?(EQUAL @actualSpeed NOT_MOVING))
		   (!(= $speed notMoving))
		   
		   ELSEIF(?(EQUAL @actualSpeed SLOW))
		   (!(= $speed slow))

		   ELSEIF(?(EQUAL @actualSpeed NORMAL))
		   (!(= $speed normal))

		   ELSE
		   (!(= $speed fast))
		   )
		
		(!(= $speed outOfRange))
	     )

	     

	     ELSE
	     (!(= $distance outOfRange))
	     (!(= $info none))
	     (!(= $speed unknown))
	     (!(= $orientation unknown))
	     (!(= $inRange false))
	     )

	 )
  )

(defop |guide|
  :invocation(ExecutionManager.execute guide @parameters @executionId)
  :documentation "guides a group of people to a destination

@group  (. @human1 @human2 ... @humann .)
@goal ID of the semantic destination node
@executionId ID of the execution"
  :body (
         (!(= @group (CAR @parameters)))
         (!(= @parameters (CDR @parameters)))
         (!(= @goal (CAR @parameters)))
         (!(= @parameters (CDR @parameters)))




	 ;;set local function variables
     (!(= @robotStatus "STOPPED"))  ;;"STOPPED" or GUIDING
	 (!(= @nFailures 0))   ;;to deal with failures in motion planning
	 (!(= @maxFailures 3))

	 (!(ExecutionManager.getGuideObservations @group @distance @info @orientation @speed @inRange))
	 (!(= @task notCompleted))
	 (!(= @time ok))
	 (!(= @xState (TERM-STRING-CAT @inRange @task @time)))
	 (!(POMDP.init Guide @xState @action @yState))
	 (WHILE(?(& (~(EQUAL @task completed)) (~(EQUAL @action ABANDON)) (ExecutionManager.stop (VAL @executionId))))
	       (IF(?(EQUAL @action CONTINUE))
              (IF(?(EQUAL @robotStatus "STOPPED"))
                 (!(= @goParameters (. @goal .)))
                 (!(ExecutionManager.getFreeId @goId))
                 (=>(ExecutionManager.execute go @goParameters @goId))
                 (!(= @robotStatus GUIDING))
		     )
		  
		  ELSEIF(?(EQUAL @action WAIT))
		  (IF(?(EQUAL @robotStatus GUIDING))
		     (=>(ExecutionManager.stop @goId))
             (!(= @robotStatus "STOPPED"))
		     )
		  )
	       (!(ExecutionManager.getGuideObservations @group @distance @info @orientation @speed @inRange))
	       (IF(?(ExecutionManager.report (VAL @goId) @report))
          (IF(?(EQUAL @report "OK"))
		     (!(= @task completed))
		     ELSE
             (!(= @robotStatus "STOPPED"))
		     (!(= @nFailures (+ @nFailures 1)))
		     )
		  )
	       
	       (!(= @xState (TERM-STRING-CAT @inRange @task @time)))
	       (!(= @obs (TERM-STRING-CAT @distance @info @orientation @speed)))
	       (!(POMDP.update Guide @xState @obs @action @yState))
	       (IF(?(> @nFailures @maxFailures))
		  (!(= @action ABANDON))
		  )
	       )
	 
	 

	 )
  )



 (defop |throw|
   :invocation(ExecutionManager.execute throw @parameters @executionId)
   :documentation "throw an object to a certain placement"
   :body (
          (?(Robot.name @robotName))

          (!(= @object (CAR @parameters)))
          (!(= @parameters (CDR @parameters)))
          (!(= @placement (CAR @parameters)))
          (!(= @parameters (CDR @parameters)))

          (!(= @preParams (. @robotName @object @placement .)))
          (!(Actions.checkPreconditions throw @preParams @result))
          (IF(?(EQUAL @result FALSE))
             (!(ReportManager.publish ExecutionManager.report @executionId "FAILURE"))
             (!(FAILED))
             )
          (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) RIGHT @o) (. @o .) @result))
          (IF(?(NULL @result))
             (!(= @arm LEFT))

             ELSE
             (!(= @arm RIGHT))
             )
          (!(= @postParams (. @robotName @object @placement @arm .)))
          (IF(?(ExecutionManager.isActive execution SIM))
             (!(Actions.setPostconditions throw @postParams))
             (!(ReportManager.publish ExecutionManager.report @executionId "OK"))
             (!(FAILED))
             )


          (=>(ExecutionManager.isExecutingAction (VAL @executionId)))

          ;;set the parameters for ehe monitor manager
          (!(= @failureConditions (. (. .)   (. (ExecutionManager.report (VAL @executionId) "FAILURE") (ExecutionManager.report (VAL @executionId) "STOPPED") .) .) )) 	 ; item not there
          (!(= @successConditions (. (. (ExecutionManager.report (VAL @executionId) "OK") .)  (. .) .) ))     ; when the execution starts the robot is free to monitor something else
	  
          (!(MonitorManager.getFreeId @monitorId))
          (!(MonitorManager.sub ExecutionManager.report @executionId @monitorId))
                                        ;start the monitoring
          (!(MonitorManager.monitorTarget (VAL @placement) "NO_NAME" (VAL @successConditions) (VAL @failureConditions) HIGH (VAL @monitorId)))
          (^(MonitorManager.isMonitoringTarget (VAL @monitorId)))


                                        ;get coordinates of the placement
          (!(Spark.getFreeId @sparkId))
          (=>(Spark.request getJointAbsPose (VAL @placement) NO_NAME (VAL @sparkId)))
          (!(ExecutionManager.handleReport Spark (VAL @sparkId) (VAL @executionId) FALSE FALSE (. .)))
          (^(Spark.result (VAL @sparkId) @xp @yp @zp @yawp @pitchp @rollp))
          (~>(Spark.result (VAL @sparkId) (VAL @xp) (VAL @yp) (VAL @zp) (VAL @yawp) (VAL @pitchp) (VAL @rollp)))

          ;;get the actual position for the throw
          (!(= @zf (+ @zp 0.60)))
	 

          ;;HACK! We hardcode the position of the throw to the left of the robot. That's because mhp sucks balls(i hope one of the mhp guys reads this)
	  
          (!(Softmotion.getFreeId @smId))
          (=>(Softmotion.request moveArmWithoutMhp -1.2 0 0 0 0 0 0  @smId))
          (!(ExecutionManager.handleReport Softmotion @smId @executionId FALSE FALSE @placement))
	  

          ;;execute the throw
          (!(ArmActions.getFreeId @actionId))
          (=>(ArmActions.action openGripper @arm @actionId))
          (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE @placement))

          (!(ReportManager.publish ExecutionManager.report  @executionId "OK"))


          (!(Actions.setPostconditions throw @postParams))



          (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
	  )
   
   )

(defop |place|
  :invocation(ExecutionManager.execute place @parameters @executionId)
  :documentation "Places an object on a support in a specific placement or a casual one if placement is NO_NAME. For now the casual version is not implemented"
  :body (

         (!(== (VAL @parameters) (. @object @placement .)))

         (?(Robot.name @robotName))
         (!(= @preParams (. (VAL @robotName) (VAL @object) (VAL @placement) .)))
         (!(Actions.checkPreconditions place @preParams @result))
         (IF(?(EQUAL @result FALSE))
            (!(ReportManager.publish ExecutionManager.report @executionId "FAILURE"))
            (!(FAILED))
            )
         (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) RIGHT @o) (. @o .) @result))
         (IF(?(NULL @result))
            (!(= @arm LEFT))
            ELSE
            (!(= @arm RIGHT))
            )

         (!(Spark.getFreeId @sparkId))
         (=>(Spark.request getJointAbsPose (VAL @placement) "NO_NAME" (VAL @sparkId)))
         (!(ReportManager.sub Spark.report @sparkId))
         (^(Spark.report (VAL @sparkId) @sparkReport))
         (!(ReportManager.unsub Spark.report @sparkId))
         (^(Spark.result (VAL @sparkId) @x @y @z @yaw @p @r))
         (~>(Spark.result (VAL @sparkId) @x @y @z @yaw @p @r))

         (!(= @postParams (. (VAL @robotName) (VAL  @object) (VAL @placement) (. @x @y @z .).)))
         (IF(?(ExecutionManager.isActive execution SIM))
            (!(Actions.setPostconditions place @postParams))
            (!(ReportManager.publish ExecutionManager.report @executionId "OK"))
            (!(FAILED))
            )


         (=>(ExecutionManager.isExecutingAction (VAL @executionId)))

         ;;set the parameters for ehe monitor manager
         (!(= @failureConditions (. (. .)   (. (ExecutionManager.report (VAL @executionId) "FAILURE") (ExecutionManager.report (VAL @executionId) "STOPPED") .) .) )) 	 ; item not there
         (!(= @successConditions (. (. (ExecutionManager.report (VAL @executionId) "OK") .)  (. .) .) ))     ; when the execution starts the robot is free to monitor something else

         (!(MonitorManager.getFreeId @monitorId))
         (!(MonitorManager.sub ExecutionManager.report @executionId @monitorId))
         ;;start the monitoring
         (!(MonitorManager.monitorTarget (VAL @placement) "NO_NAME" (VAL @successConditions) (VAL @failureConditions) HIGH (VAL @monitorId)))
         (^(MonitorManager.isMonitoringTarget (VAL @monitorId)))

         (!(ExecutionManager.getFreeId @poseId))
         (=>(ExecutionManager.execute moveToPose (. MANIP .) @poseId))
         (!(ExecutionManager.handleReport ExecutionManager @poseId @executionId TRUE TRUE (. .)))

         (!(GtpActions.getFreeId @gtpId))
         (=>(GtpActions.action place @object @placement NO_NAME (. .) @arm @gtpId ))
         (!(ExecutionManager.handleReport GtpActions @gtpId @executionId TRUE TRUE (. .)))

         (!(Actions.setPostconditions place @postParameters))

         (!(ReportManager.publish ExecutionManager.report  @executionId "OK"))

         (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
		  
         )
  )





(defop |closeGripper|
  :invocation(ExecutionManager.execute closeGripper @parameters @executionId)
  :documentation "closes the RIGHT or LEFT gripper."
  :body (

         (!(= @gripper (CAR @parameters)))
         (=>(ExecutionManager.isExecuting @executionId))
         (!(ArmActions.getFreeId @id))
         (=>(ArmActions.action closeGripper @gripper @id))
         (!(ExecutionManager.handleReport ArmActions @id @executionId FALSE FALSE (. .)))
         (~>(ExecutionManager.isExecuting @executionId))
         (!(ReportManager.publish ExecutionManager.report  (VAL @executionId) "OK"))
	 )
  )

(defop |openGripper|
  :invocation(ExecutionManager.execute openGripper @parameters @executionId)
  :documentation "opens the RIGHT or LEFT gripper."
  :body (
         (!(= @gripper (CAR @parameters)))

         (=>(ExecutionManager.isExecuting @executionId))
         (!(ArmActions.getFreeId @id))
         (=>(ArmActions.action openGripper @gripper @id))
         (!(ExecutionManager.handleReport ArmActions @id @executionId FALSE FALSE (. .)))
         (~>(ExecutionManager.isExecuting @executionId))
         (!(ReportManager.publish ExecutionManager.report  (VAL @executionId) "OK"))
	 )
)

(defop |goToPose|
  :invocation(ExecutionManager.execute moveToPose @parameters @executionId)
  :documentation "goes to the pose @pose with @arm RIGHT or LEFT where @q0 is the orientation of the shoulder of the robot (used only in some poses)"
  :body (
         (?(Robot.name @robotName))

         (!(= @pose (CAR @parameters)))

         (!(= @params (. (VAL @robotName) (VAL @pose) .)))

         (IF(?(ExecutionManager.isActive execution SIM))
            (!(Actions.setPostconditions moveToPose @params))
            (!(ReportManager.publish ExecutionManager.report  (VAL @executionId) "OK"))
            (!(FAILED))
            )
         (=>(ExecutionManager.isExecuting @executionId))
         (IF(?(Gtp.isActive TRUE))
            (!(GtpActions.getFreeId @id))
            (=>(GtpActions.action moveTo @pose @gtpId))
            (!(ExecutionManager.handleReport GtpActions @gtpId @executionId TRUE TRUE (. .)))

            ELSEIF(?(Softmotion.isActive TRUE))
            (!(ArmActions.getFreeId @id))
            (=>(ArmActions.action moveToPose @pose @arm @q0 @id))
            (!(ExecutionManager.handleReport ArmActions @id @executionId TRUE TRUE (. .)))
            (~>(ExecutionManager.isExecuting @executionId))
            )
         (!(ReportManager.publish ExecutionManager.report  (VAL @executionId) "OK"))
	 )
  )
(defop |go| 
  :invocation (ExecutionManager.execute go @parameters  @executionId)
  :documentation "Operation to make the robot reach a destination. @goal is the node in the map the should be reached, @subgoal the item"
  :body (

         (!(= @goal (CAR @parameters)))

         (?(Robot.name @robotName))
         (!(= @params (. (VAL @robotName) (VAL @goal) .)))
         (!(Actions.checkPreconditions go @params @result))
         (IF(?(EQUAL @result FALSE))
            (!(ReportManager.publish ExecutionManager.report @executionId "FAILURE"))
            (!(FAILED))
            )


         (IF(?(ExecutionManager.isActive execution SIM))
            (!(Actions.setPostconditions go @params))
            (!(ReportManager.publish ExecutionManager.report @executionId "OK"))
            (!(FAILED))
            )

         (=>(ExecutionManager.isExecutingAction @executionId))
         (!(ExecutionManager.getFreeId @poseId))
         (=>(ExecutionManager.execute moveToPose (. NAV .) @poseId))
         (!(ExecutionManager.handleReport ExecutionManager @poseId @executionId TRUE TRUE (. .) ))

         (IF(?(Waypoints.isActive  FALSE))
            ;;get list of nodes in semantic map
            (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) (VAL @robotName) isAt @l) (. @l .) @result))

            (!(= @source (CAR(CAR @result))))
            (IF(?(PathPlanner.isActive TRUE))
               (!(PathPlanner.getFreeId @pathPlannerId))
               (=>(PathPlanner.plan @source @goal @pathPlannerId))
               (!(ExecutionManager.handleReport PathPlanner @pathPlannerId @executionId TRUE TRUE NO_NAME))
               (?(PathPlanner.result @pathPlannerId @path))
               ;;get coordinates in these nodes
               (!(PathPlanner.getCoordinates @path @waypoints))

               ELSE
               (?(PathPlanner.coordinates (VAL @goal) @x @y @theta))
               (!(= @waypoints (. (. @x @y @theta .) .)))
               )
            ;;move to place
            (!(BaseActions.getFreeId @baseActionsId))
            (=>(BaseActions.action move @waypoints @baseActionsId))
            (!(ExecutionManager.handleReport BaseActions @baseActionsId @executionId FALSE TRUE (. .)))

            ELSE
            (?(PathPlanner.getCoordinates (VAL @goal) @x @y @theta))
            (!(Mhp.getFreeId @mhpId))
            (!(ReportManager.sub Mhp.report @mhpId))
            (=>(Mhp.request benPlanif @x @y @theta))
            (!(ExecutionManager.handleReport BaseActions (VAL @stopId) @executionId FALSE FALSE (. .)))
            )

         (?(PathPlanner.translate (VAL @goal) @tLocation))


         (~>(ExecutionManager.isExecutingAction @executionId))

         (!(Actions.setPostconditions go @params))
         (!(ReportManager.publish ExecutionManager.report  (VAL @executionId) "OK"))
         )

  )

(defop |startGuide| 
  :invocation(ExecutionManager.execute startGuide @executionId)
  :body (
         (?(Robot.name @robotName))
         (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) (VAL @robotName) isClosestTo @agentId) (. @agentId .) @result))
         (IF(?(~(NULL @result)))
            (!(= @agentToGuide (CAR(CAR @result))))
            )
         (=>(ExecutionManager.execute simplifiedGuide  @agentToGuide @executionId))
         )
  )


  (defop |simplifiedGuide|
    :invocation(ExecutionManager.execute simplifiedGuide @agentToGuide @executionId)
    :body (

       ;;set local function variables
	 (?(Robot.name @robotName))
	 
	 (!(= @start (. (. 0 0 0 .) .)))
	 (!(= @goal (. (. -4.8 9 -90 .) .)))
		   
	 ;;add a monitor for when the human who's followingc disappear
	 (!(DatabaseInterface.addMonitor (AGENT-STATEMENT (VAL @robotName) (VAL @agentToGuide) isPresent FALSE) (Monitor.humanNotFollowing) @result))

	 ;;start moving
	 (!(BaseActions.getFreeId @goId))
     (=>(BaseActions.action move @goal @goId))
     (!(ReportManager.sub BaseActions.report @goId))
	 (^(|| (BaseActions.report (VAL @goId) @report) (Monitor.humanNotFollowing)))
	 (!(DatabaseInterface.removeMonitor (AGENT-STATEMENT (VAL @robotName) (VAL @agentToGuide) isPresent FALSE) @result))
	 (IF(?(BaseActions.report (VAL @goId) @report))
        (!(ReportManager.publish ExecutionManager.report  @executionId "OK"))
	    
	    ELSE
	    (IF(?(Monitor.humanNotFollowing))
	       (~>(Monitor.humanNotFollowing))
	       
	       ;;Stop the robot. We assume that if we had other errors the robot is already stopped. Only time will tell if this is bullshit XD
	       (!(BaseActions.getFreeId @stopId))
	       (=>(BaseActions.action stop @stopId))
	       (!(ExecutionManager.handleReport BaseActions (VAL @stopId) @executionId FALSE FALSE (. .)))
           (^(BaseActions.report (VAL @goId) @report))
           (!(ReportManager.unsub BaseActions.report @goId))

	       )
	    
	    ;;go back to base
	    (!(BaseActions.getFreeId @backToBaseId))
	    (=>(BaseActions.action move @start @backToBaseId))
	    (!(ExecutionManager.handleReport BaseActions (VAL @backToBaseId) @executionId FALSE FALSE (. .)))
	    
        (!(ReportManager.publish ExecutionManager.report  @executionId FAILED))
	    
	    )

     )
    )
(defop |approachPerson|
  :invocation (ExecutionManager.execute approachPerson @person @executionId)
  :body (


	 (?(Robot.name @robotName))
	 
	 (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) (VAL @person) hasLocation @location) (. @location .) @result))
	 (IF(?(~(NULL @result)))
	    (!(= @location (CAR @result)))
	    )

	 (!(DatabaseInterface.addMonitor (AGENT-STATEMENT (VAL @robotName) (VAL @person) distance CLOSE) (Monitor.isCloseToPerson) @result))

     (!(BaseActions.getFreeId @goId))
     (!(ReportManager.sub BaseActions.report @goId))
	 (=>(BaseActions.action move @location @goId))
	 (^ (|| (BaseActions.report (VAL @goId) @report) (Monitor.isCloseToPerson) (ExecutionManager.stop (VAL @executionId))))

	 (IF(?(~(BaseActions.report (VAL @goId) @report)))
	    (!(BaseActions.getFreeId @stopId))
	    (=>(BaseActions.action stop @stopId))
	    (!(ExecutionManager.handleReport BaseActions @stopId @executionId FALSE FALSE (. .)))
	    
        ELSE
        (!(ReportManager.unsub BaseActions.report @goId))

	    )
	 (IF(?(Monitor.isCloseToPerson))
	    (~>(Monitor.isCloseToPerson))
        (!(ReportManager.publish ExecutionManager.report  @executionId "OK"))
	    ELSE
        (!(ReportManager.publish ExecutionManager.report  @executionId FAILED))
	    
	    )
	 (!(DatabaseInterface.removeMonitor (AGENT-STATEMENT (VAL @robotName) (VAL @person) distance CLOSE) @result))
     )
  )

(defop |Point|
  :invocation(ExecutionManager.execute pointTo @parameters @executionId)
  :body (
         (!(= @location (CAR @parameters)))

         (?(Robot.name @robotName))
         (!(= @params (. (VAL @robotName) (VAL @location) .)))
         (!(Actions.checkPreconditions pointTo @params @result))
         (IF(?(EQUAL @result FALSE))
            (!(ReportManager.publish ExecutionManager.report @executionId "FAILURE"))
            (!(FAILED))
            )


         (IF(?(ExecutionManager.isActive execution SIM))
            (!(Actions.setPostconditions pointTo @params))
            (!(ReportManager.publish ExecutionManager.report @executionId "OK"))
            (!(FAILED))
            )

         ;;close gripper if needed
         (IF(?(Robot.gripperStatus RIGHT OPEN))
            (!(ArmActions.getFreeId @actionId))
            (=>(ArmActions.action closeGripper RIGHT @actionId))
            (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE (. .)))
            )


         (?(Action.param point (VAL @location) @confName))
         (!(GtpActions.getFreeId @gtpId))
         (=>(GtpActions.action moveTo @confName @gtpId))
         (!(ExecutionManager.handleReport GtpActions @gtpId @executionId TRUE TRUE (. .)))

         (!(ReportManager.publish ExecutionManager.report @executionId "OK"))
         )
  )


)
