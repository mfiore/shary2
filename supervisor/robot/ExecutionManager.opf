
;; -*-Lisp-*-
;;author: Michelangelo Fiore
;;this module contains high-level actions like take an item, give, drop.
(

 (defop |init|
   :invocation(!(ExecutionManager.init))
   :documentation "Inits the module"
   :body (
          (!(SEM-CREATE ExecutionManager.sem 1 SEM-FIFO))
          (=>(ExecutionManager.freeId 0))

	  )

   )
 
 (defop |getFreeId|
   :invocation(!(ExecutionManager.getFreeId $id))
   :documentation "Returns an id to use in executions"
   :body (
	  (!(SEM-P ExecutionManager.sem))
	  (?(ExecutionManager.freeId $id))
	  (=>(ExecutionManager.freeId (+ $id 1)))
	  (!(SEM-V ExecutionManager.sem))
	 
	 )
   )


(defop |chooseArmForTake|
  :invocation(!(ExecutionManager.chooseArmForTake @object @executionId $armForTake))
  :documentation "Utility procedure to choose an arm for grasping. Returns the arm for the take action"
  :body (
	 (?(Spark.robotName @robotName)) 
	 (?(Spark.robotTorso @torso))

     (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) (VAL @robotName) ARM RIGHT @o) (. @o .) @resultRight))
     (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) (VAL @robotName) ARM LEFT @o) (. @o2 .) @resultLeft))

     ;;If the robot has only one free arm try the take action with that arm.
     (IF(?(~(NULL @resultRight)))
        (!(= $armForTake LEFT))

        ELSEIF(?(~(NULL @resultLeft)))
        (!(= $armForTake RIGHT))

        ELSE
         ;;otherwise calculate which is the best arm to use based on the object position relative to the robot
	     
	     (!(Spark.getFreeId @sparkId))
         (=>(Spark.request getJointAbsPose (VAL @object) "NO_NAME" (VAL @sparkId)))
         (!(ReportManager.sub Spark.report @sparkId))
         (^(Spark.report (VAL @sparkId) @sparkReport))
         (!(ReportManager.unsub Spark.report @sparkId))
         (IF(?(~(EQUAL @sparkReport "OK")))
            (!(ReportManager.publish ExecutionManager.report @executionId @sparkReport))

            (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
            (!(FAILED))
		)
	     (^(Spark.result (VAL @sparkId) @xOb @yOb @zOb @yawOb @pitchOb @rollOb))
	     (~>(Spark.result (VAL @sparkId) @xOb @yOb @zOb @yawOb @pitchOb @rollOb))

	     
	     (!(Spark.getFreeId @sparkId))
         (=>(Spark.request getJointAbsPose (VAL @robotName ) (VAL @torso) (VAL @sparkId)))
         (!(ReportManager.sub Spark.report @sparkId))
         (^(Spark.report (VAL @sparkId) @sparkReport))
         (!(ReportManager.unsub Spark.report @sparkId))

         (IF(?(~(EQUAL @sparkReport "OK")))
            (!(ReportManager.publish @executionId @sparkReport))


            (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
            (!(FAILED))
		)
	     (^(Spark.result (VAL @sparkId) @xTorso @yTorso @zTorso @yawTorso @pitchTorso @rollTorso))
	     (~>(Spark.result (VAL @sparkId) @xTorso @yTorso @zTorso @yawTorso @pitchTorso @rollTorso))

	      
	     (IF(?(> @yOb @yTorso))
		(!(= $armForTake RIGHT))
		
		ELSE
		(!(= $armForTake LEFT))
		)
	     )
	  
	  )
  )


(defop |cleanModuleRequestes|
  :invocation(!(ExecutionManager.cleanModuleRequestes))
  :documentation "When we stop an action we want to stop all the living requestes like detectPression"
  :body (

	 (IF(?(Robot.joints RIGHT_ARM))
	    (IF(?(ArmActions.hasDetectPressionRequest @gripper @mode @smId))
	       (~>(ArmActions.hasDetectPressionRequest (VAL @gripper) (VAL @mode) (VAL @smId)))
	       (?(Softmotion.gripperCancel (VAL @gripper) @state))
           (!(Softmotion.getFreeId @smId))
           (!(ReportManager.sub Softmotion.report @smId))
	       (=>(Softmotion.request useGripper @state @smId))
           (^(Softmotion.report (VAL @smId) @report))
           (!(ReportManager.unsub Softmotion.report @smId))
	       )
	    (^(Robot.isMoving RIGHT_ARM FALSE))
	    (^(Robot.isMoving LEFT_ARM FALSE))
	    )
	 )
  )


 (defop |handleReport|
   :invocation(!(ExecutionManager.handleReport @module @id @executionId @stoppable @haltable @failureConditions))
   :documentation "Utility function to avoid some code duplication when waiting for the response of a genom module. This can't be used when we don't want to fail if the genom request fails
                   @module is the name of the module we are waiting a report (Spark, Softmotion...)
                   @id is the id of the request we are waiting a report
                   @executionId is the id of the current execution
                   @stoppable is TRUE when we want to be able to stop while waiting for a report
                   @haltable is not currently used but we keep it since this crap changed a lot of times ^^
                   @failureConditions (. .) or ( @addConditions @removeConditions) where the two var are lists of database facts is used to set a fact into the database if the report is a failure "
   :body (
	  (!(= @reportName (TERM-STRING-CAT (VAL @module) ".report")))   ;we create the real report name
	  (!(= @reportName (MAKE-ATOM @reportName)))

      ;;we wait until we have a report, we are stopped or paused.
      (!(ReportManager.sub @reportName @id))
      (^(||
         (@reportName (VAL @id) @report)
         (& (EQUAL @stoppable TRUE)
            (|| (Monitor.handPositionDanger TRUE) (ExecutionManager.stop (VAL @executionId))))

            ))
	 
     (IF(?(@reportName (VAL @id) @report))   ;if we have a report
        (!(ReportManager.unsub @reportName @id))

	    (IF(?(~(EQUAL @report "OK")))   ; if we have a negative report we quit
           (!(PRINT @report))
           (!(ReportManager.publish ExecutionManager.report @executionId "FAILURE"))
           (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
	       (!(ExecutionManager.cleanModuleRequestes))
           (IF(?(~(NULL @failureConditions)))
              (!(== (VAL @failureConditions) (. @addConditions @removeConditions .))) ;;the con

              (!(DatabaseInterface.addSetRemoveFacts @addConditions (. .) @removeConditions @result))
              )
	       (!(FAILED))
	       )
	     
        ELSEIF(?(&(|| (ExecutionManager.stop (VAL @executionId) (Monitor.handPositionDanger TRUE ))) (EQUAL @stoppable TRUE)))
	    
	    (~>(ExecutionManager.stop (VAL @executionId)))
	    (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
        (IF(?(EQUAL @module ArmActions)) ;;we stop the corresponding module (only for some modules actually)
	       (=>(ArmActions.stop @id))

           ELSEIF(?(EQUAL @module Gtp))
	       (=>(GtpActions.stop @id))

	       ELSEIF(?(EQUAL @module BaseActions))
	       (=>(BaseActions.stop @id))
	       )       
	    
        (^(@reportName (VAL @id) @report))
        (!(ReportManager.unsub @reportName @id))

        (!(ReportManager.publish ExecutionManager.report @executionId "STOPPED")) ;;and publish a stopped report

	    (!(ExecutionManager.cleanModuleRequestes))

	    (!(FAILED))
	    )
	 )
   )


   

 (defop |take|
   :invocation(ExecutionManager.execute take @parameters @executionId)
   :documentation "this procedure takes the object @object. @arm can be setted to one of the two arms (RIGHT or LEFT) or to NO_NAME. In that case the robot chooses the arm to compute the action"
   :body (

          (!(= @object (CAR @parameters)))
          (!(= @parameters (CDR @parameters)))

          (IF(?(~(NULL @parameters)))
             (!(= @arm (CAR @parameters)))
             (!(= @parameters (CDR @parameters)))

             ELSE
             (!(= @arm NO_NAME))
          )

          (?(Robot.name @robotName))
          (!(= @preCondParameters (. (VAL @robotName) (VAL @object) .)))
          (!(Actions.checkPreconditions take @preCondParameters @result))

          (IF(?(ExecutionManager.isActive execution SIM))  ;;if we are in sim we don't execute the action but just set the postconditions
             (IF(?(EQUAL @result TRUE))
                (!(= @postParameters (. (VAL @robotName) (VAL @object) RIGHT .)))
                (!(Actions.setPostconditions take @postParameters))
                (!(ReportManager.publish ExecutionManager.report @executionId "OK"))

                ELSE
                (!(ReportManager.publish ExecutionManager.report @executionId FAILED))
                )
             (!(FAILED))
             )


          (=>(ExecutionManager.isExecutingAction (VAL @executionId)))

          ;;we move to manipulation pose
          (!(= @moveToPoseParams (. MANIPULATION_RIGHT .)))
          (!(ExecutionManager.getFreeId @moveToPoseId))
          (=>(ExecutionManager.execute moveToPose @moveToPoseParams @moveToPoseId ))
          (!(ExecutionManager.handleReport ExecutionManager @moveToPoseId @executionId TRUE TRUE (. .)))


      ;;set the parameters for the monitor manager

;      (!(MonitorManager.getFreeId @monitorId))
      ;;start the monitoring
 ;     (!(MonitorManager.monitorTarget @object "NO_NAME" HIGH @monitorId))
  ;    (^(|| (MonitorManager.isMonitoringTarget (VAL @monitorId)) (MonitorManager.report (VAL @monitorId) @monitorReport )))
      ;; (IF(?(~(MonitorManager.isMonitoringTarget (VAL @monitorId))))
      ;;        ;;there is an error (for example the object is not there)
      ;;        (!(ReportManager.publish ExecutionManager.report @executionId @monitorReport))
      ;;        (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
      ;;        (!(FAILED))
      ;;        )

   
	  ;;everything is good. Monitoring has started. We can choose an arm for take if needed
 
	  (IF(?(EQUAL @arm NO_NAME)) 
	     (!(ExecutionManager.chooseArmForTake @object @executionId @armForPick))
	    
	     ELSE
	     (!(= @armForPick @arm))
	     )

      ;;get the manipulation module (ex. GTP, MHP)
      (?(Manipulation.moduleName @moduleName))
      (!(= @idCommand (TERM-STRING-CAT @moduleName ".getFreeId")))
      (!(= @idCommand (MAKE-ATOM @idCommand)))
      (!(= @requestCommand (TERM-STRING-CAT  @moduleName ".request")))
      (!(= @requestCommand (MAKE-ATOM @requestCommand)))
	  ;; ;;plan and execute the trajectory

      (=>(@idCommand @pickId))
      (=>(@requestCommand pick @object @armForPick @pickId))
      (!(ExecutionManager.handleReport @moduleName @pickId @executionId TRUE TRUE (. (. (AGENT-STATEMENT PR2_ROBOT (VAL @object) isReachable false) .) (. (AGENT-STATEMENT PR2_ROBOT (VAL @object) isReachableBy PR2_ROBOT) (AGENT-STATEMENT PR2_ROBOT (VAL @object) isReachable true) .) .)))


      (=>(MonitorManager.cancelMonitoring (VAL @monitorId)))

      (!(ReportManager.publish ExecutionManager.report  (VAL @executionId) "OK"))
      (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
      )
   
   )



 (defop |getHandoverObservations|
   :invocation(!(ExecutionManager.getHandoverObservations @agent @executionId @oldArmPosition @oldDistance @oldOrientation $armPosition $distance $orientation))
   :documentation "utility procedure that calculates the observations for the handover pomdp."
   :body (
          (?(Robot.name @robotName))

      (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) (VAL @agent) agentPresent @isPresent) (. @isPresent .) @result))
	  (IF(?(~(NULL @result)))
	     (!(= @isPresent (CAR(CAR @result))))
	     
	     ELSE
	     (!(= @isPresent FALSE))
	     )

	  (IF(?(EQUAL @isPresent TRUE))
         (IF(?(EQUAL @oldDistance outOfRange))
            (!(= @newDistance closer))
            (!(= @actualDistance CLOSE))
            (IF(?(EQUAL @oldArmPosition unknown))
               (!(= @newArmPosition closer))
               (!(= @actualArmPosition EXTENDED))
               )
		
            ELSE
            (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) (VAL @agent) distance @actualDistance) (. @actualDistance .) @result))
            (IF(?(~(NULL @result)))
               (!(= @actualDistance (CAR(CAR @result))))
               (IF(?(EQUAL @oldDistance CLOSE))
                  (IF(?(EQUAL @actualDistance FAR))
                     (!(= @newDistance farther))
                     ELSE
                     (!(= @newDistance still))
                     )
                  ELSEIF(?(EQUAL @oldDistance FAR))
                  (IF(?(EQUAL @actualDistance CLOSE))
                     (!(= @newDistance closer))

                     ELSE
                     (!(= @newDistance still))
                     )
                  )
               ELSE
               (!(= @newDistance outOfRange))
               )

	       	
            (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) (VAL @agent)  armPosition @armPosition) (. @armPosition .) @result))
            (IF(?(~(NULL @result)))
               (!(= @actualArmPosition (CAR(CAR @result))))
               (IF(?(EQUAL @oldArmPosition CLOSE))
                  (IF(?(EQUAL @actualArmPosition EXTENDED))
                     (!(= @newArmPosition closer))
                     ELSE
                     (!(= @newArmPosition still))
                     )
                  ELSEIF(?(EQUAL @oldArmPosition EXTENDED))
                  (IF(?(EQUAL @actualArmPosition EXTENDED))
                     (!(= @newArmPosition still))

                     ELSE
                     (!(= @newArmPosition farther))
                     )
                  )
               ELSE
               (!(= @newArmPosition unknown))
               )
            )
	     (!(= @newOrientation still))
	     ELSE
	     (!(= @newDistance outOfRange))
	     (!(= @newArmPosition unknown))
	     (!(= @newOrientation unknown))
	     )
	  (!(= $distance (VAL @newDistance)))
	  (!(= $armPosition (VAL @newArmPosition)))
	  (!(= $orientation (VAL @newOrientation)))

	  (=>(ExecutionManager.oldDistance @actualDistance))
	  (=>(ExecutionManager.oldOrientation STILL))
	  (=>(ExecutionManager.oldArmPosition @actualArmPosition))
	  
	  )
   )


(defop |getQForHuman|
  :invocation (!(ExecutionManager.getQForHuman @arm @agent $finalQ0))
  :documentation "calculates a q0 value so that the arm is oriented toward the agent. This procedure at the moment is implemented only for the right arm. NEEDS TO BEUPDATED"
  :body (
	 (?(Spark.robotName @sparkRobotName))
	 (?(Spark.humanTorso @hTorso))
	 (?(Robot.position TORSO @robotTorsoX @robotTorsoY @robotTorsoZ @robotTorsoYaw @robotTorsoPitch @robotTorsoRoll))
	 ;;get the human position
     (!(Spark.getFreeId @sparkId))
     (!(ReportManager.sub Spark.report @sparkId))
	 (=>(Spark.request getJointAbsPose (VAL @agent) (VAL @hTorso) (VAL @sparkId)))
	 (^(Spark.report (VAL @sparkId) @report))
     (!(ReportManager.unsub Spark.report @sparkId))

	 
	 (^(Spark.result (VAL @sparkId) @humanTorsoX @humanTorsoY @humanTorsoZ @humanTorsoYaw @humanTorsoPitch @humanTorsoRoll))
	 (~>(Spark.result (VAL @sparkId) (VAL @humanTorsoX) (VAL @humanTorsoY) (VAL @humanTorsoZ) (VAL @humanTorsoYaw) (VAL @humanTorsoPitch) (VAL @humanTorsoRoll)))
	 (!(= @q0 0.4))
	 (!(= @difference (- @robotTorsoX @humanTorsoX)))
	 (!(= @q0 (- @q0 @difference)))

	 (IF(?(> @q0 0.7))
	    (!(= @q0 0.7))
	    ELSEIF(?(< @q0 -0.7))
	    (!(= @q0 0.7))
	    )
	 (!(= $finalQ0 (VAL @q0)))
	 
	 )
  
  )

(defop |simpleHandover|
  :invocation(ExecutionManager.execute simpleHandover @parameters @executionId)
  :documentation "a simple version of the handover that doesn't use pomdps"
  :body (
         (?(Robot.name @robotName))
         (!(= @type (CAR @parameters)))
         (!(= @parameters (CDR @parameters)))
         (!(= @object (CAR @parameters)))
         (!(= @parameters (CDR @parameters)))
         (!(= agent (CAR @parameters)))
         (!(= @parameters (CDR @parameters)))

         (IF(?(EQUAL @type GRAB))
            (!(= @preCondParameters (. @agent @object @robotName .)))

            ELSE
            (!(= @preCondParameters (. @robotName @agent @object .)))
            )

         (!(Actions.checkPreconditions handover @preCondParameters @result))
         (IF(?(EQUAL @result FALSE))
            (!(ReportManager.publish ExecutionManager.report @executionId "FAILURE"))
            (!(FAILED))
            )

         (IF(?(ExecutionManager.isActive execution SIM))
            (^(ELAPSED-TIME (TIME) 1))
            (IF(?(EQUAL @type GRAB))
               (!(= @postParameters (. @agent @object @robotName RIGHT .)))
               ELSE
               (!(= @postParameters (. @robotName @agent @object .)))
               )

            (!(Actions.setPostconditions handover @postParameters))
            (!(ReportManager.publish ExecutionManager.report @executionId "OK"))
            (!(FAILED))
            )



         (?(Spark.robotTorso @rTorso))
         (?(Spark.humanHead @humanHead))

         (!(= @monitorSuccessConditions (. (. (ExecutionManager.report (VAL @executionId) "OK") .) (. .) .)))
         (!(= @monitorFailureConditions  (. (. .) (. (ExecutionManager.report (VAL @executionId) "FAILURE") (ExecutionManager.report (VAL @executionId) "STOPPED") .) .)))

         ;;choose arm. We are sure that the robot has a free arm and has the object since we looked for that in the preconditions
         (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) RIGHT @o) (. @o .) @result))
         (IF(?(EQUAL @type GRAB))
            (IF(?(NULL @result))
               (!(= @arm RIGHT))
               ELSE
               (!(= @armLeft))
               )
            ;;open the gripper to grab
            (!(ArmActions.getFreeId @gripperId))
            (!(ArmActions.execute openGripper @arm @gripperId))
            (!(ArmACtions.handleReport ArmActions @gripperId @executionId FALSE FALSE (. .)))


            ELSE
            (IF(?(NULL @result))
               (!(= @arm LEFT))
               ELSE
               (!(= @arm RIGHT))
               )
         )
         (=>(ExecutionManager.isExecutingAction (VAL @executionId)))
         (?(Spark.robotName @sparkRobotName))

         (!(ExecutionManager.getFreeId @executionId))
         (=>(ExecutionManager.action  moveToPose EXTENDED @executionId))
         (!(ExecutionManager.handleReport ExecutionManager @executionId @executionId FALSE TRUE (. .)))

         (!(ArmActions.getFreeId @detectPressionId))
         (=>(ArmActions.action detectPression @arm @type @detectPressionId))
         (!(ExecutionManager.handleReport ArmActions @detectPressionId @executionId FALSE TRUE (. .)))

         (IF(?(EQUAL @type GIVE))
            (!(ArmActions.getFreeId @actionId))
            (!(ReportManager.sub ArmActions.report @actionId))
            (=>(ArmActions.action openGripper @arm @actionId))
            (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE (. .)))
            (!(= @postParams (. @robotName @object @agent @arm .)))

            ELSEIF(?(EQUAL @type GRAB))
            (!(ArmActions.getFreeId @actionId))
            (=>(ArmActions.action closeGripper @arm @actionId))
            (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE (. .)))
            (!(= @postParams (. @agent @object @robotName @arm .)))
            )


         (!(Actions.setPostconditions handover @postParams))
         (!(ExecutionManager.cleanModuleRequestes))

         (!(ReportManager.publish ExecutionManager.report  @executionId "OK"))


         (~>(ExecutionManager.isExecutingAction (VAL @executionId)))



         )


  )



(defop |give|
  :invocation(ExecutionManager.execute handover @parameters @executionId)
  :documentation "this procedure gives the object @object to the agent @agent. If the robot doesn't have the @item it fails"
  :body (
         (?(Robot.name @robotName))

         (!(= @type (CAR @parameters)))
         (!(= @parameters (CDR @parameters)))
         (!(= @object (CAR @parameters)))
         (!(= @parameters (CDR @parameters)))
         (!(= agent (CAR @parameters)))
         (!(= @parameters (CDR @parameters)))

         (IF(?(EQUAL @type GRAB))
            (!(= @preCondParameters (. (VAL @agent) (VAL @object) (VAL @robotName) .)))
            ELSE
            (!(= @preCondParameters (. (VAL @robotName) (VAL @object) (VAL @agent) .)))
            )

         (!(Actions.checkPreconditions handover @preCondParameters @result))
         (IF(?(EQUAL @result FALSE))
            (!(ReportManager.publish ExecutionManager.report @executionId "FAILURE"))
            (!(FAILED))
            )
         (IF(?(EQUAL @type GRAB))
            (!(= @postParameters (. (VAL @agent) (VAL @object) (VAL @robotName) RIGHT .)))
            ELSE
            (!(= @postParameters (. (VAL @robotName) (VAL @object) (VAL @agent) RIGHT .)))
            )
         (IF(?(ExecutionManager.isActive execution SIM))
            (^(ELAPSED-TIME (TIME) 1))
               (!(Actions.setPostconditions handover @postParameters))
               (!(ReportManager.publish ExecutionManager.report @executionId "OK"))
               (!(FAILED))
            )




         (!(= @observationWaitTime 0)) ;time to wait to get new observations
         (!(= @maxEngage 3))           ;number of times the robot will try to re-engage the user before understanding he's not interested
         (!(= @nEngage 0))             ;number of times the robot has engaged the user
         (!(= @waitTime 20))          ;time to wait before engaging the user
	 
         (?(Spark.robotTorso @rTorso))
         (?(Spark.humanHead @humanHead))
         (!(= @monitorSuccessConditions (. (. (ExecutionManager.report (VAL @executionId) "OK") .) (. .) .)))
         (!(= @monitorFailureConditions  (. (. .) (. (ExecutionManager.report (VAL @executionId) "FAILURE") (ExecutionManager.report (VAL @executionId) "STOPPED") .) .)))

         ;;choose arm. We are sure that the robot has a free arm and has the object since we looked for that in the preconditions
         (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) RIGHT @o) (. @o .) @result))
         (IF(?(EQUAL @type GRAB))
            (IF(?(NULL @result))
               (!(= @arm RIGHT))
               ELSE
               (!(= @armLeft))
               )
            ;;open the gripper to grab
            (!(ArmActions.getFreeId @gripperId))
            (!(ArmActions.execute openGripper @arm @gripperId))
            (!(ArmACtions.handleReport ArmActions @gripperId @executionId FALSE FALSE (. .)))

            ELSE
            (IF(?(NULL @result))
               (!(= @arm LEFT))
               ELSE
               (!(= @arm RIGHT))
               )
            )

         (=>(ExecutionManager.isExecutingAction (VAL @executionId)))
         (?(Spark.robotName @sparkRobotName))

         ;;starting values of observations
         (!(= @oldArmPosition UNKNOWN))
         (!(= @oldDistance outOfRange))
         (!(= @oldOrientation UNKNOWN))
         ;;Set the starting variables. We only compute observations to set inRange at the start.
         (!(ExecutionManager.getHandoverObservations @agent @oldArmPosition @oldDistance @oldOrientation  @executionId @armPosition @distance @orientation))
         (IF(?(EQUAL @distance outOfRange))
            (!(= @inRange false))
            (!(= @q0 0))  ;set the starting q0. This manouvres the robot arm horizontal position so that it can follow the human when it moves.
            ELSE
            (!(= @inRange true))
            (!(ExecutionManager.getQForHuman @arm @agent @q0))
            (IF(?(~(AgentActionMonitor.isMonitoringAgent (VAL @agent) @monitorId)))
               (!(AgentActionMonitor.startMonitoringAgent @agent))
               )

            )
	 
         (!(= @task notCompleted))
         (!(= @time ok))
         (!(= @xState (TERM-STRING-CAT @inRange @task @time)))
	 
         ;;init the POMDP
         (!(POMDP.init Handover @xState @action @yState))
         (!(= @robotState armRest))  ;;possible states are armRest armReady and armExtended
	 
         (WHILE(?(& (~(ExecutionManager.stop (VAL @executionId))) (~(ExecutionManager.report (VAL @executionId) @anyReport)) (~(EQUAL @action ABANDON)))) ;loop until we are stopped, we get a report (means we fail basically) or we abandon the task
	       
	       ;;we extend the arm if:
	       ;;the arm is not extended and:
	       ;;-we get a continue action
	       ;;we get a wait action and the user is engaged.
	       
               (IF(?(& (~(EQUAL @robotState armExtended)) (|| (EQUAL @action CONTINUE) (& (EQUAL @action WAIT) (EQUAL @yState engaged)))))  ;if user is engaged and arm is not extended extend it
                  (IF(?(ArmActions.detectPression (VAL @arm) @mode @smId)) ;if we are waiting for grasp we close the gripper, move and then relaunch release to avoid it opening because of the arm moving.
                     (!(ArmActions.getFreeId @detectPressionId))
                     (=>(ArmActions.action stopDetectPression @arm @mode @detectPressionId))
                     (!(ExecutionManager.handleReport ArmActions @detectPressionId @executionId FALSE FALSE (. .)))
		  )

                  (!(ArmActions.getFreeId @actionId))
                  (=>(ArmActions.action moveToPose EXTENDED @arm @q0 @actionId))
                  (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE TRUE (. .)))
		       
                  (!(ArmActions.getFreeId @detectPressionId))
                  (=>(ArmActions.action detectPression @arm @type @detectPressionId))

		    		  
                  (!(= @task waitingGrasp))
                  (!(= @robotState armExtended))
		  
		  
                  ;;we put the arm to ready if:
                  ;;the arm is not ready and:
                  ;;the user is not engaged and in range
                  ;;we get a WAIT or ENGAGE command
                  ;;task state is not modified here
                  ELSEIF(?(&(~(EQUAL @robotState armReady)) (EQUAL @yState notEngaged) (EQUAL @inRange true) (|| (EQUAL @action WAIT) (EQUAL @action ENGAGE))))
                  (^(Robot.isMoving (VAL @armJoint) FALSE))
                  (IF(?(ArmActions.detectPression (VAL @arm) @mode @smId)) ;if we are waiting for grasp we close the gripper, move and then relaunch release to avoid it opening because of the arm moving.
                     (!(ArmActions.getFreeId @detectPressionId))
                     (=>(ArmActions.action stopDetectPression @arm @mode @detectPressionId))
                     (!(ExecutionManager.handleReport ArmActions @detectPressionId @executionId FALSE FALSE (. .)))
                     )
                  (!(ArmActions.getFreeId @actionId))
                  (=>(ArmActions.action moveToPose READY (VAL @arm) @q0 @actionId))
                  (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE TRUE (. .)))

                  (!(ArmActions.getFreeId @detectPressionId))
                  (=>(ArmActions.action detectPression @arm @type @detectPressionId))


                  (!(= @robotState armReady))
                  (!(= @task waitingGrasp))
		
                  ;;we go to rest state if
                  ;;we receive a wait command and the user is out of range and the the robot is not in restState
                  ELSEIF(?(& (~(EQUAL @robotState armRest)) (EQUAL @inRange false) (EQUAL @action WAIT)))
                  (^(Robot.isMoving (VAL @armJoint) FALSE))
                  (IF(?(ArmActions.detectPression (VAL @arm) @mode @smId)) ;if we are waiting for grasp we close the gripper, move and then relaunch release to avoid it opening because of the arm moving.
                     (!(ArmActions.getFreeId @detectPressionId))
                     (=>(ArmActions.action stopDetectPression @arm @mode @detectPressionId))
                     (!(ExecutionManager.handleReport ArmActions @detectPressionId @executionId FALSE FALSE (. .)))
		  )
		  
                  (!(ArmActions.getFreeId @actionId))
                  (=>(ArmActions.action moveToPose MANIPULATION 0 @actionId))
                  (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE TRUE (. .)))
                  (!(= @robotState armRest))
                  (!(= @task notCompleted))
		  )
	       
	       
               (IF(?(EQUAL @action WAIT)) ;if the action is wait we start the timer (if it's not started already)
                  (IF(?(~(Timer.isRunning (VAL @timerId))))
                     (!(Timer.getFreeId @timerId))                  ;start a timer to edit the state variable time.
                     (=>(Timer.start @waitTime @timerId))
                     )

                  ELSEIF(?(EQUAL @action ENGAGE))   ;if the action is engage we stop the timer (if started) and talk to the user
                  (IF(?(Timer.isRunning (VAL @timerId)))
                     (=>(Timer.stopTimer (VAL @timerId)))
                     )
                  (IF(?(Timer.elapsedTime (VAL @timerId)))
                     (~>(Timer.elapsedTime (VAL @timerId)))
                     )
                  (!(= @time ok))
                  (IF(?(EQUAL @type GIVE))
                     (!(Acapela.say "Are you sure you want it?"))
		  
                     ELSEIF(?(EQUAL @type GRAB))
             (!(Acapela.say "Can you give that ;TODO: o me?"))
		     )
                  )
	       ;;WAIT before getting the new observations
               (^(ELAPSED-TIME (TIME) @observationWaitTime))
               (!(= @oldArmPosition @armPosition))
               (!(= @oldDistance @distance))
               (!(= @oldOrientation @orientation))
               (!(ExecutionManager.getHandoverObservations @agent @executionId @oldArmPosition @oldDistance @oldOrientation @armPosition @distance @orientation))
	       

               (IF(?(EQUAL @distance outOfRange))
                  (!(= @inRange false))
                  (!(= @q0 0))
                  ELSE
                  (!(= @inRange true))
                  (!(ExecutionManager.getQForHuman @arm @agent @qo))
                  )
	       
               (IF(?(EQUAL @task waitingGrasp)) ;if we are waiting a grasp and detecting pressure we open or close the gripper depending on the kind of handover
                  (IF(?(Robot.gripperStatus (VAL @arm) DETECTED_PRESSION))
                     (~>(Robot.gripperStatus (VAL @arm) DETECTED_PRESSION))
                     (!(ReportManager.unsub ArmActions.report @detectPressionId))


                     (IF(?(EQUAL @type GIVE))
                        (!(ArmActions.getFreeId @actionId))
                        (!(ReportManager.sub ArmActions.report @actionId))
                        (=>(ArmActions.action openGripper @arm @actionId))

                        (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE (. .)))
					     	     
                        ELSEIF(?(EQUAL @type GRAB))
                        (!(ArmActions.getFreeId @actionId))
                        (=>(ArmActions.action closeGripper @arm @actionId))
                        (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE (. .)))
                        )
                     (!(= @task completed))
                     (IF(?(EQUAL @type GIVE))
                        (!(= @postParams (. @robotName @object @agent @arm .)))

                        ELSEIF(?(EQUAL @type GRAB))
                        (!(= @postParams (. @agent @object @robotName @arm .)))
                        )
                     (!(Actions.setPostconditions @action @postParams))
                     )
                  )
               (IF(?(&(Timer.elapsedTime (VAL @timerId)) (~(EQUAL @task completed))))  ;check the timer
                  (!(= @time expired))
                  (~>(Timer.elapsedTime (VAL @timer)))
		  
                  ELSE
                  (!(= @time ok))
                  )
	 
               ;;update the pomdp
               (!(= @xState (TERM-STRING-CAT @inRange @task @time)))
               (!(= @obs (TERM-STRING-CAT @armPosition @distance @orientation)))
	       
               (!(POMDP.update Handover @obs @xState @action @yState))

	       )

                                        ;task is over. We go to rest state
         (!(ExecutionManager.cleanModuleRequestes))
	 
         (IF(?(EQUAL @task completed))
            (!(Acapela.say "Good! Thank you!"))

            (!(ReportManager.publish ExecutionManager.report  @executionId "OK"))

            ELSE
            (!(ReportManager.publish ExecutionManager.report  @executionId "FAILURE"))
            )
         (IF(?(Timer.isRunning (VAL @timerId)))
            (=>(Timer.stopTimer @timerId))
            )
         (IF(?(Timer.elapsedTime (VAL @timerId)))
            (~>(ExecutionManager.elapsedTime (VAL @timerId)))
            )

         (~>(ExecutionManager.isExecutingAction (VAL @executionId)))

         )
  )


 (defop |throw|
   :invocation(ExecutionManager.execute throw @parameters @executionId)
   :documentation "throw an object to a certain placement"
   :body (
          (?(Robot.name @robotName))

          (!(= @object (CAR @parameters)))
          (!(= @parameters (CDR @parameters)))
          (!(= @placement (CAR @parameters)))
          (!(= @parameters (CDR @parameters)))

          (!(= @preParams (. @robotName @object @placement .)))
          (!(Actions.checkPreconditions throw @preParams @result))
          (IF(?(EQUAL @result FALSE))
             (!(ReportManager.publish ExecutionManager.report @executionId "FAILURE"))
             (!(FAILED))
             )
          (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) RIGHT @o) (. @o .) @result))
          (IF(?(NULL @result))
             (!(= @arm LEFT))

             ELSE
             (!(= @arm RIGHT))
             )
          (!(= @postParams (. @robotName @object @placement @arm .)))
          (IF(?(ExecutionManager.isActive execution SIM))
             (!(Actions.setPostconditions throw @postParams))
             (!(ReportManager.publish ExecutionManager.report @executionId "OK"))
             (!(FAILED))
             )


          (=>(ExecutionManager.isExecutingAction (VAL @executionId)))

          (!(MonitorManager.getFreeId @monitorId))
          (=>(MonitorManager.monitorTarget @placement "NO_NAME" HIGH @monitorId))
          (^(MonitorManager.isMonitoringTarget (VAL @monitorId)))


                                        ;get coordinates of the placement
          (!(Spark.getFreeId @sparkId))
          (=>(Spark.request getJointAbsPose (VAL @placement) NO_NAME (VAL @sparkId)))
          (!(ExecutionManager.handleReport Spark (VAL @sparkId) (VAL @executionId) FALSE FALSE (. .)))
          (^(Spark.result (VAL @sparkId) @xp @yp @zp @yawp @pitchp @rollp))
          (~>(Spark.result (VAL @sparkId) (VAL @xp) (VAL @yp) (VAL @zp) (VAL @yawp) (VAL @pitchp) (VAL @rollp)))

          ;;get the actual position for the throw
          (!(= @zf (+ @zp 0.60)))
	 

          ;;HACK! We hardcode the position of the throw to the left of the robot. That's because mhp sucks balls(i hope one of the mhp guys reads this)
	  
          (!(Softmotion.getFreeId @smId))
          (=>(Softmotion.request moveArmWithoutMhp -1.2 0 0 0 0 0 0  @smId))
          (!(ExecutionManager.handleReport Softmotion @smId @executionId FALSE FALSE @placement))
	  

          ;;execute the throw
          (!(ArmActions.getFreeId @actionId))
          (=>(ArmActions.action openGripper @arm @actionId))
          (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE @placement))

          (!(ReportManager.publish ExecutionManager.report  @executionId "OK"))


          (!(Actions.setPostconditions throw @postParams))



          (~>(MonitorManager.cancelMonitoring (VAL @monitorId)))
          (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
	  )
   
   )

(defop |place|
  :invocation(ExecutionManager.execute place @parameters @executionId)
  :documentation "Places an object on a support in a specific placement or a casual one if placement is NO_NAME. For now the casual version is not implemented"
  :body (

         (!(== (VAL @parameters) (. @object @placement .)))

         (?(Robot.name @robotName))
         (!(= @preParams (. (VAL @robotName) (VAL @object) (VAL @placement) .)))
         (!(Actions.checkPreconditions place @preParams @result))
         (IF(?(EQUAL @result FALSE))
            (!(ReportManager.publish ExecutionManager.report @executionId "FAILURE"))
            (!(FAILED))
            )
         (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) RIGHT @o) (. @o .) @result))
         (IF(?(NULL @result))
            (!(= @arm LEFT))
            ELSE
            (!(= @arm RIGHT))
            )

         (!(Spark.getFreeId @sparkId))
         (=>(Spark.request getJointAbsPose (VAL @placement) "NO_NAME" (VAL @sparkId)))
         (!(ReportManager.sub Spark.report @sparkId))
         (^(Spark.report (VAL @sparkId) @sparkReport))
         (!(ReportManager.unsub Spark.report @sparkId))
         (^(Spark.result (VAL @sparkId) @x @y @z @yaw @p @r))
         (~>(Spark.result (VAL @sparkId) @x @y @z @yaw @p @r))

         (!(= @postParams (. (VAL @robotName) (VAL  @object) (VAL @placement) (. @x @y @z .).)))
         (IF(?(ExecutionManager.isActive execution SIM))
            (!(Actions.setPostconditions place @postParams))
            (!(ReportManager.publish ExecutionManager.report @executionId "OK"))
            (!(FAILED))
            )


         (=>(ExecutionManager.isExecutingAction (VAL @executionId)))

;         (!(MonitorManager.getFreeId @monitorId))

         ;;start the monitoring
 ;        (!(MonitorManager.monitorTarget (VAL @placement) "NO_NAME" HIGH (VAL @monitorId)))
  ;       (^(MonitorManager.isMonitoringTarget (VAL @monitorId)))

         (!(ExecutionManager.getFreeId @poseId))
         (=>(ExecutionManager.execute moveToPose (. MANIPULATION_RIGHT .) @poseId))
         (!(ExecutionManager.handleReport ExecutionManager @poseId @executionId TRUE TRUE (. .)))

         ;;get the manipulation module (ex. GTP, MHP)
         (?(Manipulation.moduleName @moduleName))
         (!(= @idCommand (TERM-STRING-CAT  @moduleName ".getFreeId")))
         (!(= @idCommand (MAKE-ATOM @idCommand)))
         (!(= @requestCommand (TERM-STRING-CAT @moduleName ".request")))
         (!(= @requestCommand (MAKE-ATOM @requestCommand)))

         (!(@idCommand @actionId))
         (=>(@requestCommand place @object @placement @actionId)
         (!(ExecutionManager.handleReport @moduleName @actionId @executionId TRUE TRUE (. .)))

         (!(Actions.setPostconditions place @postParameters))

         (!(ReportManager.publish ExecutionManager.report  @executionId "OK"))

         (=>(MonitorManager.cancelMonitoring (VAL @monitorId)))
         (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
		  
         )
  )




)
(defop |closeGripper|
  :invocation(ExecutionManager.execute closeGripper @parameters @executionId)
  :documentation "closes the RIGHT or LEFT gripper."
  :body (

         (!(= @gripper (CAR @parameters)))
         (=>(ExecutionManager.isExecuting @executionId))

         ;;get the manipulation module (ex. GTP, MHP)
         (?(Manipulation.moduleName @moduleName))
         (!(= @idcommand (TERM-STRING-CAT  @moduleName ".getFreeId")))
         (!(= @idCommand (MAKE-ATOM @idCommand)))
         (!(= @requestCommand (TERM-STRING-CAT  @moduleName ".request")))
         (!(= @requestCommand (MAKE-ATOM @requestCommand)))

         (!(@idCommand @actionId))
         (=>(@requestCommand closeGripper @gripper @actionId)
         (!(ExecutionManager.handleReport @moduleName @actionId @executionId TRUE TRUE (. .)))

            (~>(ExecutionManager.isExecuting @executionId))
         (!(ReportManager.publish ExecutionManager.report  (VAL @executionId) "OK"))
	 )
  )
)
(defop |openGripper|
  :invocation(ExecutionManager.execute openGripper @parameters @executionId)
  :documentation "opens the RIGHT or LEFT gripper."
  :body (
         (!(= @gripper (CAR @parameters)))

         (=>(ExecutionManager.isExecuting @executionId))


         ;;get the manipulation module (ex. GTP, MHP)
         (?(Manipulation.moduleName @moduleName))
         (!(= @idCommand (TERM-STRING-CAT  @moduleName ".getFreeId")))
         (!(= @idCommand (MAKE-ATOM @idCommand)))
         (!(= @requestCommand (TERM-STRING-CAT @moduleName ".request")))
         (!(= @requestCommand (MAKE-ATOM @requestCommand)))

         (!(@idCommand @actionId))
         (=>(@requestCommand openGripper @gripper @actionId)
         (!(ExecutionManager.handleReport @moduleName @actionId @executionId TRUE TRUE (. .)))

         (~>(ExecutionManager.isExecuting @executionId))
         (!(ReportManager.publish ExecutionManager.report  (VAL @executionId) "OK"))
	 )
         )
  )

(defop |moveToPose|
  :invocation(ExecutionManager.execute moveToPose @parameters @executionId)
  :documentation "goes to the pose @pose with @arm RIGHT or LEFT where @q0 is the orientation of the shoulder of the robot (used only in some poses)"
  :body (
         (?(Robot.name @robotName))

         (!(= @pose (CAR @parameters)))

         (!(= @params (. (VAL @robotName) (VAL @pose) .)))

         (IF(?(ExecutionManager.isActive execution SIM))
            (!(Actions.setPostconditions moveToPose @params))
            (!(ReportManager.publish ExecutionManager.report  (VAL @executionId) "OK"))
            (!(FAILED))
            )
         (=>(ExecutionManager.isExecuting @executionId))

         ;;get the manipulation module (ex. GTP, MHP)
         (?(Manipulation.moduleName @moduleName))
         (!(= @idCommand (TERM-STRING-CAT @moduleName ".getFreeId")))
         (!(= @idCommand (MAKE-ATOM @idCommand)))
         (!(= @requestCommand (TERM-STRING-CAT @moduleName ".request")))
         (!(= @requestCommand (MAKE-ATOM @requestCommand)))

         (!(@idCommand @actionId))
         (=>(@requestCommand moveToPose @pose @actionId))
         (!(ExecutionManager.handleReport @moduleName @actionId @executionId TRUE TRUE (. .)))


         (!(ReportManager.publish ExecutionManager.report  (VAL @executionId) "OK"))
     )
  )
(defop |go| 
  :invocation (ExecutionManager.execute go @parameters  @executionId)
  :documentation "Operation to make the robot reach a destination. @goal is the node in the map the should be reached, @subgoal the item"
  :body (

         (!(= @goal (CAR @parameters)))

         (?(Robot.name @robotName))
         (!(= @params (. (VAL @robotName) (VAL @goal) .)))
         (!(Actions.checkPreconditions go @params @result))
         (IF(?(EQUAL @result FALSE))
            (!(ReportManager.publish ExecutionManager.report @executionId "FAILURE"))
            (!(FAILED))
            )


         (IF(?(ExecutionManager.isActive execution SIM))
            (!(Actions.setPostconditions go @params))
            (!(ReportManager.publish ExecutionManager.report @executionId "OK"))
            (!(FAILED))
            )

         (=>(ExecutionManager.isExecutingAction @executionId))
         (!(ExecutionManager.getFreeId @poseId))
         (=>(ExecutionManager.execute moveToPose (. NAV .) @poseId))
         (!(ExecutionManager.handleReport ExecutionManager @poseId @executionId TRUE TRUE (. .) ))

         (IF(?(Waypoints.isActive  FALSE))
            ;;get list of nodes in semantic map
            (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) (VAL @robotName) isAt @l) (. @l .) @result))

            (!(= @source (CAR(CAR @result))))
            (IF(?(PathPlanner.isActive TRUE))
               (!(PathPlanner.getFreeId @pathPlannerId))
               (=>(PathPlanner.plan @source @goal @pathPlannerId))
               (!(ExecutionManager.handleReport PathPlanner @pathPlannerId @executionId TRUE TRUE NO_NAME))
               (?(PathPlanner.result @pathPlannerId @path))
               ;;get coordinates in these nodes
               (!(PathPlanner.getCoordinates @path @waypoints))

               ELSE
               (?(PathPlanner.coordinates (VAL @goal) @x @y @theta))
               (!(= @waypoints (. (. @x @y @theta .) .)))
               )
            ;;move to place
            (!(BaseActions.getFreeId @baseActionsId))
            (=>(BaseActions.action move @waypoints @baseActionsId))
            (!(ExecutionManager.handleReport BaseActions @baseActionsId @executionId FALSE TRUE (. .)))

            ELSE
            (?(PathPlanner.getCoordinates (VAL @goal) @x @y @theta))
            (!(Mhp.getFreeId @mhpId))
            (!(ReportManager.sub Mhp.report @mhpId))
            (=>(Mhp.request benPlanif @x @y @theta))
            (!(ExecutionManager.handleReport BaseActions (VAL @stopId) @executionId FALSE FALSE (. .)))
            )

         (?(PathPlanner.translate (VAL @goal) @tLocation))


         (~>(ExecutionManager.isExecutingAction @executionId))

         (!(Actions.setPostconditions go @params))
         (!(ReportManager.publish ExecutionManager.report  (VAL @executionId) "OK"))
         )

  )

(defop |Point|
  :invocation(ExecutionManager.execute pointTo @parameters @executionId)
  :body (
         (!(= @location (CAR @parameters)))

         (?(Robot.name @robotName))
         (!(= @params (. (VAL @robotName) (VAL @location) .)))
         (!(Actions.checkPreconditions pointTo @params @result))
         (IF(?(EQUAL @result FALSE))
            (!(ReportManager.publish ExecutionManager.report @executionId "FAILURE"))
            (!(FAILED))
            )


         (IF(?(ExecutionManager.isActive execution SIM))
            (!(Actions.setPostconditions pointTo @params))
            (!(ReportManager.publish ExecutionManager.report @executionId "OK"))
            (!(FAILED))
            )


         ;;get the manipulation module (ex. GTP, MHP)
         (?(Manipulation.moduleName @moduleName))
         (!(= @idCommand (TERM-STRING-CAT @moduleName ".getFreeId")))
         (!(= @idCommand (MAKE-ATOM @idCommand)))
         (!(= @requestCommand (TERM-STRING-CAT @moduleName ".request")))
         (!(= @requestCommand (MAKE-ATOM @requestCommand)))



         ;;close gripper if needed
         (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @robotName) right_gripper_status @s) (. @s .) @result))
         (!(= @status (CAR(CAR @result))))
         (IF(?(EQUAL OPEN))
            (!(ExecutionManager.getFreeId @actionId))
            (=>(ExecutionManager.execute closeGripper RIGHT @actionId))
            (!(ExecutionManager.handleReport ExecutionManager @actionId @executionId FALSE FALSE (. .)))
            )

         (?(Action.param point (VAL @location) @confName))

         (!(@idCommand @actionId))
         (=>(@requestCommand moveToPose @confName @actionId))
         (!(ExecutionManager.handleReport @moduleName @actionId @executionId TRUE TRUE (. .)))

           (!(ReportManager.publish ExecutionManager.report @executionId "OK"))
         )
  )


)
