;; -*-Lisp-*-
;;author: Michelangelo Fiore
;;this module contains primitive head actions. 

(
 (defop |init|
   :invocation(!(HeadActions.init))
   :documentation "inits the module"
   :body (
	  (=>(HeadActions.freeId 0))
	  (=>(Robot.isMoving HEAD FALSE))
	  (!(SEM-CREATE HeadActions.sem 1 SEM-FIFO))
	  )
   )

(defop |getFreeId|
   :invocation(!(HeadActions.getFreeId $id))
   :documentation "gets a new id for requestes"
   :body (
	  (!(SEM-P HeadActions.sem))
	  (?(HeadActions.freeId $id))
	  (=>(HeadActions.freeId (+ $id 1)))
	  (!(SEM-V HeadActions.sem))
	  )
   )

(defop |moveHeadDirection|
  :invocation(HeadActions.action moveHeadDirection @direction @actionId)
  :body (
         (!(Viman.getFreeId @vimanId))
         (=>(Viman.request stopTracking @vimanId))
         (!(HeadActions.handleReport Viman.report (VAL @vimanId) (VAL @actionId)))


         (?(HeadActions.bridgeName @bridgeName))
         (!(= @command (TERM-STRING-CAT (VAL @bridgeName) ".moveDir")))
         (!(= @reportName (TERM-STRING-CAT (VAL @bridgeName) ".report")))
         (!(= @reportName (MAKE-ATOM @reportName)))
         (!(SEND-MESSAGE (VAL @bridgeName) (@command @direction)))
         (^(|| (@reportName @report (ELAPSED-TIME (TIME) 5))))
         (~>(@reportName (VAL @report)))

         (!(Viman.getFreeId @vimanId))
         (=>(Viman.request activateTracking @vimanId))
         (!(HeadActions.handleReport Viman.report (VAL @vimanId) (VAL @actionId)))


         (=>(HeadActions.report @actionId @report))

         )

  )


(defop |lookAt|
  :invocation(HeadActions.action lookAt @target @joint @actionId)
  :documentation "this procedure moves the head to look at @target"
  :body (
         ;;Get the position of the target
         (!(Spark.getFreeId @sparkId))
         (=>(Spark.request getJointAbsPose (VAL @target) (VAL @joint) (VAL @sparkId)))
         (!(HeadActions.handleReport Spark.report (VAL @sparkId) (VAL @actionId)))
         (^(Spark.result (VAL @sparkId) @xOb @yOb @zOb @yawOb @pitchOb @rollOb))
         (~>(Spark.result (VAL @sparkId) @xOb @yOb @zOb @yawOb @pitchOb @rollOb))


         (!(Viman.getFreeId @vimanId))
         (=>(Viman.request stopTracking @vimanId))
         (!(HeadActions.handleReport Viman.report (VAL @vimanId) (VAL @actionId)))


         (?(HeadActions.bridgeName @bridgeName))
         (!(= @command (TERM-STRING-CAT (VAL @bridgeName) ".lookAt")))
         (!(= @reportName (TERM-STRING-CAT (VAL @bridgeName) ".report")))
         (!(= @reportName (MAKE-ATOM @reportName)))
         (!(SEND-MESSAGE (VAL @bridgeName) (@command @xOb @yOb @zOb)))
         (^(|| (@reportName @report) (ELAPSED-TIME (TIME) 5)))
         (~>(@reportName (VAL @report)))

         (!(Viman.getFreeId @vimanId))
         (=>(Viman.request activateTracking @vimanId))
         (!(HeadActions.handleReport Viman.report (VAL @vimanId) (VAL @actionId)))


         (=>(HeadActions.report @actionId @report))

         )
  )



(defop |track|
  :invocation(HeadActions.action track @target @id)
  :body (
         (?(HeadActions.bridgeName @bridgeName))
         (!(= @command (TERM-STRING-CAT (VAL @bridgeName) ".track")))
         (!(= @reportName (TERM-STRING-CAT (VAL @bridgeName) ".report")))
         (!(= @reportName (MAKE-ATOM @reportName)))
         (!(SEND-MESSAGE (VAL @bridgeName) (@command @target)))
         (^(|| (@reportName @report) (ELAPSED-TIME (TIME) 5)))
         (~>(@reportName (VAL @report)))

         (=>(HeadActions.report @id "OK"))
         )

  )



 (defop |handleReport|
   :invocation(!(HeadActions.handleReport @reportName @id @actionId))
   :documentation "Utility function to avoid some code duplication when waiting for the response of a genom module. This can't be used when we don't want to fail if the genom request fails"
   :body (
          (!(ReportManager.sub  @reportName @id))
          (^(|| ( @reportName (VAL @id) @report)  (HeadActions.stop (VAL @actionId))))
	  
          (IF(?(HeadActions.stop (VAL @actionId)))
             (~>(HeadActions.stop (VAL @actionId)))
             (!(ReportManager.publish HeadActions.report @actionId "STOPPED"))


             ELSE
             (!(ReportManager.unsub @reportName @id))
             (IF(?(~(EQUAL @report "OK")))
                (!(ReportManager.publish HeadActions.report @actionId @report))

                (!(FAILED))
                )
             )
	  )
   
   )

(defop |isLookingAt|
   :invocation(HeadActions.action isLookingAt @target @joint @actionId)
   :documentation "this procedure return TRUE if the robot is actually looking at a target @target"
   :body (
	  (=>(HeadActions.freeId (+ @actionId 1)))
	  
	  ;Get the position of the target
	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request getJointAbsPose (VAL @target) (VAL @joint) (VAL @sparkId))) 
	  (!(HeadActions.handleReport Spark.report (VAL @sparkId) (VAL @actionId)))
	   (^(Spark.result (VAL @sparkId) @xOb @yOb @zOb @yawOb @pitchOb @rollOb))
	   (~>(Spark.result (VAL @sparkId) @xOb @yOb @zOb @yawOb @pitchOb @rollOb))
	   
	   ;get needed pan-tilt to look at it
	   (?(Softmotion.freeId @smId))
	   (=>(Softmotion.request getPanTiltFromXYZ (VAL @xOb) (VAL @yOb) (VAL @zOb) (VAL @smId)))
	   (!(HeadActions.handleReport Softmotion.report (VAL @smId) (VAL @actionId)))
	   (^(Softmotion.result (VAL @smId) @pan @tilt))
	   (~>(Softmotion.result (VAL @smId) (VAL @pan) (VAL @tilt)))

	   ;look if the head look near this position
	   (IF(?(Robot.headPan @robotPan))
	      (?(Robot.headTilt @robotTilt))
          (IF(?(|| (& (< @robotPan (+ @pan 0.05)) (> @robotPan (- @pan 0.05))) (& (< @robotTilt (+ @tilt 0.05) ) (> @robotTilt (- @tilt 0.05)))))
             (!(ReportManager.publish HeadActions.report @actionId "TRUE"))

		 ELSE
         (!(ReportManager.publish HeadActions.report @actionId "FALSE"))
		 )
	      ELSE
          (!(ReportManager.publish HeadActions.report @actionId "FAILED"))
	      )
	   

	   )

   )
)
