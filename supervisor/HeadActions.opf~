;; -*-Lisp-*-
;;author: Michelangelo Fiore
;;this module contains primitive head actions. 

(
 (defop |init|
   :invocation(!(HeadActions.init))
   :documentation "inits the module"
   :body (
	  (=>(HeadActions.freeId 0))
	  (!(SEM-CREATE HeadActions.sem 1 SEM-FIFO))
	  )
   )

(defop |getFreeId|
   :invocation(!(HeadActions.getFreeId $id))
   :documentation "gets a new id for requestes"
   :body (
	  (!(SEM-P HeadActions.sem))
	  (?(HeadActions.freeId $id))
	  (=>(HeadActions.freeId (+ $id 1)))
	  (!(SEM-V HeadActions.sem))
	  )
   )
 (defop |lookAt|
   :invocation(HeadActions.action lookAt @target @joint @actionId)
   :documentation "this procedure moves the head to look at item @item"
   :body (
	  (=>(HeadActions.freeId (+ @actionId 1)))
	  
	  ;Get the position of the target
	  (?(Spark.freeId @sparkId))
	  (=>(Spark.request getJointAbsPose (VAL @target) (VAL @joint) (VAL @sparkId))) 
	  (!(HeadActions.handleReport Spark.report (VAL @sparkId) (VAL @actionId)))
	   (?(Spark.result (VAL @sparkId) @xOb @yOb @zOb @yawOb @pitchOb @rollOb))
	   (~>(Spark.result (VAL @sparkId) @xOb @yOb @zOb @yawOb @pitchOb @rollOb))
	   
	   ;get needed pan-tilt to look at it
	   (?(Softmotion.freeId @smId))
	   (=>(Softmotion.request getPanTiltFromXYZ (VAL @xOb) (VAL @yOb) (VAL @zOb) (VAL @smId)))
	   (!(HeadActions.handleReport Softmotion.report (VAL @smId) (VAL @actionId)))
	   (?(Softmotion.result (VAL @smId) @pan @tilt))
	   (~>(Softmotion.result (VAL @smId) (VAL @pan) (VAL @tilt)))

	   ;if the head is not already close to the target move it (we want to avoid very small continuous movement of the head)
	   (IF(?(Robot.headPan @robotPan))
	      (?(Robot.headTilt @robotTilt))
	      (IF(?(|| (& (< @robotPan (+ @pan 0.05)) (> @robotPan (- @pan 0.05))) (& (< @robotTilt (+ @tilt 0.05) ) (> @robotTilt (- @tilt 0.05)))))
		 (!(= @moveHead FALSE))
		 ELSE
		 (!(= @moveHead TRUE))
		 )
	      ELSE
	      (!(= @moveHead TRUE))
	      )
	   (IF(?(EQUAL @moveHead TRUE))
	      (?(Softmotion.freeId @smId))
	      (=>(Softmotion.request moveHead (VAL @pan) (VAL @tilt) (VAL @smId)))
	      (=>(Robot.headPan (VAL @pan)))
	      (=>(Robot.headTilt (VAL @tilt)))
	      (!(HeadActions.handleReport Softmotion.report (VAL @smId) (VAL @actionId)))
	      )
	   (=>(HeadActions.report (VAL @actionId) "OK"))
	   
	   
	   )


   
   )


 (defop |lookAtLocation|
   :invocation(HeadActions.action lookAtLocation @location @actionId)
   :documentation "this procedure looks at some location. This could be a direction from the user or a 
pointing gesture"
   :body (

	  )
   )

 (defop |headExplore|
   :invocation(HeadActions.action headExplore @actionId)
   :documentation "this procedure explores the surrounding area moving the head"
   :body (
	  )
   )

 (defop |headExploreLocation|
   :invocation(HeadActions.action headExplore @location @actionId)
   :documentation "this procedure explores the area surrounding a certain location. This could be useful
when we want to find something near a certain point"
   :body (
	  )
   )

 (defop |handleReport|
   :invocation(!(HeadActions.handleReport @reportName @id @actionId))
   :documentation "Utility function to avoid some code duplication when waiting for the response of a genom module. This can't be used when we don't want to fail if the genom request fails"
   :body (
	  (^(|| ( @reportName (VAL @id) @report)  (HeadActions.stop (VAL @actionId))))
	  
	  (IF(?(HeadActions.stop (VAL @actionId)))
	     (~>(HeadActions.stop (VAL @actionId)))
	     (=>(HeadActions.report (VAL @actionId) STOPPED))
	     
	     ELSE	 
	     
	     (~>( @reportName (VAL @id) (VAL @report)))
	     (IF(?(~(EQUAL @report "OK")))
		(=> (HeadActions.report (VAL @actionId) (VAL @report)))
		(!(FAILED))
		)
	     )
	  )
   
   )
)
