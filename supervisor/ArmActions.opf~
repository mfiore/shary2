; -*-Lisp-*-
;;author: Michelangelo Fiore
;;this module contains common actions for arm movements, using both mhp and softmotion. 
;;Testing notes:
;;place object has not been tested
;;not every possible scenario of the other functions has been tested (mainly the movements from a grip position have not been tested)


(

 (defop |init|
   :invocation(!(ArmActions.init))
   :documentation " "
   :body (
	  (=>(ArmActions.freeId 0))
	  )
   )

(defop |getFreeId|
  :invocation(!(ArmActions.getFreeId $id))
  :documentation "gets a new id for requestes"
  :body (

	  (?(ArmActions.freeId $id))

	  (=>(ArmActions.freeId (+ $id 1)))

	  )
   )

 (defop |moveTo|
   :invocation  (ArmActions.action moveTo @arm @task @armGoto @object @support @placement @useObjGoto @objGoto @actionId)
   :documentation "generic procedure to move arm (note that arm start and objstart are not supported)"
   :body (
	  (=>(ArmActions.freeId (+ @actionId 1)))

	  (?(Mhp.arm (VAL @arm) @mhpArm))
	  (?(Softmotion.arm (VAL @arm) @smArm))

	  (!(Mhp.makeArmStartParameter 0 0 0 0 0 0 0 @armStart))
	  (!(= @objStart (objStart 0.0 0.0 0.0 0.0 0.0 0.0)))
	  (!(Mhp.getFreeId @mhpId))
	  
	  (=>(Mhp.request setTrajectory GEN_TRUE (VAL @task) (VAL @mhpArm) (VAL @armStart) (VAL @armGoto) (VAL @object) (VAL @support) (VAL @placement) GEN_FALSE 0 (VAL @objStart) (VAL @useObjGoto) (VAL @objGoto) (VAL @mhpId)))
	  (!(ArmActions.handleReport Mhp.report @mhpId @actionId))

	  (?(Softmotion.freeId @smId))
	  (=>(Softmotion.request moveArm @smArm @smId))
	  (!(ArmActions.handleReport Softmotion.report @smId @actionId))
	  (=>(ArmActions.report (VAL @actionId) "OK"))
	  
	  )
   )

 (defop |escapeObject|
   :invocation(ArmActions.action escapeObject @arm @object @actionId)
   :documentation "Moves the arm away from a placed object"
   :body (
	  (!(Mhp.makeArmGotoParameter 0 0 0 0 0 0 0 @armGoto))
	  (!(= @objGoto (objGoto 0.0 0.0 0.0 0.0 0.0 0.0)))
	  
	  (=>(ArmActions.action moveTo @arm MHP_ARM_ESCAPE_OBJECT @armGoto @object NO_NAME NO_NAME 0 @objGoto @actionId))
	  )
   )
 (defop |moveToX|
   :invocation(ArmActions.action moveToX @arm @object @support @x @y @z @actionId)
   :documentation "Moves the arm to the point specified"
   :body (
	  (IF(?(Robot.armPosition (VAL @arm) FREE))
	     (!(= @task MHP_ARM_FREE))
	     ELSE
	     (!(= @task MHP_ARM_TAKE_TO_FREE))
	     )
	  
	  (!(Mhp.makeArmGotoParameter 0 0 0 0 0 0 0 @armGoto))
	  (!(= @objGoto (objGoto (VAL @x) (VAL @y) (VAL @z) 0.0 0.0 0.0)))

	  (=>(ArmActions.action moveTo @arm @task @armGoto @object @support NO_NAME 15 @objGoto @actionId))
	  
	  )
   )
 (defop |moveToQ|
   :invocation(ArmActions.action moveToQ @arm @object @support @q0 @q1 @q2 @q3 @q4 @q5 @q6 @actionId)
   :documentation "Moves the arm to the q configuration"
   :body (
	  (IF(?(Robot.armPosition (VAL @arm) FREE))
	     (!(= @task MHP_ARM_FREE))
	     
	     ELSE
	     (!(= @task MHP_ARM_TAKE_TO_FREE))
	     )
	  
	  (!(Mhp.makeArmGotoParameter @q0 @q1 @q2 @q3 @q4 @q5 @q6 @armGoto))
	  (!(= @objGoto (objGoto 0.0 0.0 0.0 0.0 0.0 0.0)))

	  (=>(ArmActions.action moveTo @arm @task @armGoto @object @support NO_NAME 0 @objGoto @actionId))
	  
	  )
   )


					;ARM_PICK_UP_GOTO FUNCTIONS
 (defop |moveToObject|
   :invocation(ArmActions.action moveToObject @arm @object @actionId)
   :documentation "Moves the arm in a pick position to a specified object"
   :body (
	  (!(= @objStart (objStart 0.0 0.0 0.0 0.0 0.0 0.0)))
	  (!(= @objGoto (objGoto 0.0 0.0 0.0 0.0 0.0 0.0)))
	  (!(Mhp.makeArmGotoParameter 0 0 0 0 0 0 0 @armGoto))
	
	  (=>(ArmActions.action moveTo @arm MHP_ARM_PICK_GOTO @armGoto @object NO_NAME NO_NAME 0 @objGoto @actionId))
	  )
   )


 (defop |moveToPlaceObject|
   :invocation(ArmActions.action moveToPlaceObject @arm @object @support @placement @actionId)
   :documentation "moves to the placement position with the object"
   :body (
	  (IF(?(Robot.armInAir (VAL @arm) TRUE))
	     (!(= @task MHP_ARM_PLACE_FROM_FREE))
	     
	     ELSE
	     (!(= @task MHP_ARM_TAKE_TO_PLACE))
	     )
	  (!(Mhp.makeArmGotoParameter 0 0 0 0 0 0 0 @armGoto))
	  (!(= @objGoto (objGoto 0.0 0.0 0.0 0.0 0.0 0.0)))

	  (=>(ArmActions.moveTo @arm @task @armGoto @object @support @placement 0 @objGoto @actionId))
	  )
   )

 ;;ROBOT POSES

 (defop |moveToRestPosition|
   :invocation(ArmActions.action moveToRestPosition @arm @actionId)
   :documentation "Goes to a rest pose with the arm nearby the body"
   :body (
	  (=>(ArmActions.action moveToQ (VAL @arm) 0.6 0.4 -1.2 -1.0 0.0 -0.4 0.0 (VAL @actionId))) 
	  )
   )

 (defop |moveToExtendedPosition|
   :invocation(ArmActions.action moveToExtendedPosition @arm @q0 @actionId)
   :documentation "Utility function to extend the arm"
   :body (
	  (=>(ArmActions.action moveToQ (VAL @arm) @q0 0 0 0 0 0 0 (VAL @actionId)))
	  )
   )

 (defop |moveToReadyPosition|
   :invocation (ArmActions.action moveToReadyPosition @arm @q0 @actionId)
   :documentation "For now just utility function but should become an actual request. Goes to a rest pose with the arm nearby the body"
   :body (

	  (=>(ArmActions.action moveToQ @arm @q0 0.4 -1.2 -1.0 0.0 -0.4 0.0 (VAL @actionId)))
	  )
   )



 ;;GRIPPER FUNCTIONS


 (defop |closeGripper|
   :invocation(ArmActions.action closeGripper @gripper @actionId)
   :documentation "closes the gripper"
   :body (
	  (?(Softmotion.gripperClose (VAL @gripper) @state))
	  (=>(ArmActions.action useGripper (VAL @gripper) (VAL @state) (VAL @actionId)))
	  )
   )

 (defop |openGripper|
   :invocation(ArmActions.action openGripper @gripper @actionId)
   :documentation "opens the gripper"
   :body (
	  (?(Softmotion.gripperOpen (VAL @gripper) @state))
	  (=>(ArmActions.action useGripper (VAL @gripper) (VAL @state) (VAL @actionId)))
	  )
   )

 (defop |openGripperOnPressure|
   :invocation(ArmActions.action openGripperOnPressure @gripper @actionId)
   :documentation "opens the gripper"
   :body (
	  (?(Softmotion.gripperRelease (VAL @gripper) @state))
	  (=>(ArmActions.action useGripper (VAL @state) (VAL @actionId)))
	  )
   )
 (defop |useGripper|
   :invocation(ArmActions.action useGripper @gripper @state @actionId)
   :documentation "Moves the gripper to state @state"
   :body (
	  (=>(ArmActions.freeId (+ @actionId 1)))
	  
	  (?(Softmotion.freeId @smId))
	  (IF(?(|| (EQUAL @state LRELEASE) (EQUAL @state RRELEASE)))
	     (=>(ArmActions.gripperRelease @gripper @smId))
	     )
	  
	  (=>(Softmotion.request useGripper (VAL @state) (VAL @smId)))
	  (!(ArmActions.handleReport Softmotion.report @smId @actionId))
	  (=>(ArmActions.report @actionId "OK")) 
	  (IF(?(|| (EQUAL @state LRELEASE) (EQUAL @state RRELEASE)))
	     (~>(ArmActions.gripperRelease (VAL @gripper) (VAL @smId)))
	     )
	  )
   )
 (defop |stopOpenGripperOnPressure|
   :invocation (ArmActions.action stopOpenGripperOnPressure  @gripper @actionId)
   :documentation "Utility function to stop a gribber grab release request"
   :body (
	  (IF(?(ArmActions.gripperRelease @gripper @smId))
	     (=>(Softmotion.stop (VAL @smId)))
	     (^(Softmotion.report (VAL @smId) @report))
	     )
	  
	  (?(Softmotion.gripperCancel @gripper @state))
	  (=>(ArmActions.action useGripper @state (VAL @actionId)))
	  
	  )
   )

   (defop |handleReport|
     :invocation(!(ArmActions.handleReport @reportName @id @actionId))
     :documentation "Utility function to avoid some code duplication when waiting for the response of a genom module. This can't be used when we don't want to fail if the genom request fails"
     :body (
	    (^(|| ( @reportName (VAL @id) @report)  (ArmActions.stop (VAL @actionId))))
	    
	    (IF(?(ArmActions.stop (VAL @actionId)))
	       (~>(ArmActions.stop (VAL @actionId)))
	       (=>(ArmActions.report (VAL @actionId) STOPPED))
	       
	       ELSE	 
	       
	       (~>( @reportName (VAL @id) (VAL @report)))
	       (IF(?(~(EQUAL @report "OK")))
		  (=> (ArmActions.report (VAL @actionId) (VAL @report)))
		  (!(FAILED))
		  )
	       )
	    )
     
     )
   )


