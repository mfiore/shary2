;; -*-Lisp-*-
;;author: Michelangelo Fiore
;;this module contains high-level actions like take an item, give, drop.
(

 (defop |init|
   :invocation(!(ExecutionManager.init))
   :documentation "Inits the module"
   :body (
	  (=>(ExecutionManager.freeId 0))
	  (!(SEM-CREATE ExecutionManager.sem 1 SEM-FIFO))
	


	  )

   )
 
 (defop |getFreeId|
   :invocation(!(ExecutionManager.getFreeId $id))
   :documentation "Returns an id to use in executions"
   :body (
	  (!(SEM-P ExecutionManager.sem))
	  (?(ExecutionManager.freeId $id))
	  (=>(ExecutionManager.freeId (+ $id 1)))
	  (!(SEM-V ExecutionManager.sem))
	 
	 )
   )


(defop |executeAction|
  :invocation(ExecutionManager.executeAction @actionName @actionParameters @executionId)
  :documentation "Launching point to allow other modules to launch actions in a generic way"
  :body (
	 (?(Action.type (VAL @actionName) @type))
	 (IF(?(EQUAL @type MANIPULATION))
	    (!(== (VAL @actionParameters) (. @object .)))
	 
	    ELSEIF(?(EQUAL @type HANDOVER))
	    (!(== (VAL @actionParameters) (. @object @agent1 @agent2 .)))

	    ELSEIF(?(EQUAL @type PLACEMENT))
	    (!(== (VAL @actionParameters) (. @object @placement .)))
	    
	    ELSEIF(?(EQUAL @type POSE))
	    (!(== (VAL @actionParameters) (. @pose @arm @q0 .)))

	    ELSEIF(?(EQUAL @type GRIPPER))
	    (!(== (VAL @actionParameters) (. @gripper .)))

	    )

	 (IF(?(EQUAL @actionName closeGripper))
	    (=>(ExecutionManager.execute closeGripper @gripper @executionId))
	    
	    ELSEIF(?(EQUAL @actionName openGripper))
	    (=>(ExecutionManager.execute openGripper @gripper @executionId))
	    
	    ELSEIF(?(EQUAL @actionName moveToPose))
	    (=>(ExecutionManager.execute moveToPose @pose @arm @q0 @executionId))
	    
	    ELSEIF(?(EQUAL @actionName take))
	    (=>(ExecutionManager.execute take @object NO_NAME @executionId))
	    
	    ELSEIF(?(EQUAL @actionName throw))
	    (=>(ExecutionManager.execute throw @object @placement @executionId))

	    ELSEIF(?(EQUAL @actionName place))
	    (=>(ExecutionManager.execute place @object @placement @executionId))
	    
	    ELSEIF(?(EQUAL @actionName handover))
	    (IF(?(EQUAL @agent2 PR2_ROBOT))
	       (=>(ExecutionManager.execute handover GRAB @object @agent1 @executionId)) 
		 ELSE 
		 (=>(ExecutionManager.execute handover GIVE @object @agent2 @executionId))
		 )
	    ELSEIF(?(EQUAL @actionName undefined))  ;this kind of actions are not executed at the moment and the module returns just an ok
	    (=>(ExecutionManager.report (VAL @executionId) OK))
	    
	    )

	 
	 )
  )

(defop |chooseArmForTake|
  :invocation(!(ExecutionManager.chooseArmForTake @object @executionId $armForTake))
  :documentation "Utility procedure to choose an arm for grasping. Returns the arm for the take action"
  :body (
	 (?(Spark.robotName @robotName)) 
	 (?(Spark.robotTorso @torso))
	 
					;If the robot has only one free arm try the take action with that arm. 
	 (IF(?(& (Robot.hasObject RIGHT @anyObject) (~(Robot.hasObject LEFT @anyObject2))))
	    (!(= $armForTake LEFT))
	    
	    ELSEIF(?(&(~(Robot.hasObject RIGHT @anyObject)) (Robot.hasObject LEFT @anyObject2)))
	    (!(= $armForTake RIGHT))
	     
	     ELSE
					;otherwise calculate which is the best arm to use based on the object position relative to the robot
	     
	     
	     (!(Spark.getFreeId @sparkId))
	     (=>(Spark.request getJointAbsPose (VAL @object) "NO_NAME" (VAL @sparkId))) 
	     (^(Spark.report (VAL @sparkId) @sparkReport))
	     (IF(?(~(EQUAL @sparkReport "OK")))
		(=> (ExecutionManager.report (VAL @executionId) (VAL @sparkReport)))
		(!(SEM-V ExecutionManager.sem))
		(~>(ExecutionManager.isExecutingAction (VAL @executionId)))
		(!(FAILED))
		)
	     (^(Spark.result (VAL @sparkId) @xOb @yOb @zOb @yawOb @pitchOb @rollOb))
	     (~>(Spark.result (VAL @sparkId) @xOb @yOb @zOb @yawOb @pitchOb @rollOb))
	     (~>(Spark.report (VAL @sparkId) @sparkReport))
	     
	     (!(Spark.getFreeId @sparkId))
	     (=>(Spark.request getJointAbsPose (VAL @robotName ) (VAL @torso) (VAL @sparkId))) 
	     (^(Spark.report (VAL @sparkId) @sparkReport))
	     (IF(?(~(EQUAL @sparkReport "OK")))
		(=> (ExecutionManager.report (VAL @executionId) (VAL @sparkReport)))
		(!(SEM-V ExecutionManager.sem))
		(~>(ExecutionManager.isExecutingAction (VAL @executionId)))
		(!(FAILED))
		)
	     (^(Spark.result (VAL @sparkId) @xTorso @yTorso @zTorso @yawTorso @pitchTorso @rollTorso))
	     (~>(Spark.result (VAL @sparkId) @xTorso @yTorso @zTorso @yawTorso @pitchTorso @rollTorso))
	     (~>(Spark.report (VAL @sparkId) @sparkReport))
	      
	     (IF(?(> @yOb @yTorso))
		(!(= $armForTake LEFT))
		
		ELSE
		(!(= $armForTake RIGHT))
		)
	     )
	  
	  )
  )


(defop |cleanModuleRequestes|
  :invocation(!(ExecutionManager.cleanModuleRequestes))
  :documentation "When we stop an action we want to stop all the living requestes like detectPression"
  :body (
	 (IF(?(ArmActions.hasDetectPressionRequest @gripper @mode @smId))
	    (~>(ArmActions.hasDetectPressionRequest (VAL @gripper) (VAL @mode) (VAL @smId)))
	    (?(Softmotion.gripperCancel (VAL @gripper) @state))
	    (!(Softmotion.getFreeId @smId))
	    (=>(Softmotion.request useGripper @state @smId))
	    (^(Softmotion.report (VAL @smId) @report))
	    )
	 (^(Robot.isMoving RIGHT_ARM FALSE))
	 (^(Robot.isMoving LEFT_ARM FALSE))
	 )
  )
 (defop |handleReport|
   :invocation(!(ExecutionManager.handleReport @module @id @executionId @haltable @stoppable @object))
   :documentation "Utility function to avoid some code duplication when waiting for the response of a genom module. This can't be used when we don't want to fail if the genom request fails
                   @module is the name of the module we are waiting a report (Spark, Softmotion...)
                   @id is the id of the request we are waiting a report
                   @executionId is the id of the current execution
                   @stoppable is TRUE when we want to be able to stop while waiting for a report
                   @object NO_NAME or set to an object name is used to set reachability false when we fail an action oriented to an object. This could be generalized in a better mechanism to input failure facts"
   :body (
	  (!(= @reportName (TERM-STRING-CAT (VAL @module) ".report")))   ;we create the real report name
	  (!(= @reportName (MAKE-ATOM @reportName)))

	  ;;we wait until we have a report, we are stopped or paused.
	 (^(|| (@reportName (VAL @id) @report) (& (EQUAL @haltable TRUE) (|| (ExecutionManager.halt (VAL @executionId)) (Monitor.handPositionDanger TRUE))) (& (EQUAL @stoppable TRUE) (ExecutionManager.stop (VAL @executionId)) )))
	 
	 (IF(?(@reportName (VAL @id) @report))   ;if we have a report
	    (~>(@reportName (VAL @id) (VAL @report)))
	    (IF(?(~(EQUAL @report "OK")))   ; if we have a negative report we quit
	       (!(PRINT @report))
	       (=> (ExecutionManager.report (VAL @executionId) FAILURE))
	       (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
	       (!(ExecutionManager.cleanModuleRequestes))
	       (IF(?(~(EQUAL @object NO_NAME)))  ;if an object name is set the op will call the db to put a reachability to false. It would be better if this was in ArmActions, with the Acapela command here perhaps. The structure of ArmActions rends it a little difficult...
		  (!(DatabaseInterface.setReachabilityFalse (VAL @object) @result)) 
		  (!(Acapela.say "I can't seem to reach it..."))   
		  )
	       (!(SEM-V ExecutionManager.sem))
	       (!(FAILED))
	       )
	    ELSEIF(?(& (EQUAL @haltable TRUE) (|| (ExecutionManager.halt (VAL @executionId)) (Monitor.handPositionDanger TRUE))))  ;if we halt we want to pause until we receive a resume or stop order.
	    (IF(?(Monitor.handPositionDanger TRUE))
	       (!(= @waitingPositionChange TRUE))
	       
	       ELSE
	       (!(= @waitingPositionChange FALSE))
	       (~>(ExecutionManager.halt (VAL @executionId)))
	       )
	    (IF(?(EQUAL @module ArmActions))
	       (=>(ArmActions.halt (VAL @id)))
	       )
	    (^(|| (& (EQUAL @stoppable TRUE) (ExecutionManager.stop (VAL @executionId))) (ExecutionManager.resume (VAL @executionId)) (&(EQUAL @waitingPositionChange TRUE) (Monitor.handPositionDanger FALSE))))
	    
	    (IF(?(||(ExecutionManager.resume (VAL @executionId)) (&(EQUAL @waitingPositionChange TRUE) (Monitor.handPositionDanger FALSE))))  ;we ask to resume and recall this function to wait for the report
	       (~>(ExecutionManager.resume (VAL @executionId)))
	       (IF(?(EQUAL @module ArmActions))
		  (=>(ArmActions.resume (VAL @id)))
		  )
	       (!(ExecutionManager.handleReport @module @id @executionId @haltable @stoppable @object )) 
	       
	       ELSEIF(?(&(EQUAL @stoppable TRUE) (ExecutionManager.stop (VAL @executionId))))
	       (~>(ExecutionManager.stop (VAL @executionId)))
	       (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
	       (=>(ExecutionManager.report @executionId STOPPED))
	       (!(ExecutionManager.cleanModuleRequestes))
	       (!(SEM-V ExecutionManager.sem))
	       (!(FAILED))
	       )

	    
	    ELSEIF(?(&(ExecutionManager.stop (VAL @executionId)) (EQUAL @stoppable TRUE)))   ;;if we stop we abandon the action. Possible problem of coherency. Since the stop in softmotion is not working well we will just quit after the action is over
	 

	    (~>(ExecutionManager.stop (VAL @executionId)))
	    (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
	    (IF(?(EQUAL @module ArmActions))
	       (=>(ArmActions.stop @id))
	       )	  
	       ;; 	  ELSEIF(?(EQUAL @module Spark))
	       ;; 	  (=>(Spark.stop (VAL @id)))
		  
	       ;; 	  ELSEIF(?(EQUAL @module Viman))
	       ;; 	  (=>(Viman.stop (VAL @id)))      
	       ;; 	  )
	       (^(@reportName (VAL @id) @report))
	       (~>(@reportName (VAL @id) (VAL @report)))
	       (=>(ExecutionManager.report @executionId STOPPED))
	       (!(ExecutionManager.cleanModuleRequestes))
	       (!(SEM-V ExecutionManager.sem))
	       (!(FAILED))
	            
	       )
	 )
   )
   

   

 (defop |take|
   :invocation(ExecutionManager.execute take @object @arm @executionId)
   :documentation "this procedure takes the object @object. @arm can be setted to one of the two arms (RIGHT or LEFT) or to NO_NAME. In that case the robot chooses the arm to compute the action"
   :body (	  
	  (!(SEM-P ExecutionManager.sem))
	  	 


	  ;;check if the action has already been realized
	  (IF(?(~(EQUAL @arm NO_NAME)))
	     (IF(?(Robot.hasObject (VAL @arm) (VAL @object)))
		(=>(ExecutionManager.report (VAL @executionId) OK))
		(!(SEM-V ExecutionManager.sem))

		(!(FAILED))
		
		)
	     ELSEIF(?(Robot.hasObject @anyArm (VAL @object)))
	     (=>(ExecutionManager.report (VAL @executionId) OK))
	     (!(SEM-V ExecutionManager.sem))
	     (!(FAILED))
	     )
	  
	  ;;check if the robot has both hands full (or one hand if @arm was specified)
	  (IF(?(~(EQUAL @arm NO_NAME)))
	     (IF(?(Robot.hasObject (VAL @arm) @anyObject))
		(=>(ExecutionManager.report (VAL @executionId) FAILURE))
		(!(SEM-V ExecutionManager.sem))
		(!(FAILED))
		)
	     ELSEIF(?(|| (Robot.hasObject RIGHT  @anyObject) (Robot.hasObject LEFT  @anyObject)))
	     (=>(ExecutionManager.report (VAL @executionId) FAILURE))
	     (!(SEM-V ExecutionManager.sem))
	     (!(FAILED))
	     )
	  (=>(ExecutionManager.isExecutingAction (VAL @executionId)))
	  ;;set the parameters for the monitor manager
	   (!(= @failureConditions (. (. .)  (. (ExecutionManager.report (VAL @executionId) FAILURE) (ExecutionManager.report (VAL @executionId) STOPPED) .) .) )) 	 ; stops monitoring if we fail or if we are stopped
	  (!(= @successConditions (. (. (ExecutionManager.report (VAL @executionId) OK) .)  (. .) .) ))     ; look at the item until execution is completed
	  

	  (!(MonitorManager.getFreeId @monitorId))
	  
	  
	  ;;start the monitoring
	  (!(MonitorManager.monitorTarget @object "NO_NAME" @successConditions @failureConditions HIGH @monitorId))
	  
	  (WHILE(?(~(MonitorManager.isMonitoringTarget (VAL @monitorId)))) ;until the monitor starts
		(^(|| (MonitorManager.isMonitoringTarget (VAL @monitorId)) (MonitorManager.report (VAL @monitorId) @monitorReport ))) ;wait until the monitoring starts or it returns a value (which would be an error, a cancel or a stopped status since it can't succed before execution starts.
		
		(IF(?(MonitorManager.report (VAL @monitorId) @report)) ;;there's an error (like object not present) or the monitoring has being stopped or canceled
		   (~>(MonitorManager.report (VAL @monitorId) @report))
		   (IF(?(EQUAL @report STOPPED))
		      (=>(ExecutionManager.report (VAL @executionId) STOPPED)) ;pause the execution and go back to the loop
		      ELSEIF(?(EQUAL @report CANCELED))
		      (=> (ExecutionManager.report (VAL @executionId) FAILURE))  ;we fail
		      (!(SEM-V ExecutionManager.sem))
		      (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
		      (!(FAILED))
		      
		      ELSE  ;unhandled report
		      (=> (ExecutionManager.report (VAL @executionId) @report)) 
		      (!(SEM-V ExecutionManager.sem))
		      (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
		      (!(FAILED))
		      )
		   )	
		)
	  ;;everything is good. Monitoring has started. We can choose an arm for take if needed
 
	  (IF(?(EQUAL @arm NO_NAME)) 
	     (!(ExecutionManager.chooseArmForTake @object @executionId @armForPick))
	    
	     ELSE
	     (!(= @armForPick @arm))
	     )


	  ;;open gripper if needed
	  (IF(?(Robot.gripperStatus (VAL @armForPick) CLOSE))
	     (!(ArmActions.getFreeId @actionId))
	     (=>(ArmActions.action openGripper @armForPick @actionId))
	     (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE NO_NAME))
	     )


	  ;;plan and execute the trajectory
	  (!(ArmActions.getFreeId @actionId))
	  (=>(ArmActions.action moveToObject @armForPick @object @actionId))

	  (!(ExecutionManager.handleReport ArmActions @actionId @executionId TRUE TRUE @object))

	  

	  ;;close the gripper
	  (!(ArmActions.getFreeId @actionId))
	  (=>(ArmActions.action closeGripper @armForPick @actionId))
	  (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE NO_NAME))
	  
	  ;;updates knowledge of the robot
	  (=> (Robot.hasObject (VAL @armForPick) (VAL @object))) ;if we arrive here with no FAILED than we've got the item (hopefully XD)

	  (=>(ExecutionManager.report (VAL @executionId) OK))
	  (~>(ExecutionManager.isExecutingAction (VAL @executionId)))

	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request setObjectInHand PR2_ROBOT (VAL @object) (VAL @armForPick) TRUE (VAL @sparkId)))
	  (!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE FALSE NO_NAME))

	  (!(DatabaseInterface.add (AGENT-STATEMENT PR2_ROBOT PR2_ROBOT hasInHand (VAL @object)) @result))

	  (!(AgentActionMonitor.cleanObjectMonitorSpheres (VAL @object)))
	  (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
	  (!(SEM-V ExecutionManager.sem))
	  )
   
   )



 (defop |getHumanObservations|
   :invocation(!(ExecutionManager.getHumanObservations @agent @executionId $armPosition $distance $orientation))
   :documentation "utility procedure that calculates the observations for the POMDP."
   :body (
	  (!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT HERAKLES_HUMAN1 agentPresent @isPresent) (. @isPresent .) @result))
	  (IF(?(~(NULL @result)))
	     (!(= @isPresent (CAR(CAR @result))))
	     
	     ELSE
	     (!(= @isPresent FALSE))
	     )

	  (IF(?(EQUAL @isPresent TRUE))
	     (?(ExecutionManager.oldDistance @oldDistance)) 
	     (?(ExecutionManager.oldArmPosition @oldArmPosition)) 
	     (IF(?(EQUAL @oldDistance outOfRange))
		(!(= @newDistance closer))
		(!(= @actualDistance CLOSE))
		(IF(?(EQUAL @oldArmPosition unknown))
		   (!(= @newArmPosition closer))
		   (!(= @actualArmPosition EXTENDED))
		   )
		
		ELSE
		(!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT HERAKLES_HUMAN1 distance @actualDistance) (. @actualDistance .) @result))
		(IF(?(~(NULL @result)))
		   (!(= @actualDistance (CAR(CAR @result))))
		   (IF(?(EQUAL @oldDistance CLOSE))
		      (IF(?(EQUAL @actualDistance FAR))
			 (!(= @newDistance farther))
			 ELSE
			 (!(= @newDistance still))
			 )
		      ELSEIF(?(EQUAL @oldDistance FAR))
			 (IF(?(EQUAL @actualDistance CLOSE))
			    (!(= @newDistance closer))
			    
			    ELSE
			    (!(= @newDistance still))
			    )
			 )
		   ELSE 
		   (!(= @newDistance outOfRange))
		   )
		
	       	
		(!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT HERAKLES_HUMAN1  armPosition @armPosition) (. @armPosition .) @result))
		(IF(?(~(NULL @result)))
		   (!(= @actualArmPosition (CAR(CAR @result))))
		   (IF(?(EQUAL @oldArmPosition CLOSE))
		      (IF(?(EQUAL @actualArmPosition EXTENDED))
			 (!(= @newArmPosition closer))
			 ELSE
			 (!(= @newArmPosition still))
			 )
		      ELSEIF(?(EQUAL @oldArmPosition EXTENDED))
		      (IF(?(EQUAL @actualArmPosition EXTENDED))
			 (!(= @newArmPosition still))
			 
			 ELSE
			 (!(= @newArmPosition farther))
			 )
		      )
		   ELSE
		   (!(= @newArmPosition unknown))
		   )
		)
	     (!(= @newOrientation still))
	     ELSE
	     (!(= @newDistance outOfRange))
	     (!(= @newArmPosition unknown))
	     (!(= @newOrientation unknown))
	     )
	  (!(= $distance (VAL @newDistance)))
	  (!(= $armPosition (VAL @newArmPosition)))
	  (!(= $orientation (VAL @newOrientation)))

	  (=>(ExecutionManager.oldDistance @actualDistance))
	  (=>(ExecutionManager.oldOrientation STILL))
	  (=>(ExecutionManager.oldArmPosition @actualArmPosition))
	  
	  )
   )


(defop |getQForHuman|
  :invocation (!(ExecutionManager.getQForHuman @arm @agent $finalQ0))
  :documentation "calculates a q0 value so that the arm is oriented toward the agent. This procedure at the moment is implemented only for the right arm. NEEDS TO BEUPDATED"
  :body (
	 (?(Spark.robotName @sparkRobotName))
	 (?(Spark.humanTorso @hTorso))
	 (?(Robot.position TORSO @robotTorsoX @robotTorsoY @robotTorsoZ @robotTorsoYaw @robotTorsoPitch @robotTorsoRoll))
	 ;;get the human position
	 (!(Spark.getFreeId @sparkId))
	 (=>(Spark.request getJointAbsPose (VAL @agent) (VAL @hTorso) (VAL @sparkId)))
	 (^(Spark.report (VAL @sparkId) @report))
	 
	 (~>(Spark.report (VAL @sparkId) (VAL @report)))
	 
	 (^(Spark.result (VAL @sparkId) @humanTorsoX @humanTorsoY @humanTorsoZ @humanTorsoYaw @humanTorsoPitch @humanTorsoRoll))
	 (~>(Spark.result (VAL @sparkId) (VAL @humanTorsoX) (VAL @humanTorsoY) (VAL @humanTorsoZ) (VAL @humanTorsoYaw) (VAL @humanTorsoPitch) (VAL @humanTorsoRoll)))
	 (!(= @q0 0.4))
	 (!(= @difference (- @robotTorsoX @humanTorsoX)))
	 (!(= @q0 (- @q0 @difference)))

	 (IF(?(> @q0 0.7))
	    (!(= @q0 0.7))
	    ELSEIF(?(< @q0 -0.7))
	    (!(= @q0 0.7))
	    )
	 (!(= $finalQ0 (VAL @q0)))
	 
	 )
  
  )

(defop |give|
  :invocation(ExecutionManager.execute handover @type @object @agent @executionId)
  :documentation "this procedure gives the object @object to the agent @agent. If the robot doesn't have the @item it fails"
  :body (
	 (!(SEM-P ExecutionManager.sem))
	 (!(= @observationWaitTime 0)) ;time to wait to get new observations
	 (!(= @maxEngage 3))           ;number of times the robot will try to re-engage the user before understanding he's not interested
	 (!(= @nEngage 0))             ;number of times the robot has engaged the user
	 (!(= @waitTime 20))          ;time to wait before engaging the user
	 
	 (?(Spark.robotTorso @rTorso))
	 (?(Spark.humanHead @humanHead))

	 (!(= @monitorSuccessConditions (. (. (ExecutionManager.report (VAL @executionId) OK) .) (. .) .)))
	 (!(= @monitorFailureConditions  (. (. .) (. (ExecutionManager.report (VAL @executionId) FAILURE) (ExecutionManager.report (VAL @executionId) STOPPED) .) .)))



	 (IF(?(EQUAL @type GIVE))
	    (IF(?(Robot.hasObject @arm  (VAL @object)))  ;if the robot doesn't have the object fail
	       ELSE 
	       (=>(ExecutionManager.report (VAL @executionId) FAILURE))
	       (!(SEM-V ExecutionManager.sem))
	       (!(FAILED))
	       )
	      
	    ELSEIF(?(EQUAL @type GRAB)) ;select an arm for the grab or fail if there are free arms
	    (IF(?(Robot.hasObject RIGHT  @anyObject))
	       (IF(?(Robot.hasObject LEFT  @anyObject))
		  (!(SEM-V ExecutionManager.sem))
		  (!(FAILED))
		  
		  ELSE
		  (!(= @arm LEFT))
		  (!(= @armJoint LEFT_ARM))
		  (!(ArmActions.getFreeId @actionId))
		  (=>(ArmActions.action openGripper @arm @actionId))
		  (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE NO_NAME))
		  )
		    
	       ELSE
	       (!(= @arm RIGHT))
	       (!(= @armJoint RIGHT_ARM))
	       (!(ArmActions.getFreeId @actionId))
	       (=>(ArmActions.action openGripper @arm @actionId))

	       (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE NO_NAME))
	       )
	    )
	 
	 (=>(ExecutionManager.isExecutingAction (VAL @executionId)))
	 (?(Spark.robotName @sparkRobotName))
	
	 
	 ;;Set the starting variables. We only compute observations to set inRange at the start.
	 (!(ExecutionManager.getHumanObservations @agent  @executionId @armPosition @distance @orientation))
	 (IF(?(EQUAL @distance outOfRange))
	    (!(= @inRange false))
	    (!(= @q0 0))  ;set the starting q0. This manouvres the robot arm horizontal position so that it can follow the human when it moves.
	    ELSE
	    (!(= @inRange true))
	    (!(ExecutionManager.getQForHuman @arm @agent @q0))
	    (IF(?(~(AgentActionMonitor.isMonitoringAgent (VAL @agent) @monitorId)))
		 (!(AgentActionMonitor.startMonitoringAgent @agent))
		 )
	       

	    )
	 
	 (!(= @task notCompleted))  
	 (!(= @time ok))
	 (!(= @xState (TERM-STRING-CAT @inRange @task @time)))
	 
	 ;;init the POMDP
	 (!(POMDP.init Handover @xState @action @yState))
	 (!(= @robotState armRest))  ;;possible states are armRest armReady and armExtended
	 
	 (WHILE(?(& (~(ExecutionManager.stop (VAL @executionId))) (~(ExecutionManager.report (VAL @executionId) @anyReport)) (~(EQUAL @action ABANDON)))) ;loop until we are stopped, we get a report (means we fail basically) or we abandon the task
	       
	       ;;we extend the arm if:
	       ;;the arm is not extended and:
	       ;;-we get a continue action
	       ;;we get a wait action and the user is engaged.
	       
	       (IF(?(& (~(EQUAL @robotState armExtended)) (|| (EQUAL @action CONTINUE) (& (EQUAL @action WAIT) (EQUAL @yState engaged)))))  ;if user is engaged and arm is not extended extend it
		  (IF(?(ArmActions.detectPression (VAL @arm) @mode @smId)) ;if we are waiting for grasp we close the gripper, move and then relaunch release to avoid it opening because of the arm moving.
		     (!(ArmActions.getFreeId @detectPressionId))
		     (=>(ArmActions.action stopDetectPression @arm @mode @detectPressionId))
		     (!(ExecutionManager.handleReport ArmActions @detectPressionId @executionId FALSE FALSE NO_NAME))
		  )

		  (!(ArmActions.getFreeId @actionId))
		  (=>(ArmActions.action moveToPose EXTENDED @arm @q0 @actionId))
		  (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE TRUE NO_NAME))
		       
		  (!(ArmActions.getFreeId @detectPressionId))
		  (=>(ArmActions.action detectPression @arm @type @detectPressionId))

		    		  
		  (!(= @task waitingGrasp))
		  (!(= @robotState armExtended))
		  
		  
		  ;;we put the arm to ready if:
		  ;;the arm is not ready and:
		  ;;the user is not engaged and in range
		  ;;we get a WAIT or ENGAGE command
		  ;;task state is not modified here
		  ELSEIF(?(&(~(EQUAL @robotState armReady)) (EQUAL @yState notEngaged) (EQUAL @inRange true) (|| (EQUAL @action WAIT) (EQUAL @action ENGAGE))))
		  (^(Robot.isMoving (VAL @armJoint) FALSE))
		  (IF(?(ArmActions.detectPression (VAL @arm) @mode @smId)) ;if we are waiting for grasp we close the gripper, move and then relaunch release to avoid it opening because of the arm moving.
		     (!(ArmActions.getFreeId @detectPressionId))
		     (=>(ArmActions.action stopDetectPression @arm @mode @detectPressionId))
		     (!(ExecutionManager.handleReport ArmActions @detectPressionId @executionId FALSE FALSE NO_NAME))
		     )
		  (!(ArmActions.getFreeId @actionId))
		  (=>(ArmActions.action moveToPose READY (VAL @arm) @q0 @actionId))
		  (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE TRUE NO_NAME))
		  
		  (!(ArmActions.getFreeId @detectPressionId))
		  (=>(ArmActions.action detectPression @arm @type @detectPressionId))


		  (!(= @robotState armReady))
		  (!(= @task waitingGrasp))
		
		  ;;we go to rest state if
		  ;;we receive a wait command and the user is out of range and the the robot is not in restState
		  ELSEIF(?(& (~(EQUAL @robotState armRest)) (EQUAL @inRange false) (EQUAL @action WAIT)))
		  (^(Robot.isMoving (VAL @armJoint) FALSE))
		  (IF(?(ArmActions.detectPression (VAL @arm) @mode @smId)) ;if we are waiting for grasp we close the gripper, move and then relaunch release to avoid it opening because of the arm moving.
		     (!(ArmActions.getFreeId @detectPressionId))
		     (=>(ArmActions.action stopDetectPression @arm @mode @detectPressionId))
		     (!(ExecutionManager.handleReport ArmActions @detectPressionId @executionId FALSE FALSE NO_NAME))
		  )
		  
		  (!(ArmActions.getFreeId @actionId))
		  (=>(ArmActions.action moveToPose MANIPULATION @actionId))
		  (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE TRUE NO_NAME))
		  (!(= @robotState armRest))
		  (!(= @task notCompleted))
		  )
	       
	       
	       (IF(?(EQUAL @action WAIT)) ;if the action is wait we start the timer (if it's not started already)
		  (IF(?(~(Timer.isRunning (VAL @timerId))))
		     (!(Timer.getFreeId @timerId))                  ;start a timer to edit the state variable time. 
		     (=>(Timer.start @waitTime @timerId))
		     )
		  
		  ELSEIF(?(EQUAL @action ENGAGE))   ;if the action is engage we stop the timer (if started) and talk to the user
		  (IF(?(Timer.isRunning (VAL @timerId)))
		     (=>(Timer.stopTimer (VAL @timerId)))
		     )
		  (IF(?(Timer.elapsedTime (VAL @timerId)))
		     (~>(Timer.elapsedTime (VAL @timerId)))
		     )
		  (!(= @time ok))
		  (IF(?(EQUAL @type GIVE))
		     (!(Acapela.say "Are you sure you want it?"))
		  
		     ELSEIF(?(EQUAL @type GRAB))
		     (!(Acapela.say "Can you give that to me?"))
		     )
		  )
	       ;;WAIT before getting the new observations
	       (^(ELAPSED-TIME (TIME) @observationWaitTime))
	       (!(ExecutionManager.getHumanObservations @agent @executionId @armPosition @distance @orientation))
	       
	       
	       (IF(?(EQUAL @distance outOfRange))
		  (!(= @inRange false))
		  (!(= @q0 0))
		  ELSE
		  (!(= @inRange true))
		  (!(ExecutionManager.getQForHuman @arm @agent @qo))
		  )
	       
	       ;; ;;if the user is out of range and the monitor has not failed stop the monitor. If the user is in range and we are not monitoring it start the monitor.
	       
	       ;; (IF(?(EQUAL @inRange true))
	       ;; 	  (IF(?(~(MonitorManager.isMonitoringTarget (VAL @monitorId))))
	       ;; 	     (!(MonitorManager.getFreeId @monitorId))
	       ;; 	     (!(MonitorManager.monitorTarget @agent @humanHead @monitorSuccessConditions @monitorFailureConditions HIGH @monitorId)) 
	       ;; 	     )
	       ;; 	  ELSE
	       ;; 	  (IF(?(MonitorManager.isMonitoringTarget (VAL @monitorId)))
	       ;; 	     (IF(?(~(MonitorManager.report (VAL @monitorId) @report)))
	       ;; 		(=>(MonitorManager.cancelMonitoring (VAL @monitorId)))
	       ;; 		(^(MonitorManager.report (VAL @monitorId) @report))
	       ;; 		(~>(MonitorManager.report (VAL @monitorId) @report))
	       ;; 		ELSE
	       ;; 		(~>(MonitorManager.report (VAL @monitorId) @report))
	       ;; 		)
	       ;; 	     )
	       ;; 	  )
	       (IF(?(EQUAL @task waitingGrasp)) ;if we are waiting a grasp and detecting pressure we open or close the gripper depending on the kind of handover
		  (IF(?(Robot.gripperStatus (VAL @arm) DETECTED_PRESSION))
		     (~>(Robot.gripperStatus (VAL @arm) DETECTED_PRESSION))
		     (~>(ArmActions.report @detectPressionId @report))
		     
		     (IF(?(EQUAL @type GIVE))
			(!(ArmActions.getFreeId @actionId))
			(=>(ArmActions.action openGripper @arm @actionId))
			(!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE NO_NAME))
					     	     
			ELSEIF(?(EQUAL @type GRAB))
			(!(ArmActions.getFreeId @actionId))
			(=>(ArmActions.action closeGripper @arm @actionId))
			(!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE NO_NAME))
			)
		     (!(= @task completed))
		     (IF(?(EQUAL @type GIVE))
			(~>(Robot.hasObject (VAL @arm) (VAL @object)))
			
			(!(Spark.getFreeId @sparkId))
			(=>(Spark.request placeObjectForSimu (VAL @object) 0 0 0 0 0 0 1 @sparkId)) 
			(!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE FALSE NO_NAME))
	       
			(!(Spark.getFreeId @sparkId))
			(=>(Spark.request setObjectInHand (VAL @sparkRobotName) (VAL @object) (VAL @arm) FALSE (VAL @sparkId)))
			(!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE FALSE NO_NAME))

			(!(Spark.getFreeId @sparkId))
			(=>(Spark.request setObjectInHand (VAL @agent) (VAL @object) (VAL @arm) TRUE (VAL @sparkId)))
			(!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE FALSE NO_NAME))

			(=>(Agent.hasObject (VAL @agent) (VAL @object)))
			(!(DatabaseInterface.remove (AGENT-STATEMENT PR2_ROBOT PR2_ROBOT hasInHand (VAL @object)) @result))
			(!(DatabaseInterface.add (AGENT-STATEMENT PR2_ROBOT (VAL @agent) hasInHand (VAL @object)) @result))
			ELSEIF(?(EQUAL @type GRAB))
					;	       (=>(Robot.hasObject (VAL @arm)  (VAL @object)))  ;explanation in the next comment
			(=>(Robot.hasObjectForThrow (VAL @arm) (VAL @object)))
			(!(Spark.getFreeId @sparkId))
			(=>(Spark.request placeObjectForSimu (VAL @object) 0 0 0 0 0 0 1 @sparkId)) 
			(!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE FALSE NO_NAME))

			(!(Spark.getFreeId @sparkId))
			(=>(Spark.request setObjectInHand (VAL @agent) (VAL @object) (VAL @arm) FALSE (VAL @sparkId)))
			(!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE FALSE NO_NAME))

			(~>(Agent.hasObject (VAL @agent) (VAL @object)))
			(!(DatabaseInterface.add (AGENT-STATEMENT PR2_ROBOT PR2_ROBOT hasInHand (VAL @object)) @result))
			(!(DatabaseInterface.remove (AGENT-STATEMENT PR2_ROBOT (VAL @agent) hasInHand (VAL @object)) @result))
			;;At this point we should put an inference to tell spark that the robot has an object. The problem is that with handover the robot usually doesn't see the object so it would be attached in the wrong
			;;position. At the moment we just act like if the robot doesn't have the object.
			;; (?(Spark.robotFinger (VAL @arm) @sparkRobotFinger))                

			;; (!(HeadActions.getFreeId @headId))
			;; (=>(HeadActions.action lookAt @sparkRobotName @sparkRobotFinger @headId))
			;; (!(ExecutionManager.handleReport HeadActions.report @headId @executionId))

			;; (!(Spark.getFreeId @sparkId))
			;; (=>(Spark.request setObjectInHand @sparkRobotName (VAL @object) (VAL @arm) TRUE (VAL @sparkId)))
			;; (!(ExecutionManager.handleReport Spark.report @sparkId @executionId))
			
			
			)
		     )
		  )
	       (IF(?(&(Timer.elapsedTime (VAL @timerId)) (~(EQUAL @task completed))))  ;check the timer
		  (!(= @time expired))
		  (~>(Timer.elapsedTime (VAL @timer)))
		  
		  ELSE
		  (!(= @time ok))
		  )
	 
	       ;;update the opmdp
	       (!(= @xState (TERM-STRING-CAT @inRange @task @time)))                       
	       (!(= @obs (TERM-STRING-CAT @armPosition @distance @orientation)))
	       
	       (!(POMDP.update Handover @obs @xState @action @yState))
	       
	       )
	 
					;task is over. We go to rest state
	 (!(ExecutionManager.cleanModuleRequestes))
	 
	 (IF(?(EQUAL @task completed))
	    (!(Acapela.say "Good! Thank you!"))
	    
	    (=>(ExecutionManager.report @executionId OK))
	   
	    ELSE
	    (=>(ExecutionManager.report @executionId FAILURE))
	    )
	 (IF(?(Timer.isRunning (VAL @timerId)))
	    (=>(Timer.stopTimer @timerId))
	    )
	 (IF(?(Timer.elapsedTime (VAL @timerId)))
	    (~>(ExecutionManager.elapsedTime (VAL @timerId)))
	    )

	 (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
	 (!(SEM-V ExecutionManager.sem))

	 )
  )




 (defop |throw|
   :invocation(ExecutionManager.execute throw @object @placement @executionId)
   :documentation "throw an object to a certain placement"
   :body (
	  (!(SEM-P ExecutionManager.sem))

	  (IF(?(&(~(Robot.hasObject @arm (VAL @object))) (~(Robot.hasObjectForThrow @arm (VAL @object)))))
	     (=>(ExecutionManager.report (VAL @executionId) FAILURE))
	     (!(SEM-V ExecutionManager.sem))
	     (!(FAILED))
	     )
	  (IF(?(Robot.hasObject @arm (VAL @object)))
	     
	     ELSE
	     (?(Robot.hasObjectForThrow @arm (VAL @object)))
	     )

	  (=>(ExecutionManager.isExecutingAction (VAL @executionId)))

	  ;;set the parameters for ehe monitor manager
	  (!(= @failureConditions (. (. .)   (. (ExecutionManager.report (VAL @executionId) FAILURE) (ExecutionManager.report (VAL @executionId) STOPPED) .) .) )) 	 ; item not there 
	  (!(= @successConditions (. (. (ExecutionManager.report (VAL @executionId) OK) .)  (. .) .) ))     ; when the execution starts the robot is free to monitor something else
	  
	  (!(MonitorManager.getFreeId @monitorId))
					;start the monitoring
	  (!(MonitorManager.monitorTarget (VAL @placement) "NO_NAME" (VAL @successConditions) (VAL @failureConditions) HIGH (VAL @monitorId)))	   
	  (^(MonitorManager.isMonitoringTarget (VAL @monitorId)))


					;get coordinates of the placement
	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request getJointAbsPose (VAL @placement) NO_NAME (VAL @sparkId)))
	  (!(ExecutionManager.handleReport Spark (VAL @sparkId) (VAL @executionId) FALSE FALSE NO_NAME))
	  (^(Spark.result (VAL @sparkId) @xp @yp @zp @yawp @pitchp @rollp))
	  (~>(Spark.result (VAL @sparkId) (VAL @xp) (VAL @yp) (VAL @zp) (VAL @yawp) (VAL @pitchp) (VAL @rollp)))


	  ;;get the actual position for the throw
	  (!(= @zf (+ @zp 0.60)))
	 

	  ;move the arm over the placement
	  (!(ArmActions.getFreeId @actionId))
	  (=>(ArmActions.action moveToX @arm @xp @yp @zf @actionId))
	  (!(ExecutionManager.handleReport ArmActions @actionId @executionId TRUE TRUE (VAL @placement)))
	  
	  
	  ;;execute the throw
	  (!(ArmActions.getFreeId @actionId))
	  (=>(ArmActions.action openGripper @arm @actionId))
	  (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE @placement))

	  (=>(ExecutionManager.report @executionId OK))
	  (~>(Robot.hasObject (VAL @arm) (VAL @object)))
	  (~>(Robot.hasObjectForThrow (VAL @arm) (VAL @object)))

	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request setObjectInHand PR2_ROBOT (VAL @object) (VAL @armForPick) FALSE (VAL @sparkId)))
	  (!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE FALSE NO_NAME))


	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request getJointAbsPose @placement NO_NAME @sparkId))
	  (!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE FALSE NO_NAME))
	  (^(Spark.result (VAL @sparkId) @x @y @z @yaw @pitch @roll))

	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request setInferrenceForObject @object 1 @placement 0 SPARK_IS_IN 1.0 @sparkId))
	  (!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE FALSE NO_NAME))
	  (!(DatabaseInterface.remove (AGENT-STATEMENT PR2_ROBOT PR2_ROBOT hasInHand (VAL @object)) @result))

	  (!(SEM-V ExecutionManager.sem))
	  
	  (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
	  )
   
   )

(defop |place|
  :invocation(ExecutionManager.execute place @object @support @placement @executionId)
  :documentation "Places an object on a support in a specific placement or a casual one if placement is NO_NAME. For now the casual version is not implemented"
  :body (
	 (!(SEM-P ExecutionManager.sem))


	 (IF(?(~(Robot.hasObject @arm  (VAL @object))))
	    (=>(ExecutionManager.report (VAL @executionId) FAILURE))
	    (!(SEM-V ExecutionManager.sem))
	    (!(FAILED))
	    )
	 (?(Robot.hasObject @arm (VAL @object)))
	 
	 (=>(ExecutionManager.isExecutingAction (VAL @executionId)))


					;move the arm over the placement
	  (!(ArmActions.getFreeId @actionId))
	  (=>(ArmActions.action moveToPlaceObject @arm @object @support @placement @actionId))
	  (!(ExecutionManager.handleReport ArmActions @actionId @executionId TRUE TRUE NO_NAME))
	  
	  
	  ;;open the gripper
	  (!(ArmActions.getFreeId @actionId))
	  (=>(ArmActions.action openGripper @arm @actionId))
	  (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE FALSE NO_NAME))
	  
	  (=>(ExecutionManager.report @executionId OK))
	  (~>(Robot.hasObject (VAL @arm) (VAL @object)))
  
	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request setObjectInHand (VAL @object) (VAL @armForPick) FALSE (VAL @sparkId)))
	  (!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE FALSE NO_NAME))

	  (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
		  
	 (!(SEM-V ExecutionManager.sem))	 
	 )
  )
(defop |takeSandra|
   :invocation(ExecutionManager.execute takeSandra @object @arm @executionId)
   :documentation "this procedure takes the object @object. @arm can be setted to one of the two arms (RIGHT or LEFT) or to NO_NAME. In that case the robot chooses the arm to compute the action, execution mecanism of action with state machine is used"
   :body (
	(=>(ExecutionManager.haveToRun (VAL @executionId)))
	(=>(ExecutionManager.verifyPrec (VAL @executionId)))
	;;execution loop
	(WHILE(?(ExecutionManager.haveToRun (VAL @executionId) ))
		;; Verification of pre-conditions
		(IF(?(ExecutionManager.verifyPrec (VAL @executionId) ))
			(~>(ExecutionManager.verifyPrec (VAL @executionId)))
	 		(IF(?(ExecutionManager.stop (VAL @executionId) )) ;; stop of the action
				(~>(ExecutionManager.stop (VAL @executionId)))
				(=>(ExecutionManager.goToStop (VAL @executionId) PRE NO_NAME NO_ID))
				ELSEIF(?(ExecutionManager.suspend (VAL @executionId)))
					(~>(ExecutionManager.suspend (VAL @executionId)))
					(=>(ExecutionManager.goToSuspend (VAL @executionId) PRE NO_NAME NO_ID))
				ELSEIF(?(Robot.hasObject @anyArm (VAL @object))) ;;action already done
					(!(PRINT "Object already in hand"))
					(~>(ExecutionManager.haveToRun (VAL @executionId)))
					(=>(ExecutionManager.done (VAL @executionId)))
						ELSE
							(IF(?(EQUAL @arm NO_NAME)) ;; if no arm is choosen we look at the two hands
								(IF(?(Robot.hasObject RIGHT @anyObject))
									(IF(?(Robot.hasObject LEFT @anyObject)) ;; if the two hands are busy the action is impossible
										(!(PRINT "Hand busy"))
										(~>(ExecutionManager.haveToRun (VAL @executionId)))
		 	    							(=> (ExecutionManager.failed (VAL @executionId) PRE HAND))
										ELSE
											(!(= @armFree LEFT))
										)
									ELSEIF(?(Robot.hasObject LEFT @anyObject)) ;; else, if there is an object in only one hand we choose the other
										(!(= @armFree RIGHT))
										ELSE
											(!(= @armFree NO_NAME))
									)
								ELSEIF(?(EQUAL @arm RIGHT)) ;; if a hand is choose, we llok only this hand
									(IF(?(Robot.hasObject RIGHT @anyObject))
										(!(PRINT "Hand busy"))
										(~>(ExecutionManager.haveToRun (VAL @executionId)))
										(=> (ExecutionManager.failed (VAL @executionId) PRE HAND))
										ELSE
											(!(= @armFree RIGHT))
										)
									ELSEIF(?(EQUAL @arm LEFT))
										(IF(?(Robot.hasObject LEFT @anyObject))
											(!(PRINT "Hand busy"))
											(~>(ExecutionManager.haveToRun (VAL @executionId)))
											(=> (ExecutionManager.failed (VAL @executionId) PRE HAND))
											ELSE
												(!(= @armFree LEFT))
											)
								)
							(IF(?(ExecutionManager.haveToRun (VAL @executionId)))
								(!(HeadActions.getFreeId @headId))
								(=>(HeadActions.action isLookingAt (VAL @object) NO_NAME (VAL @headId)))
								(^(HeadActions.report (VAL @headId) @report))
								(~>(HeadActions.report (VAL @headId) @report))
								(IF(?(EQUAL @report "FALSE")) ;; we want that the object be looking before planning 
									(=>(ExecutionManager.fixePre (VAL @executionId) OBJECT (VAL @object) PRE)) ;; call fonction for find and look the object
									ELSEIF(?(EQUAL @report "FAILED"))
										(~>(ExecutionManager.haveToRun (VAL @executionId)))
		 	    							(=> (ExecutionManager.failed (VAL @executionId) PRE HEAD_ACTION))
							       		ELSE
										        (!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT (VAL @object) isReachable @reachability) (. @reachability .) @result)) ;; the object need to be reachable
											(IF(?(EQUAL (CAR (CAR @result)) true))
												(IF(?(EQUAL @armFree NO_NAME))
													(!(ExecutionManager.chooseArmForTake (VAL @object) (VAL @executionId) @armForPick))	;; we choose an arm with thi function but we always know that there is a choice if the planning failed
													ELSE
													(!(= @armForPick (VAL @armFree)))
													)
												(IF(?(Robot.gripper (VAL @armForPick) CLOSE)) ;;if the gripper of the hand choosen is close we open it
													(=>(ExecutionManager.fixePre (VAL @executionId) GRIPPER (VAL @armForPick) PRE))
													ELSE ;;pre-conditions ok, we can plan
														(!(PRINT "Pre-conditions ok"))
														(=> (ExecutionManager.plan (VAL @executionId)))
													)
												ELSE      
												        (!(PRINT "Object non reachable"))
												        (~>(ExecutionManager.haveToRun (VAL @executionId)))
		 	    									        (=> (ExecutionManager.failed (VAL @executionId) PRE REACHABLE))
												)
	 								)
		    	 							
											
								)
				)
			)

		;; Fixe pre-conditions at begining or at a restart, possibly by calling other actions
		(IF(?(ExecutionManager.fixePre (VAL @executionId) @problem @param @state)) ;; @problem can be GRIPPER to open a gripper or OBJECT to find and look an object, @param : for gripper close the arm of the gripper for OBJECT is the object to look, @state is the state were the function is called
			(~>(ExecutionManager.fixePre (VAL @executionId) @problem @param @state))
			(IF(?(EQUAL @problem GRIPPER)) 
				(!(ArmActions.getFreeId @actionId))
	  			(=>(ArmActions.action openGripper (VAL @param) (VAL @actionId)))
				(^(ArmActions.report (VAL @actionId) @result))
				(~>(ArmActions.report (VAL @actionId) @result))
				(IF(?(EQUAL @result "OK"))
					(IF(?(EQUAL @state PRE))
						(=>(ExecutionManager.verifyPrec (VAL @executionId)))
						ELSEIF(?(EQUAL @state RESTART))
							(=>(ExecutionManager.goToRestart (VAL @executionId)))
						)
					ELSE
						(~>(ExecutionManager.haveToRun (VAL @executionId)))
		 	    			(=> (ExecutionManager.failed (VAL @executionId) FIXE GRIPPER))
					)
				ELSEIF(?(EQUAL @problem OBJECT))
					(=>(ExecutionManager.shearchObject (VAL @executionId)))
					(WHILE(?(ExecutionManager.shearchObject (VAL @executionId)))
						(IF(?(Executionmanager.stop (VAL @executionId)))
							(~>(ExecutionManager.shearchObject (VAL @executionId)))
							(~>(ExecutionManager.stop (VAL @executionId)))
							(=>(ExecutionManager.goToStop (VAL @executionId) FIXE NO_NAME NO_ID))
							ELSEIF(?(ExecutionManager.suspend (VAL @executionId)))
								(~>(ExecutionManager.shearchObject (VAL @executionId)))
								(~>(ExecutionManager.suspend (VAL @executionId)))
								(=>(ExecutionManager.goToSuspend (VAL @executionId) FIXE NO_NAME NO_ID))
							ELSE
								(!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT (VAL @object) isVisible @visibility) (. @visibility .) @result))
								(IF(?(EQUAL (CAR (CAR @result)) true))
									(!(HeadActions.getFreeId @headId))
									(=>(HeadActions.action isLookingAt (VAL @param) NO_NAME (VAL @headId)))
									(^(HeadActions.report (VAL @headId) @report))
									(~>(HeadActions.report (VAL @headId) @report))
									(IF(?(EQUAL @report "FALSE"))
										(!(HeadActions.getFreeId @headId))
										(=>(HeadActions.action lookAt (VAL @param) NO_NAME (VAL @headId)))
										(^(HeadActions.report (VAL @headId) @report))
										(~>(HeadActions.report (VAL @headId) @report))
										(IF(?(EQUAL @report "FAILED"))
											(~>(ExecutionManager.shearchObject (VAL @executionId)))
											(~>(ExecutionManager.haveToRun (VAL @executionId)))
				 	    						(=> (ExecutionManager.failed (VAL @executionId) FIXE HEAD_ACTION))
											)
										ELSEIF(?(EQUAL @report "TRUE"))
											(~>(ExecutionManager.shearchObject (VAL @executionId)))
											ELSEIF(?(EQUAL @report "FAILED"))
												(~>(ExecutionManager.shearchObject (VAL @executionId)))
												(~>(ExecutionManager.haveToRun (VAL @executionId)))
				 	    							(=> (ExecutionManager.failed (VAL @executionId) FIXE HEAD_ACTION))
										)
									ELSE ;; if the object is not visible we look around to find it
										(!(HeadActions.getFreeId @headId))
										(=>(HeadActions.action headExplore (VAL @headId)))
										(^(|| (|| (HeadActions.report (VAL @headId) @report) (ExecutionManager.stop (VAL @executionId))) (ExecutionManager.suspend (VAL @executionId))))
										(IF(?(Execution.Manager.stop (VAL @executionId)))
											(~>(ExecutionManager.shearchObject (VAL @executionId)))
											(~>(ExecutionManager.stop (VAL @executionId)))
											(=>(ExecutionManager.goToStop (VAL @executionId) FIXE HEAD_ACTION (VAL @headId)))
											ELSEIF(?(ExecutionManager.suspend (VAL @executionId)))
												(~>(ExecutionManager.shearchObject (VAL @executionId)))
												(~>(ExecutionManager.suspend (VAL @executionId)))
												(=>(ExecutionManager.goToSuspend (VAL @executionId) FIXE HEAD_ACTION (VAL @headId)))
												ELSE
													(~>(HeadActions.report (VAL @headId) @report))
													(IF(?(EQUAL @report "FAILED"))
														(~>(ExecutionManager.shearchObject (VAL @executionId)))
														(~>(ExecutionManager.haveToRun (VAL @executionId)))
							 	    						(=> (ExecutionManager.failed (VAL @executionId) FIXE HEAD_ACTION))
														ELSE
															(!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT (VAL @object) isVisible @location) (. @location .) @result))
															(IF(?(EQUAL (CAR (CAR @result)) true));;if the object isnot visible after we failed because the object can't be seen
																(~>(ExecutionManager.shearchObject (VAL @executionId)))
																(~>(ExecutionManager.haveToRun (VAL @executionId)))
							 	    								(=> (ExecutionManager.failed (VAL @executionId) FIXE OBJECT))
																)						
														)
											)
									)
							)
						)
					(IF(?(ExecutionManager.haveToRun (VAL @executionId)))
						(IF(?(EQUAL @state PRE)) ;; we return t othe state were the function was called
							(=>(ExecutionManager.verifyPrec (VAL @executionId)))
							ELSEIF(?(EQUAL @state RESTART))
								(=>(ExecutionManager.goToRestart (VAL @executionId)))
								ELSEIF(?(EQUAL @state PLAN))
							 	    (=>(ExecutionManager.plan (VAL @executionId)))
							)
						)		
				)
			)

		;; Planification
		(IF(?(ExecutionManager.plan (VAL @executionId)))
			(~>(ExecutionManager.plan (VAL @executionId)))
			(!(PRINT "Planification"))
			(?(Mhp.arm (VAL @armForPick) @mhpArm))

	 		(!(Mhp.makeArmStartParameter 0 0 0 0 0 0 0 @armStart))
	  		(!(= @objStart (objStart 0.0 0.0 0.0 0.0 0.0 0.0)))
	  		(!(Mhp.getFreeId @mhpId))
	  
			(!(= @objGoto (objGoto 0.0 0.0 0.0 0.0 0.0 0.0)))
			(!(Mhp.makeArmGotoParameter 0 0 0 0 0 0 0 @armGoto))

	 		(=>(Mhp.request setTrajectory GEN_TRUE MHP_ARM_PICK_GOTO (VAL @mhpArm) (VAL @armStart) (VAL @armGoto) (VAL @object) NO_NAME NO_NAME GEN_FALSE 0 (VAL @objStart) 0 (VAL @objGoto) (VAL @mhpId)))
			
			(^(|| (Mhp.report (VAL @mhpId) @report) (ExecutionManager.stop (VAL @executionId))))
			(IF(?(ExecutionManager.stop (VAL @executionId)))
				(~>(ExecutionManager.stop (VAL @executionId)))
				(=>(ExecutionManager.goToStop (VAL @executionId) PLAN MHP NO_ID))
				ELSE
					(~>(Mhp.report (VAL @mhpId) @report))
					(IF(?(~(EQUAL @report "OK"))) ;; no plan found
						(IF(?(EQUAL @armFree NO_NAME)) ;;if we have choosen a arm before, we retry with the other
							(IF(?(EQUAL @armForPick RIGHT))
								(!(= @armForPick LEFT))
								(!(= @armFree LEFT))
								(=> (ExecutionManager.plan (VAL @executionId)))
								ELSE
									(!(= @armForPick RIGHT))
									(!(= @armFree RIGHT))
									(=> (ExecutionManager.plan (VAL @executionId)))
								)
							(IF(?(Robot.gripper (VAL @armForPick) CLOSE)) ;;if the gripper of the hand choosen is close we open it
					       		    	(=>(ExecutionManager.fixePre (VAL @executionId) GRIPPER (VAL @armForPick) PLAN))
								)
							ELSE
								(!(PRINT "No plan found"))
								(~>(ExecutionManager.haveToRun (VAL @executionId)))
		  	    					(=> (ExecutionManager.failed (VAL @executionId) PLAN (VAL @armForPick)))
							)
						ELSEIF(?(& (EQUAL @report "OK") (ExecutionManager.suspend (VAL @executionId)))) ;; plan found but suspend order, we go to suspend state before execution
							(~>(ExecutionManager.suspend (VAL @executionId)))
							(!(PRINT "Plan found"))
							(=>(ExecutionManager.goToSuspend (VAL @executionId) PLAN NO_NAME NO_ID)) ;; plan found and no suspend order, we go to execution
							ELSEIF(?(EQUAL @report "OK"))
								(!(PRINT "Plan found"))
								(=>(ExecutionManager.exec (VAL @executionId) 0))
						)
				)
			)

     
		;; Execution
		(IF(?(ExecutionManager.exec (VAL @executionId) @restart))
			(~>(ExecutionManager.exec (VAL @executionId) @restart));; @restart : 0 if the action begin, 1 if it is a restart of the arm movement and 2 if there is only the gripper to close
			(IF(?(EQUAL @restart 0));; if it isn't a restart we do the movement plan by mhp, else 
				(?(Softmotion.arm (VAL @armForPick) @smArm))
				(!(Softmotion.getFreeId @execId))
	 			(=>(Softmotion.request moveArmWithoutMhpClean (VAL @smArm) (VAL @execId)))
				)
			(IF(?(|| (EQUAL @restart 0) (EQUAL @restart 1)))
				(^(|| (||(Softmotion.report (VAL @execId) @report) (ExecutionManager.stop (VAL @executionId))) (ExecutionManager.suspend (VAL @executionId)) ))
				(IF(?(ExecutionManager.stop (VAL @executionId)))
					(~>(ExecutionManager.stop (VAL @executionId)))
					(=>(ExecutionManager.goToStop (VAL @executionId) EXEC ARM_ACTION (VAL @execId)))
					ELSEIF(?(ExecutionManager.suspend (VAL @executionId)))
						(~>(ExecutionManager.suspend (VAL @executionId)))
						(=>(ExecutionManager.goToSuspend (VAL @executionId) EXEC ARM_ACTION (VAL @execId)))
						ELSE
							(~>(Softmotion.report (VAL @execId) @report))
							(IF(?(EQUAL @report "OK")) ;; execution ok, we have to verify the post conditions
								(=>(ExecutionManager.closeGripper (VAL @executionId)))
								(!(Mhp.cleanTrajectories)) ;; if the movement succeed we can cleen the mhp trajectory
								ELSEIF(?(EQUAL @report "FAILED"))
									(!(PRINT "Movement failed"))
									(!(Mhp.cleanTrajectories))
									(~>(ExecutionManager.haveToRun (VAL @executionId)))
			  	    					(=> (ExecutionManager.failed (VAL @executionId) EXEC ARM_ACTION))
									ELSE ;;TO BE REMOVED : when there will be a report from restart
									     (^(ELAPSED-TIME(TIME) 3))
									     (=>(ExecutionManager.closeGripper (VAL @executionId)))
									     (!(Mhp.cleanTrajectories)) ;; if the movement succeed we can cleen the mhp trajectory
								)
					)
				)
			(IF(?(ExecutionManager.closeGripper (VAL @executionId)))
			   (~>(ExecutionManager.closeGripper (VAL @executionId)))
		  	   (!(ArmActions.getFreeId @actionId))
	  		   (=>(ArmActions.action closeGripper @armForPick @actionId))
	  		   (^(|| (||(ArmActions.report (VAL @actionId) @report) (ExecutionManager.stop (VAL @executionId))) (ExecutionManager.suspend (VAL @executionId)) ))
			   (IF(?(ExecutionManager.stop (VAL @executionId)))
				(~>(ExecutionManager.stop (VAL @executionId)))
				(=>(ExecutionManager.goToStop (VAL @executionId) EXEC GRIPPER (VAL @actionId)))
				ELSEIF(?(ExecutionManager.suspend (VAL @executionId)))
					(~>(ExecutionManager.suspend (VAL @executionId)))
					(=>(ExecutionManager.goToSuspend (VAL @executionId) EXEC GRIPPER (VAL @actionId)))
					ELSE
						(~>(ArmActions.report (VAL @actionId) @report))
						(IF(?(EQUAL @report "OK")) ;; execution ok, we have to verify the post conditions
							(!(PRINT "Execution ok"))
							(=>(ExecutionManager.verifyPost (VAL @executionId)))
							ELSE
								(!(PRINT "Close gripper failed"))
								(~>(ExecutionManager.haveToRun (VAL @executionId)))
		  	    					(=> (ExecutionManager.failed (VAL @executionId) EXEC GRIPPER))
								)
					)
			   )
			)

		;; Verification Post-conditions
		(IF(?(ExecutionManager.verifyPost (VAL @executionId))) ;;actualy more a set post-condition....
			(~>(ExecutionManager.verifyPost (VAL @executionId)))

			(=> (Robot.hasObject (VAL @armForPick) (VAL @object)))

	 		(!(Spark.getFreeId @sparkId))
	 		(=>(Spark.request setObjectInHand PR2_ROBOT (VAL @object) (VAL @armForPick) TRUE (VAL @sparkId)))
			(^(Spark.report (VAL @sparkId) @etat))
			(~>(Spark.report (VAL @sparkId) @etat))
	
			(IF(?(EQUAL @etat "OK")) ;; we don't look the stop and suspend order because the action is finished
				(!(PRINT "Post conditions ok"))
				(=>(ExecutionManager.done (VAL @executionId)))
				(~>(ExecutionManager.haveToRun (VAL @executionId)))
				ELSE
					(!(PRINT "Post conditions not ok"))
					(~>(ExecutionManager.haveToRun (VAL @executionId)))
		  	    		(=> (ExecutionManager.failed (VAL @executionId) POST SPARK))
				)
			)


		;; Suspended state
		(IF(?(ExecutionManager.suspended (VAL @executionId) @state @param @xObj @yObj @zObj @yawObj @pitchObj @rollObj))
			(IF(?(|| (Robot.isMovingArm (VAL @armForPick) TRUE) (Robot.isMoving TRUE))) ;; we look if the arm for pick move during the suspend time
				(!(= @armMove TRUE))
				)
			(IF(?(ExecutionManager.stop))
			        (~>(ExecutionManager.suspended (VAL @executionId) @state @param @xObj @yObj @zObj @yawObj @pitchObj @rollObj))
				(~>(ExecutionManager.stop (VAL @executionId)))
				(=>(ExecutionManager.goToStop (VAL @executionId) SUSPEND NO_NAME))
				ELSEIF(?(ExecutionManager.restart (VAL @executionId)))
				        (~>(ExecutionManager.suspended (VAL @executionId) @state @param @xObj @yObj @zObj @yawObj @pitchObj @rollObj))
					(~>(ExecutionManager.restart (VAL @executionId)))
					(=>(ExecutionManager.goToRestart (VAL @executionId) (VAL @state) (VAL @param) (VAL @xObj) (VAL @yObj) (VAL @zObj) (VAL @yawObj) (VAL @pitchObj) (VAL @rollObj) (VAL @armMove)))
				)
			)


		;; Go to stop state
		(IF(?(ExecutionManager.goToStop (VAL @executionId) @state @param @id))
			(~>(ExecutionManager.goToStop (VAL @executionId) @state @param @id))
			(!(PRINT "Go to stop"))
			(IF(?(EQUAL @param NO_NAME))
				(~>(ExecutionManager.haveToRun (VAL @executionId)))
				(=>(ExecutionManager.stopped (VAL @executionId)))
				ELSEIF(?(EQUAL @param MHP))
					(!(Mhp.cleanTrajectories))
					(~>(ExecutionManager.haveToRun (VAL @executionId)))
					(=>(ExecutionManager.stopped (VAL @executionId)))
					ELSEIF(?(EQUAL @param ARM_ACTION))
						(!(Softmotion.getFreeId @smId))
		 				(=>(Softmotion.request stop (VAL @smId)))
						(^(Softmotion.report (VAL @smId) @report))
						(~>(Softmotion.report (VAL @smId) @report))
						(!(Mhp.cleanTrajectories))
						(IF(?(EQUAL @report "OK"))
							(!(PRINT "Stop ok"))
							(~>(ExecutionManager.haveToRun (VAL @executionId)))
							(=>(ExecutionManager.stopped (VAL @executionId)))
							ELSEIF(?(EQUAL @report "FAILED"))
								(!(PRINT "stop failed"))
								(~>(ExecutionManager.haveToRun (VAL @executionId)))
					  	    		(=> (ExecutionManager.failed (VAL @executionId) STOP ARM_ACTION))
							)
						ELSEIF(?(EQUAL @param HEAD_ACTION))
							(=>(HeadActions.stop (VAL @id)))
							(^(HeadActions.report (VAL @id) @report))
							(~>(HeadActions.report (VAL @id) @report))
							(IF(?(EQUAL @report "OK"))
								(!(PRINT "Stop ok"))
								(~>(ExecutionManager.haveToRun (VAL @executionId)))
								(=>(ExecutionManager.stopped (VAL @executionId)))
								ELSEIF(?(EQUAL @report "FAILED"))
									(!(PRINT "stop failed"))
									(~>(ExecutionManager.haveToRun (VAL @executionId)))
						  	    		(=> (ExecutionManager.failed (VAL @executionId) STOP HEAD_ACTION))
								)
				)
			)

		;; Go to suspend state
		(IF(?(ExecutionManager.goToSuspend (VAL @executionId) @state @param @id))
			(~>(ExecutionManager.goToSuspend (VAL @executionId) @state @param @id))
			(!(PRINT "Go to suspend"))
			(!(Spark.getFreeId @sparkId))
			(=>(Spark.request getJointAbsPose (VAL @object) NO_NAME (VAL @sparkId))) ;; we save the position of the object
			(^(Spark.result (VAL @sparkId) @xObj @yObj @zObj @yawObj @pitchObj @rollObj))
			(!(= @armMove FALSE))
			(IF(?(||(EQUAL @state PRE) (EQUAL @state PLAN)))
			        (!(PRINT "Suspended"))
				(=>(ExecutionManager.report (VAL @executionId) SUSPEND))
				(=>(ExecutionManager.suspended (VAL @executionId) (VAL @state) (VAL @param) (VAL @xObj) (VAL @yObj) (VAL @zObj) (VAL @yawObj) (VAL @pitchObj) (VAL @rollObj)))
				ELSEIF(?(EQUAL @state FIXE))
					(IF(?(EQUAL @param NO_NAME))
					        (!(PRINT "Suspended"))
						(=>(ExecutionManager.report (VAL @executionId) SUSPEND))
						(=>(ExecutionManager.suspended (VAL @executionId) (VAL @state) (VAL @param) (VAL @xObj) (VAL @yObj) (VAL @zObj) (VAL @yawObj) (VAL @pitchObj) (VAL @rollObj)))
						ELSEIF(?(EQUAL @param HEAD_ACTION))
							(=>(HeadActions.stop (VAL @id)))
							(^(HeadActions.report (VAL @id) @report))
							(~>(HeadActions.report (VAL @id) @report))
							(IF(?(EQUAL @report "OK"))
							        (!(PRINT "Suspended"))
								(=>(ExecutionManager.report (VAL @executionId) SUSPEND))
								(=>(ExecutionManager.suspended (VAL @executionId) (VAL @state) (VAL @param) (VAL @xObj) (VAL @yObj) (VAL @zObj) (VAL @yawObj) (VAL @pitchObj) (VAL @rollObj)))
								ELSEIF(?(EQUAL @report "FAILED"))
									(!(PRINT "suspend failed"))
									(~>(ExecutionManager.haveToRun (VAL @executionId)))
						  	    		(=> (ExecutionManager.failed (VAL @executionId) SUSPEND HEAD_ACTION))
								)
						)
					ELSEIF(?(EQUAL @state EXEC))
						(!(Softmotion.getFreeId @smId))
		 				(=>(Softmotion.request halt (VAL @smId)))
						(^(Softmotion.report (VAL @smId) @report))
						(~>(Softmotion.report (VAL @smId) @report))
						(IF(?(EQUAL @report "OK"))
							(=>(ExecutionManager.suspended (VAL @executionId) (VAL @state) (VAL @param) (VAL @xObj) (VAL @yObj) (VAL @zObj) (VAL @yawObj) (VAL @pitchObj) (VAL @rollObj)))
							(!(PRINT "Suspended"))
							(=>(ExecutionManager.report (VAL @executionId) SUSPEND))
							ELSEIF(?(EQUAL @report "FAILED"))
								(!(PRINT "suspend failed"))
								(~>(ExecutionManager.haveToRun (VAL @executionId)))
					  	    		(=> (ExecutionManager.failed (VAL @executionId) SUSPEND ARM_ACTION))
							)	
				)
			)

		;; Restart
		(IF(?(|| (ExecutionManager.goToRestart (VAL @executionId) @stateRestart @paramRestart @xObj @yObj @zObj @yawObj @pitchObj @rollObj @armMove) (ExecutionManager.goToRestart (VAL @executionId)))) 
			(~>(ExecutionManager.goToRestart (VAL @executionId) @state @param @xObj @yObj @zObj @yawObj @pitchObj @rollObj @armMove))
			(~>(ExecutionManager.goToRestart (VAL @executionId)))
			(!(PRINT "Restarting"))
			(IF(?(||(EQUAL @stateRestart PRE) (EQUAL @stateRestart FIXE))) ;; no plan before, we restart from pre-conditions
				(=>(ExecutionManager.verifyPrec (VAL @executionId)))
				ELSEIF(?(||(EQUAL @stateRestart PLAN) (EQUAL @stateRestart EXEC)))
					(IF(?(EQUAL @armMove TRUE)) ;; the arm for pick has moved, we restart from pre-conditions
						(!(Mhp.cleanTrajectories))
						(=>(ExecutionManager.verifyPrec (VAL @executionId)))
						ELSE
							(!(HeadActions.getFreeId @headId))
							(=>(HeadActions.action isLookingAt (VAL @object) NO_NAME (VAL @headId)))
							(^(HeadActions.report (VAL @headId) @report))
							(~>(HeadActions.report (VAL @headId) @report))
							(IF(?(EQUAL @report "FALSE")) ;; we want to look the object 
								(=>(ExecutionManager.fixePre (VAL @executionId) OBJECT (VAL @object) RESTART))
								ELSEIF(?(EQUAL @report "FAILED"))
									(~>(ExecutionManager.haveToRun (VAL @executionId)))
		 	    						(=> (ExecutionManager.failed (VAL @executionId) RESTART HEAD_ACTION))
							       		ELSE
										(!(Spark.getFreeId @sparkId))
										(=>(Spark.request getJointAbsPose (VAL @object) NO_NAME (VAL @sparkId)))
										(^(Spark.result (VAL @sparkId) @xNew @yNew @zNew @yawNew @pitchNew @rollNew))
										(IF(?(& (& (& (& (& (EQUAL @xNew @xObj) (EQUAL @yNew @yObj)) (EQUAL @zNew @zObj)) (EQUAL @yawNew @yawObj)) (EQUAL @pitchNew @pitchObj)) (EQUAL @rollNew @rollObj))) ;; the object has not moved
												(IF(?(Robot.gripper (VAL @armForPick) CLOSE));; we open the gripper if it is close
													(=>(ExecutionManager.fixePre (VAL @executionId) GRIPPER (VAL @armForPick) FIXE))
													ELSE ;;we can restart the old mhp plan
														(IF(?(EQUAL @stateRestart PLAN))
															(=>(ExecutionManager.exec (VAL @executionId) 0))
															ELSEIF(?(& (EQUAL @stateRestart EXEC) (EQUAL @paramRestart ARM_ACTION)))
																(!(Softmotion.getFreeId @smId))
																(IF(?(EQUAL @armForPick RIGHT))
		 															(=>(Softmotion.request resume RARM (VAL @smId)))
																	ELSE
																		(=>(Softmotion.request resume LARM (VAL @smId)))
																	)
																(^(Softmotion.report (VAL @smId) @report))
																(~>(Softmotion.report (VAL @smId) @report))
																(IF(?(EQUAL @report "OK"))
																	(=>(ExecutionManager.exec (VAL @executionId) 1))
																	ELSE
																		(!(PRINT "restart failed"))
																		(~>(ExecutionManager.haveToRun (VAL @executionId)))
					  	    												(=> (ExecutionManager.failed (VAL @executionId) RESTART ARM_ACTION))
																	)
																ELSEIF(?(& (EQUAL @stateRestart EXEC) (EQUAL @paramRestart GRIPPER)))
																	(=>(ExecutionManager.exec (VAL @executionId) 1))
															)						
													)
											ELSE ;; the object has moved, we have to restart from pre conditions
												(!(Mhp.cleanTrajectories))
												(=>(ExecutionManager.verifyPrec (VAL @executionId)))
											)
								)
						)
				)
			)

		)	

	;; FINAL STATES

	;;Action ok	
	(IF(?(ExecutionManager.done (VAL @executionId)))
		(~>(ExecutionManager.done (VAL @executionId)))
		(!(PRINT "Action ok"))
		(=> (ExecutionManager.report (VAL @executionId) OK))
		)

	;;Action failed	
	(IF(?(ExecutionManager.failed (VAL @executionId) @state @problem))
		(~>(ExecutionManager.failed (VAL @executionId) @state @problem))
		(!(PRINT "Action FAILED"))
		(=> (ExecutionManager.report (VAL @executionId) FAILED (VAL @state) (VAL @problem)))
		)

	;;Action stopped	
	(IF(?(ExecutionManager.stopped (VAL @executionId)))
		(~>(ExecutionManager.stopped (VAL @executionId)))
		(!(PRINT "Action stopped"))
		(=> (ExecutionManager.report (VAL @executionId) STOPPED))
		)

	
	)


)

(defop |placeSandra|
   :invocation(ExecutionManager.execute placeSandra @object @support @placement @executionId)
   :documentation "this procedure place the object @object in the placement @placement, execution mecanism of action with state machine is used"
   :body (
	(=>(ExecutionManager.haveToRun (VAL @executionId)))
	(=>(ExecutionManager.verifyPrec (VAL @executionId)))

	;;execution loop
	(WHILE(?(ExecutionManager.haveToRun (VAL @executionId) ))
		;; Verification of pre-conditions
		(IF(?(ExecutionManager.verifyPrec (VAL @executionId) ))
			(~>(ExecutionManager.verifyPrec (VAL @executionId)))
	 		(IF(?(ExecutionManager.stop (VAL @executionId) )) ;; stop of the action
				(~>(ExecutionManager.stop (VAL @executionId)))
				(=>(ExecutionManager.goToStop (VAL @executionId) PRE NO_NAME NO_ID))
				ELSEIF(?(ExecutionManager.suspend (VAL @executionId)))
					(~>(ExecutionManager.suspend (VAL @executionId)))
					(=>(ExecutionManager.goToSuspend (VAL @executionId) PRE NO_NAME NO_ID))
				ELSE
					(!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT (VAL @object) isOn @place) (. @place .) @result))
					(IF(?(EQUAL (CAR (CAR @result)) @placement)) ;;action already done
						(!(PRINT "Object already in the placement"))
						(~>(ExecutionManager.haveToRun (VAL @executionId)))
						(=>(ExecutionManager.done (VAL @executionId)))
							ELSEIF(?(~(Robot.hasObject @anyArm (VAL @object)))) ;; the robot have to have the object
								(!(PRINT "The robot don't have the object"))
								(~>(ExecutionManager.haveToRun (VAL @executionId)))
			 	    				(=> (ExecutionManager.failed (VAL @executionId) PRE OBJECT))
								ELSE
									(!(= @armForPlace @anyArm))
									
									(!(HeadActions.getFreeId @headId))
									(=>(HeadActions.action isLookingAt (VAL @placement) NO_NAME (VAL @headId)))
									(^(HeadActions.report (VAL @headId) @report))
									(~>(HeadActions.report (VAL @headId) @report))
									(IF(?(EQUAL @report "FALSE")) ;; we want that the placement be looking before planning 
										(=>(ExecutionManager.fixePre (VAL @executionId) OBJECT (VAL @placement) PRE)) ;; call fonction for find and look the placement
										ELSEIF(?(EQUAL @report "FAILED"))
											(~>(ExecutionManager.haveToRun (VAL @executionId)))
			 	    							(=> (ExecutionManager.failed (VAL @executionId) PRE HEAD_ACTION))
								       		ELSE
												(!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT (VAL @placement) isReachable @reachability) (. @reachability .) @result)) ;; the object need to be reachable
												(IF(?(EQUAL (CAR (CAR @result)) true))
													(!(PRINT "Pre-conditions ok"))
													(=> (ExecutionManager.plan (VAL @executionId)))
													ELSE      
														(!(PRINT "Placement non reachable"))
														(~>(ExecutionManager.haveToRun (VAL @executionId)))
			 	    									        (=> (ExecutionManager.failed (VAL @executionId) PRE REACHABLE))
													)
		 								)
						)
				)
			)

		;; Fixe pre-conditions at begining or at a restart, possibly by calling other actions
		(IF(?(ExecutionManager.fixePre (VAL @executionId) @problem @param @state)) ;; @problem can be GRIPPER to open a gripper or OBJECT to find and look an object, @param : for gripper close the arm of the gripper for OBJECT is the object to look, @state is the state were the function is called
			(~>(ExecutionManager.fixePre (VAL @executionId) @problem @param @state))
			(IF(?(EQUAL @problem OBJECT))
				(=>(ExecutionManager.shearchObject (VAL @executionId)))
				(WHILE(?(ExecutionManager.shearchObject (VAL @executionId)))
					(IF(?(Executionmanager.stop (VAL @executionId)))
						(~>(ExecutionManager.shearchObject (VAL @executionId)))
						(~>(ExecutionManager.stop (VAL @executionId)))
						(=>(ExecutionManager.goToStop (VAL @executionId) FIXE NO_NAME NO_ID))
						ELSEIF(?(ExecutionManager.suspend (VAL @executionId)))
							(~>(ExecutionManager.shearchObject (VAL @executionId)))
							(~>(ExecutionManager.suspend (VAL @executionId)))
							(=>(ExecutionManager.goToSuspend (VAL @executionId) FIXE NO_NAME NO_ID))
							ELSE
								(!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT (VAL @param) isVisible @visibility) (. @visibility .) @result))
								(IF(?(EQUAL (CAR (CAR @result)) true))
									(!(HeadActions.getFreeId @headId))
									(=>(HeadActions.action isLookingAt (VAL @param) NO_NAME (VAL @headId)))
									(^(HeadActions.report (VAL @headId) @report))
									(~>(HeadActions.report (VAL @headId) @report))
									(IF(?(EQUAL @report "FALSE"))
										(!(HeadActions.getFreeId @headId))
										(=>(HeadActions.action lookAt (VAL @param) NO_NAME (VAL @headId)))
										(^(HeadActions.report (VAL @headId) @report))
										(~>(HeadActions.report (VAL @headId) @report))
										(IF(?(EQUAL @report "FAILED"))
											(~>(ExecutionManager.shearchObject (VAL @executionId)))
											(~>(ExecutionManager.haveToRun (VAL @executionId)))
				 	    						(=> (ExecutionManager.failed (VAL @executionId) FIXE HEAD_ACTION))
											)
										ELSEIF(?(EQUAL @report "TRUE"))
											(~>(ExecutionManager.shearchObject (VAL @executionId)))
											ELSEIF(?(EQUAL @report "FAILED"))
												(~>(ExecutionManager.shearchObject (VAL @executionId)))
												(~>(ExecutionManager.haveToRun (VAL @executionId)))
				 	    							(=> (ExecutionManager.failed (VAL @executionId) FIXE HEAD_ACTION))
										)
									ELSE ;; if the object is not visible we look around to find it
										(!(HeadActions.getFreeId @headId))
										(=>(HeadActions.action headExplore (VAL @headId)))
										(^(|| (|| (HeadActions.report (VAL @headId) @report) (ExecutionManager.stop (VAL @executionId))) (ExecutionManager.suspend (VAL @executionId))))
										(IF(?(Execution.Manager.stop (VAL @executionId)))
											(~>(ExecutionManager.shearchObject (VAL @executionId)))
											(~>(ExecutionManager.stop (VAL @executionId)))
											(=>(ExecutionManager.goToStop (VAL @executionId) FIXE HEAD_ACTION (VAL @headId)))
											ELSEIF(?(ExecutionManager.suspend (VAL @executionId)))
												(~>(ExecutionManager.shearchObject (VAL @executionId)))
												(~>(ExecutionManager.suspend (VAL @executionId)))
												(=>(ExecutionManager.goToSuspend (VAL @executionId) FIXE HEAD_ACTION (VAL @headId)))
											ELSE
												(~>(HeadActions.report (VAL @headId) @report))
												(IF(?(EQUAL @report "FAILED"))
													(~>(ExecutionManager.shearchObject (VAL @executionId)))
													(~>(ExecutionManager.haveToRun (VAL @executionId)))
							 	    					(=> (ExecutionManager.failed (VAL @executionId) FIXE HEAD_ACTION))
													ELSE
														(!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT (VAL @param) isVisible @location) (. @location .) @result))
														(IF(?(EQUAL (CAR (CAR @result)) true));;if the placement is not visible after we failed because the object can't be seen
															(~>(ExecutionManager.shearchObject (VAL @executionId)))
															(~>(ExecutionManager.haveToRun (VAL @executionId)))
							 	    							(=> (ExecutionManager.failed (VAL @executionId) FIXE PLACEMENT))
															)						
													)
											)
									)
							)
						)
					(IF(?(ExecutionManager.haveToRun (VAL @executionId)))
						(IF(?(EQUAL @state PRE)) ;; we return to the state were the function was called
							(=>(ExecutionManager.verifyPrec (VAL @executionId)))
							ELSEIF(?(EQUAL @state RESTART))
								(=>(ExecutionManager.goToRestart (VAL @executionId)))
							)
						)		
				)
			)

		;; Planification
		(IF(?(ExecutionManager.plan (VAL @executionId)))
			(~>(ExecutionManager.plan (VAL @executionId)))
			(!(PRINT "Planification"))
			(?(Robot.armPosition (VAL @armForPlace) @position))
	 		(IF(?(EQUAL @position FREE))
	     			(!(= @task MHP_ARM_PLACE_FROM_FREE))
	   		  	(!(= @support NO_NAME))
	     			ELSE
	     				(!(= @task MHP_ARM_TAKE_TO_PLACE))
	     				(!(= @support @position))
	     			)
	  		(!(Mhp.makeArmGotoParameter 0 0 0 0 0 0 0 @armGoto))
	  
	  		(!(Spark.getFreeId @sparkId))
	  		(=>(Spark.request getJointAbsPose @placement NO_NAME @sparkId))
	  		(!(ArmActions.handleReport Spark.report @sparkId @actionId))
	  		(^(Spark.result (VAL @sparkId) @xp @yp @zp @yawp @pitchp @rollp))
	  		(~>(Spark.result (VAL @sparkId) (VAL @xp) (VAL @yp) (VAL @zp) (VAL @yawp) (VAL @pitchp) (VAL @rollp))) 
	  		(!(= @objGoto (objGoto @xp @yp @zp 0.0 0.0 0.0)))

			(?(Mhp.arm (VAL @armForPlace) @mhpArm))

	  		(!(Mhp.makeArmStartParameter 0 0 0 0 0 0 0 @armStart))
	  		(!(= @objStart (objStart 0.0 0.0 0.0 0.0 0.0 0.0)))
	  		(!(Mhp.getFreeId @mhpId))

	 		(=>(Mhp.request setTrajectory GEN_TRUE (VAL @task) (VAL @mhpArm) (VAL @armStart) (VAL @armGoto) (VAL @object) (VAL @support) (VAL @placement) GEN_FALSE 0 (VAL @objStart) (VAL @useObjGoto) (VAL @objGoto) (VAL @mhpId)))
			
			(^(|| (Mhp.report (VAL @mhpId) @report) (ExecutionManager.stop (VAL @executionId))))
			(IF(?(ExecutionManager.stop (VAL @executionId)))
				(~>(ExecutionManager.stop (VAL @executionId)))
				(=>(ExecutionManager.goToStop (VAL @executionId) PLAN MHP NO_ID))
				ELSE
					(~>(Mhp.report (VAL @mhpId) @report))
					(IF(?(~(EQUAL @report "OK"))) ;; no plan found
						(!(PRINT "No plan found"))
						(~>(ExecutionManager.haveToRun (VAL @executionId)))
		  	    			(=> (ExecutionManager.failed (VAL @executionId) PLAN (VAL @armForPlace)))
						ELSEIF(?(& (EQUAL @report "OK") (ExecutionManager.suspend (VAL @executionId)))) ;; plan found but suspend order, we go to suspend state before execution
							(~>(ExecutionManager.suspend (VAL @executionId)))
							(!(PRINT "Plan found"))
							(=>(ExecutionManager.goToSuspend (VAL @executionId) PLAN NO_NAME NO_ID)) ;; plan found and no suspend order, we go to execution
							ELSEIF(?(EQUAL @report "OK"))
								(!(PRINT "Plan found"))
								(=>(ExecutionManager.execute (VAL @executionId) 0))
						)
				)
			)

		;; Execution
		(IF(?(ExecutionManager.execute (VAL @executionId) @restart))
			(~>(ExecutionManager.execute (VAL @executionId) @restart));; @restart : 0 if the action begin, 1 if it is a restart of the arm movement and 2 if there is only the gripper to close
			(IF(?(EQUAL @restart 0));; if it isn't a restart we do the movement plan by mhp, else 
				(?(Softmotion.arm (VAL @armForPick) @smArm))
				(!(Softmotion.getFreeId @execId))
	 			(=>(Softmotion.request moveArmWithoutMhpClean (VAL @smArm) (VAL @execId)));; if the movement have been restart we have not to wait the report
				(^(|| (||(Softmotion.report (VAL @execId) @report) (ExecutionManager.stop (VAL @executionId))) (ExecutionManager.suspend (VAL @executionId)) ))
				(IF(?(ExecutionManager.stop (VAL @executionId)))
					(~>(ExecutionManager.stop (VAL @executionId)))
					(=>(ExecutionManager.goToStop (VAL @executionId) EXEC ARM_ACTION (VAL @execId)))
					ELSEIF(?(ExecutionManager.suspend (VAL @executionId)))
						(~>(ExecutionManager.suspend (VAL @executionId)))
						(=>(ExecutionManager.goToSuspend (VAL @executionId) EXEC ARM_ACTION (VAL @execId)))
						ELSE
							(~>(Softmotion.report (VAL @execId) @report))
							(IF(?(EQUAL @report "OK")) ;; execution ok, we have to verify the post conditions
								(=>(ExecutionManager.closeGripper (VAL @executionId)))
								(!(Mhp.cleanTrajectories)) ;; if the movment succeed we can cleen the mhp trajectory
								ELSE
									(!(PRINT "Movement failed"))
									(!(Mhp.cleanTrajectories))
									(~>(ExecutionManager.haveToRun (VAL @executionId)))
			  	    					(=> (ExecutionManager.failed (VAL @executionId) EXEC ARM_ACTION))
								)
					)
				)
			(IF(?(EQUAL @restart 1))
			   (=>(ExecutionManager.closeGripper (VAL @executionId)))
			   )
			(IF(?(ExecutionManager.closeGripper (VAL @executionId)))
			   (~>(ExecutionManager.closeGripper (VAL @executionId)))
		  	   (!(ArmActions.getFreeId @actionId))
	  		   (=>(ArmActions.action openGripper @arm @actionId))
	  		   (^(|| (||(ArmActions.report (VAL @actionId) @report) (ExecutionManager.stop (VAL @executionId))) (ExecutionManager.suspend (VAL @executionId)) ))
			   (IF(?(ExecutionManager.stop (VAL @executionId)))
				(~>(ExecutionManager.stop (VAL @executionId)))
				(=>(ExecutionManager.goToStop (VAL @executionId) EXEC GRIPPER (VAL @actionId)))
				ELSEIF(?(ExecutionManager.suspend (VAL @executionId)))
					(~>(ExecutionManager.suspend (VAL @executionId)))
					(=>(ExecutionManager.goToSuspend (VAL @executionId) EXEC GRIPPER (VAL @actionId)))
					ELSE
						(~>(ArmActions.report (VAL @actionId) @report))
						(IF(?(EQUAL @report "OK")) ;; execution ok, we have to verify the post conditions
							(!(PRINT "Execution ok"))
							(=>(ExecutionManager.verifyPost (VAL @executionId)))
							ELSE
								(!(PRINT "Open gripper failed"))
								(~>(ExecutionManager.haveToRun (VAL @executionId)))
		  	    					(=> (ExecutionManager.failed (VAL @executionId) EXEC GRIPPER))
								)
					)
			   )
			)

		;; Verification Post-conditions
		(IF(?(ExecutionManager.verifyPost (VAL @executionId))) ;;actualy more a set post-condition....
			(~>(ExecutionManager.verifyPost (VAL @executionId)))

			(~>(Robot.hasObject (VAL @arm) (VAL @object)))
  
	  		(!(Spark.getFreeId @sparkId))
	  		(=>(Spark.request setObjectInHand (VAL @object) (VAL @armForPick) FALSE (VAL @sparkId)))
			(^(Spark.report (VAL @sparkId) @etat))
			(~>(Spark.report (VAL @sparkId) @etat))
	
			(IF(?(EQUAL @etat "OK")) ;; we don't look the stop and suspend order because the action is finished
				(!(PRINT "Post conditions ok"))
				(=>(ExecutionManager.done (VAL @executionId)))
				(~>(ExecutionManager.haveToRun (VAL @executionId)))
				ELSE
					(!(PRINT "Post conditions not ok"))
					(~>(ExecutionManager.haveToRun (VAL @executionId)))
		  	    		(=> (ExecutionManager.failed (VAL @executionId) POST SPARK))
				)
			)


		;; Suspended state
		(IF(?(ExecutionManager.suspended (VAL @executionId) @state @param @xObj @yObj @zObj @yawObj @pitchObj @rollObj))
			(IF(?(|| (Robot.isMovingArm (VAL @armForPick) TRUE) (Robot.isMoving TRUE))) ;; we look if the arm for pick move during the suspend time
				(!(= @armMove TRUE))
				)
			(IF(?(ExecutionManager.stop))
			        (~>(ExecutionManager.suspended (VAL @executionId) @state @param @xObj @yObj @zObj @yawObj @pitchObj @rollObj))
				(~>(ExecutionManager.stop (VAL @executionId)))
				(=>(ExecutionManager.goToStop (VAL @executionId) SUSPEND NO_NAME))
				ELSEIF(?(ExecutionManager.restart (VAL @executionId)))
				        (~>(ExecutionManager.suspended (VAL @executionId) @state @param @xObj @yObj @zObj @yawObj @pitchObj @rollObj))
					(~>(ExecutionManager.restart (VAL @executionId)))
					(=>(ExecutionManager.goToRestart (VAL @executionId) (VAL @state) (VAL @param) (VAL @xObj) (VAL @yObj) (VAL @zObj) (VAL @yawObj) (VAL @pitchObj) (VAL @rollObj) (VAL @armMove)))
				)
			)


		;; Go to stop state
		(IF(?(ExecutionManager.goToStop (VAL @executionId) @state @param @id))
			(~>(ExecutionManager.goToStop (VAL @executionId) @state @param @id))
			(!(PRINT "Go to stop"))
			(IF(?(EQUAL @param NO_NAME))
				(~>(ExecutionManager.haveToRun (VAL @executionId)))
				(=>(ExecutionManager.stopped (VAL @executionId)))
				ELSEIF(?(EQUAL @param MHP))
					(!(Mhp.cleanTrajectories))
					(~>(ExecutionManager.haveToRun (VAL @executionId)))
					(=>(ExecutionManager.stopped (VAL @executionId)))
					ELSEIF(?(EQUAL @param ARM_ACTION))
						(!(Softmotion.getFreeId @smId))
		 				(=>(Softmotion.request stop (VAL @smId)))
						(^(Softmotion.report (VAL @smId) @report))
						(~>(Softmotion.report (VAL @smId) @report))
						(!(Mhp.cleanTrajectories))
						(IF(?(EQUAL @report "OK"))
							(!(PRINT "Stop ok"))
							(~>(ExecutionManager.haveToRun (VAL @executionId)))
							(=>(ExecutionManager.stopped (VAL @executionId)))
							ELSEIF(?(EQUAL @report "FAILED"))
								(!(PRINT "stop failed"))
								(~>(ExecutionManager.haveToRun (VAL @executionId)))
					  	    		(=> (ExecutionManager.failed (VAL @executionId) STOP ARM_ACTION))
							)
						ELSEIF(?(EQUAL @param HEAD_ACTION))
							(=>(HeadActions.stop (VAL @id)))
							(^(HeadActions.report (VAL @id) @report))
							(~>(HeadActions.report (VAL @id) @report))
							(IF(?(EQUAL @report "OK"))
								(!(PRINT "Stop ok"))
								(~>(ExecutionManager.haveToRun (VAL @executionId)))
								(=>(ExecutionManager.stopped (VAL @executionId)))
								ELSEIF(?(EQUAL @report "FAILED"))
									(!(PRINT "stop failed"))
									(~>(ExecutionManager.haveToRun (VAL @executionId)))
						  	    		(=> (ExecutionManager.failed (VAL @executionId) STOP HEAD_ACTION))
								)
				)
			)

		;; Go to suspend state
		(IF(?(ExecutionManager.goToSuspend (VAL @executionId) @state @param @id))
			(~>(ExecutionManager.goToSuspend (VAL @executionId) @state @param @id))
			(!(PRINT "Go to suspend"))
			(!(Spark.getFreeId @sparkId))
			(=>(Spark.request getJointAbsPose (VAL @placement) NO_NAME (VAL @sparkId))) ;; we save the position of the object
			(^(Spark.result (VAL @sparkId) @xObj @yObj @zObj @yawObj @pitchObj @rollObj))
			(!(= @armMove FALSE))
			(IF(?(||(EQUAL @state PRE) (EQUAL @state PLAN)))
			        (!(PRINT "Suspended"))
				(=>(ExecutionManager.report (VAL @executionId) SUSPEND))
				(=>(ExecutionManager.suspended (VAL @executionId) (VAL @state) (VAL @param) (VAL @xObj) (VAL @yObj) (VAL @zObj) (VAL @yawObj) (VAL @pitchObj) (VAL @rollObj)))
				ELSEIF(?(EQUAL @state FIXE))
					(IF(?(EQUAL @param NO_NAME))
					        (!(PRINT "Suspended"))
						(=>(ExecutionManager.report (VAL @executionId) SUSPEND))
						(=>(ExecutionManager.suspended (VAL @executionId) (VAL @state) (VAL @param) (VAL @xObj) (VAL @yObj) (VAL @zObj) (VAL @yawObj) (VAL @pitchObj) (VAL @rollObj)))
						ELSEIF(?(EQUAL @param HEAD_ACTION))
							(=>(HeadActions.stop (VAL @id)))
							(^(HeadActions.report (VAL @id) @report))
							(~>(HeadActions.report (VAL @id) @report))
							(IF(?(EQUAL @report "OK"))
							        (!(PRINT "Suspended"))
								(=>(ExecutionManager.report (VAL @executionId) SUSPEND))
								(=>(ExecutionManager.suspended (VAL @executionId) (VAL @state) (VAL @param) (VAL @xObj) (VAL @yObj) (VAL @zObj) (VAL @yawObj) (VAL @pitchObj) (VAL @rollObj)))
								ELSEIF(?(EQUAL @report "FAILED"))
									(!(PRINT "suspend failed"))
									(~>(ExecutionManager.haveToRun (VAL @executionId)))
						  	    		(=> (ExecutionManager.failed (VAL @executionId) SUSPEND HEAD_ACTION))
								)
						)
					ELSEIF(?(EQUAL @state EXEC))
						(!(Softmotion.getFreeId @smId))
		 				(=>(Softmotion.request halt (VAL @smId)))
						(^(Softmotion.report (VAL @smId) @report))
						(~>(Softmotion.report (VAL @smId) @report))
						(IF(?(EQUAL @report "OK"))
							(=>(ExecutionManager.suspended (VAL @executionId) (VAL @state) (VAL @param) (VAL @xObj) (VAL @yObj) (VAL @zObj) (VAL @yawObj) (VAL @pitchObj) (VAL @rollObj)))
							(!(PRINT "Suspended"))
							(=>(ExecutionManager.report (VAL @executionId) SUSPEND))
							ELSEIF(?(EQUAL @report "FAILED"))
								(!(PRINT "suspend failed"))
								(~>(ExecutionManager.haveToRun (VAL @executionId)))
					  	    		(=> (ExecutionManager.failed (VAL @executionId) SUSPEND ARM_ACTION))
							)	
				)
			)

		;; Restart
		(IF(?(|| (ExecutionManager.goToRestart (VAL @executionId) @stateRestart @paramRestart @xObj @yObj @zObj @yawObj @pitchObj @rollObj @armMove) (ExecutionManager.goToRestart (VAL @executionId)))) 
			(~>(ExecutionManager.goToRestart (VAL @executionId) @state @param @xObj @yObj @zObj @yawObj @pitchObj @rollObj @armMove))
			(~>(ExecutionManager.goToRestart (VAL @executionId)))
			(!(PRINT "Restarting"))
			(IF(?(||(EQUAL @stateRestart PRE) (EQUAL @stateRestart FIXE))) ;; no plan before, we restart from pre-conditions
				(=>(ExecutionManager.verifyPrec (VAL @executionId)))
				ELSEIF(?(||(EQUAL @stateRestart PLAN) (EQUAL @stateRestart EXEC)))
					(IF(?(EQUAL @armMove TRUE)) ;; the arm for pick has moved, we restart from pre-conditions
						(!(Mhp.cleanTrajectories))
						(=>(ExecutionManager.verifyPrec (VAL @executionId)))
						ELSE
							(IF(?(Robot.hasObject @anyArm (VAL @object)))
								(IF(?(EQUAL @anyArm @armForPlace))
									(!(HeadActions.getFreeId @headId))
									(=>(HeadActions.action isLookingAt (VAL @placement) NO_NAME (VAL @headId)))
									(^(HeadActions.report (VAL @headId) @report))
									(~>(HeadActions.report (VAL @headId) @report))
									(IF(?(EQUAL @report "FALSE")) ;; we want to look the object 
										(=>(ExecutionManager.fixePre (VAL @executionId) OBJECT (VAL @placement) RESTART))
										ELSEIF(?(EQUAL @report "FAILED"))
											(~>(ExecutionManager.haveToRun (VAL @executionId)))
			 	    							(=> (ExecutionManager.failed (VAL @executionId) RESTART HEAD_ACTION))
									       		ELSE
												(!(Spark.getFreeId @sparkId))
												(=>(Spark.request getJointAbsPose (VAL @placement) NO_NAME (VAL @sparkId)))
												(^(Spark.result (VAL @sparkId) @xNew @yNew @zNew @yawNew @pitchNew @rollNew))
												(IF(?(& (& (& (& (& (EQUAL @xNew @xObj) (EQUAL @yNew @yObj)) (EQUAL @zNew @zObj)) (EQUAL @yawNew @yawObj)) (EQUAL @pitchNew @pitchObj)) (EQUAL @rollNew @rollObj))) ;; the object has not moved
														(IF(?(EQUAL @stateRestart PLAN))
															(=>(ExecutionManager.execute (VAL @executionId) 0))
															ELSEIF(?(& (EQUAL @stateRestart EXEC) (EQUAL @paramRestart ARM_ACTION)))
																(!(Softmotion.getFreeId @smId))
																(IF(?(EQUAL @armForPlace RIGHT))
				 													(=>(Softmotion.request resume RARM (VAL @smId)))
																	ELSE
																		(=>(Softmotion.request resume LARM (VAL @smId)))
																	)
																(^(Softmotion.report (VAL @smId) @report))
																(~>(Softmotion.report (VAL @smId) @report))
																(IF(?(EQUAL @report "OK"))
																	(=>(ExecutionManager.execute (VAL @executionId) 1))
																	ELSE
																		(!(PRINT "restart failed"))
																		(~>(ExecutionManager.haveToRun (VAL @executionId)))
							  	    										(=> (ExecutionManager.failed (VAL @executionId) RESTART ARM_ACTION))
																	)
																ELSEIF(?(& (EQUAL @stateRestart EXEC) (EQUAL @paramRestart GRIPPER)))
																	(=>(ExecutionManager.execute (VAL @executionId) 1))
																	(!(PRINT "After execute order"))
														)
													ELSE ;; the object has moved, we haved to restart from pre conditions
														(!(Mhp.cleanTrajectories))
														(=>(ExecutionManager.verifyPrec (VAL @executionId)))
													)
										)
									ELSE
										(!(Mhp.cleanTrajectories))
										(=>(ExecutionManager.verifyPrec (VAL @executionId)))
									)
								ELSE ;; robot has not the object any more
									(~>(ExecutionManager.haveToRun (VAL @executionId)))
			 	    					(=> (ExecutionManager.failed (VAL @executionId) RESTART OBJECT))
								)
						)
				)
			(!(PRINT "End Restart"))
			)
		(!(PRINT "End Loop"))
		)	

	;; FINAL STATES

	;;Action ok	
	(IF(?(ExecutionManager.done (VAL @executionId)))
		(~>(ExecutionManager.done (VAL @executionId)))
		(!(PRINT "Action ok"))
		(=> (ExecutionManager.report (VAL @executionId) OK))
		)

	;;Action failed	
	(IF(?(ExecutionManager.failed (VAL @executionId) @state @problem))
		(~>(ExecutionManager.failed (VAL @executionId) @state @problem))
		(!(PRINT "Action FAILED"))
		(=> (ExecutionManager.report (VAL @executionId) FAILED (VAL @state) (VAL @problem)))
		)

	;;Action stopped	
	(IF(?(ExecutionManager.stopped (VAL @executionId)))
		(~>(ExecutionManager.stopped (VAL @executionId)))
		(!(PRINT "Action stopped"))
		(=> (ExecutionManager.report (VAL @executionId) STOPPED))
		)

	
	)


)
(defop |closeGripper|
  :invocation(ExecutionManager.execute closeGripper @gripper @executionId)
  :body (
	 (=>(ExecutionManager.isExecuting @executionId))
	 (!(ArmActions.getFreeId @id))
	 (=>(ArmActions.action closeGripper @gripper @id))
	 (!(ExecutionManager.handleReport ArmActions @id @executionId FALSE FALSE NO_NAME))
	 (~>(ExecutionManager.isExecuting @executionId))
	 (=>(ExecutionManager.report (VAL @executionId) OK))
	 )
  )

(defop |openGripper|
  :invocation(ExecutionManager.execute openGripper @gripper @executionId)
  :body (
	 (=>(ExecutionManager.isExecuting @executionId))
	 (!(ArmActions.getFreeId @id))
	 (=>(ArmActions.action openGripper @gripper @id))
	 (!(ExecutionManager.handleReport ArmActions @id @executionId FALSE FALSE NO_NAME))
	 (~>(ExecutionManager.isExecuting @executionId))
	 (=>(ExecutionManager.report (VAL @executionId) OK))
	 )
)

(defop |goToPose|
  :invocation(ExecutionManager.execute moveToPose @pose @arm @q0 @executionId)
  :body (
	 (=>(ExecutionManager.isExecuting @executionId))
	 (!(ArmActions.getFreeId @id))
	 (=>(ArmActions.action moveToPose @pose @arm @q0 @id))
	 (!(ExecutionManager.handleReport ArmActions @id @executionId TRUE TRUE NO_NAME))
	 (~>(ExecutionManager.isExecuting @executionId))
	 (=>(ExecutionManager.report (VAL @executionId) OK))
	 )
  )
(defop |go| 
  :invocation (ExecutionManager.execute go @goal @subgoal @executionId)
  :documentation "Operation to make the robot reach a destination. @goal is the node in the map the should be reached, @subgoal the item"
  :body (
	 (!(SEM-P ExecutionManager.sem))
	 
	 ;;get list of nodes in semantic map
	 (?(Robot.location @source))
	 (!(PathPlanner.getFreeId @pathPlannerId))
	 (=>(PathPlanner.plan @source @goal))
	 (!(ExecutionManager.handleReport PathPlanner @pathPlannerId @executionId TRUE TRUE NO_NAME))
	 (?(PathPlanner.result @pathPlannerId @path))
	 ;;get coordinates in these nodes
	 (!(PathPlanner.getCoordinates @path @waypoints))
 
	 ;;move to place
	 (=>(BaseActions.action move @waypoints))
	 (!(ExecutionManager.handleReport BaseActions @baseActionsId @executionId TRUE TRUE NO_NAME))
	 
	 (!(SEM-V ExecutionManager.sem))
	 )
  )
(defop |approach|
  :invocation(ExecutionManager.execute approach @support @object @executionId)
  :documentation "Approaches a furniture to be able to pick an object. If @object NO_NAME will approach from a random side. Otherwise, if the robot knows the position of the object, it will go on the correct side."
  :body (
	 )
  )

(defop |relocate|
  :invocation(ExecutionManager.execute relocate @support @object @executionId)
  :documentation "Reposition the robot to go around a furniture in order to reach an object)"
  :body (
	 )
  )

)
