;; -*-Lisp-*-
;;author: Michelangelo Fiore
;;this module contains high-level actions like take an item, give, drop.
(

 (defop |init|
   :invocation(!(ExecutionManager.init))
   :documentation "Inits the module"
   :body (
	  (=>(ExecutionManager.freeId 0))
	  (!(SEM-CREATE ExecutionManager.sem 1 SEM-FIFO))
	  )
   
   )
 
 (defop |getFreeId|
   :invocation(!(ExecutionManager.getFreeId $id))
   :documentation "Returns an id to use in executions"
   :body (
	  (!(SEM-P ExecutionManager.sem))
	  (?(ExecutionManager.freeId $id))
	  (=>(ExecutionManager.freeId (+ $id 1)))
	  (!(SEM-V ExecutionManager.sem))
	 
	 )
   )


(defop |executeAction|
  :invocation(ExecutionManager.executeAction @actionName @actionParameters @executionId)
  :documentation "Launching point to allow other modules to launch actions in a generic way"
  :body (
	 (?(Action.type (VAL @actionName) @type))
	 (IF(?(EQUAL @type MANIPULATION))
	    (!(== (VAL @actionParameters) (. @object .)))
	 
	    ELSEIF(?(EQUAL @type HANDOVER))
	    (!(== (VAL @actionParameters) (. @object @agent1 @agent2 .)))

	    ELSEIF(?(EQUAL @type PLACEMENT))
	    (!(== (VAL @actionParameters) (. @object @placement .)))

	    )
	 (IF(?(EQUAL @actionName take))
	    (=>(ExecutionManager.execute take @object NO_NAME @executionId))
	    
	    ELSEIF(?(EQUAL @actionName throw))
	    (=>(ExecutionManager.execute throw @object @placement @executionId))

	    ELSEIF(?(EQUAL @actionName place))
	    (=>(ExecutionManager.execute place @object @placement @executionId))
	    
	    ELSEIF(?(EQUAL @actionName handover))
	    (IF(?(EQUAL @agent2 PR2_ROBOT))
	       (=>(ExecutionManager.execute handover GRAB @object @agent1 @executionId)) 
		 ELSE 
		 (=>(ExecutionManager.execute handover GIVE @object @agent2 @executionId))
		 )
	    ELSEIF(?(EQUAL @actionName undefined))
	    (=>(ExecutionManager.report (VAL @executionId) OK))
	    
	    )

	 
	 )
  )

(defop |chooseArmForTake|
  :invocation(!(ExecutionManager.chooseArmForTake @object @executionId $armForTake))
  :documentation "Utility procedure to choose an arm for grasping. Returns the arm for the take action"
  :body (
	 (?(Spark.robotName @robotName)) 
	 (?(Spark.robotTorso @torso))
	 
					;If the robot has only one free arm try the take action with that arm. 
	 (IF(?(& (Robot.hasObject RIGHT @anyObject) (~(Robot.hasObject LEFT @anyObject2))))
	    (!(= $armForTake LEFT))
	     
	    ELSEIF(?(&(~(Robot.hasObject RIGHT @anyObject)) (Robot.hasObject LEFT @anyObject2)))
	    (!(= $armForTake RIGHT))
	     
	     ELSE
					;otherwise calculate which is the best arm to use based on the object position relative to the robot
	     
	     
	     (!(Spark.getFreeId @sparkId))
	     (=>(Spark.request getJointAbsPose (VAL @object) "NO_NAME" (VAL @sparkId))) 
	     (^(Spark.report (VAL @sparkId) @sparkReport))
	     (IF(?(~(EQUAL @sparkReport "OK")))
		(=> (ExecutionManager.report (VAL @executionId) (VAL @sparkReport)))
		(!(SEM-V ExecutionManager.sem))
		(!(FAILED))
		)
	     (^(Spark.result (VAL @sparkId) @xOb @yOb @zOb @yawOb @pitchOb @rollOb))
	     (~>(Spark.result (VAL @sparkId) @xOb @yOb @zOb @yawOb @pitchOb @rollOb))
	     (~>(Spark.report (VAL @sparkId) @sparkReport))
	     
	     (!(Spark.getFreeId @sparkId))
	     (=>(Spark.request getJointAbsPose (VAL @robotName ) (VAL @torso) (VAL @sparkId))) 
	     (^(Spark.report (VAL @sparkId) @sparkReport))
	     (IF(?(~(EQUAL @sparkReport "OK")))
		(=> (ExecutionManager.report (VAL @executionId) (VAL @sparkReport)))
		(!(SEM-V ExecutionManager.sem))
		(!(FAILED))
		)
	     (^(Spark.result (VAL @sparkId) @xTorso @yTorso @zTorso @yawTorso @pitchTorso @rollTorso))
	     (~>(Spark.result (VAL @sparkId) @xTorso @yTorso @zTorso @yawTorso @pitchTorso @rollTorso))
	     (~>(Spark.report (VAL @sparkId) @sparkReport))
	      
	     (IF(?(> @yOb @yTorso))
		(!(= $armForTake LEFT))
		
		ELSE
		(!(= $armForTake RIGHT))
		)
	     )
	  
	  )
  )

 (defop |handleReport|
   :invocation(!(ExecutionManager.handleReport @reportName @id @executionId))
   :documentation "Utility function to avoid some code duplication when waiting for the response of a genom module. This can't be used when we don't want to fail if the genom request fails"
   :body (
	  (^(|| (@reportName (VAL @id) @report)  (ExecutionManager.stop (VAL @executionId))))
	  
	  (IF(?(ExecutionManager.stop (VAL @executionId)))
	     (~>(ExecutionManager.stop (VAL @executionId)))
	     (=>(ExecutionManager.report (VAL @executionId) STOPPED))

	     ELSE	 
	     (~>( @reportName (VAL @id) (VAL @report)))
	     (IF(?(~(EQUAL @report "OK")))
		(!(PRINT @report))
		(=> (ExecutionManager.report (VAL @executionId) FAILURE))
		(!(SEM-V ExecutionManager.sem))
		(!(FAILED))
		)
	     )
	  )
   
   )

 (defop |take|
   :invocation(ExecutionManager.execute take @object @arm @executionId)
   :documentation "this procedure takes the object @object. @arm can be setted to one of the two arms (RIGHT or LEFT) or to NO_NAME. In that case the robot chooses the arm to compute the action"
   :body (	  
	  (!(SEM-P ExecutionManager.sem))
	  ;;find the support where the object is placed
	  (!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT (VAL @object) isOn @support) (. @support .) @result))
	  (IF(?(EQUAL @result ERROR))
	     (=>(ExecutionManager.report (VAL @executionId) FAILURE))
	     (!(SEM-V ExecutionManager.sem))
	     (!(FAILED))
	     )
	  (!(= @support (CAR @result)))
	  (!(= @support (CAR @support)))
	  
	  ;;check if the action has already been realized
	  (IF(?(~(EQUAL @arm NO_NAME)))
	     (IF(?(Robot.hasObject (VAL @arm) (VAL @object)))
		(=>(ExecutionManager.report (VAL @executionId) OK))
		(!(SEM-V ExecutionManager.sem))
		(!(FAILED))
		
		)
	     ELSEIF(?(Robot.hasObject @anyArm (VAL @object)))
	     (=>(ExecutionManager.report (VAL @executionId) OK))
	     (!(SEM-V ExecutionManager.sem))
	     (!(FAILED))
	     )
	  
	  ;;check if the robot has both hands full (or one hand if @arm was specified)
	  (IF(?(~(EQUAL @arm NO_NAME)))
	     (IF(?(Robot.hasObject (VAL @arm) @anyObject))
		(=>(ExecutionManager.report (VAL @executionId) FAILURE))
		(!(SEM-V ExecutionManager.sem))
		(!(FAILED))
		)
	     ELSEIF(?(|| (Robot.hasObject RIGHT  @anyObject) (Robot.hasObject LEFT  @anyObject)))
	     (=>(ExecutionManager.report (VAL @executionId) FAILURE))
	     (!(SEM-V ExecutionManager.sem))
	     (!(FAILED))
	     )

	  ;;set the parameters for the monitor manager
	   (!(= @failureConditions (. (. (ExecutionManager.report (VAL @executionId) FAILURE) .)  (. .) .) )) 	 ; item not there 
	  (!(= @successConditions (. (. (ExecutionManager.report (VAL @executionId) OK) .)  (. .) .) ))     ; look at the item until execution is completed
	  

	  (!(MonitorManager.getFreeId @monitorId))

	  
	  ;;start the monitoring
	  (!(MonitorManager.monitorTarget @object "NO_NAME" @successConditions @failureConditions HIGH @monitorId))
	  
	  (WHILE(?(~(MonitorManager.isMonitoringTarget (VAL @monitorId)))) ;until the monitor starts
		(^(|| (MonitorManager.isMonitoringTarget (VAL @monitorId)) (MonitorManager.report (VAL @monitorId) @monitorReport ))) ;wait until the monitoring starts or it returns a value (which would be an error, a cancel or a stopped status since it can't succed before execution starts.
		
		(IF(?(MonitorManager.report (VAL @monitorId) @report)) ;;there's an error (like object not present) or the monitoring has being stopped or canceled
		   (~>(MonitorManager.report (VAL @monitorId) @report))
		   (IF(?(EQUAL @report STOPPED))
		      (=>(ExecutionManager.report (VAL @executionId) STOPPED)) ;pause the execution and go back to the loop
		      ELSEIF(?(EQUAL @report CANCELED))
		      (=> (ExecutionManager.report (VAL @executionId) FAILURE))  ;we fail
		      (!(SEM-V ExecutionManager.sem))
		      (!(FAILED))
		      
		      ELSE  ;unhandled report
		      (=> (ExecutionManager.report (VAL @executionId) @report)) 
		      (!(SEM-V ExecutionManager.sem))
		      (!(FAILED))
		      )
		   )	
		)
	  ;;everything is good. Monitoring has started. We can choose an arm for take if needed
 
	  (IF(?(EQUAL @arm NO_NAME)) 
	     (!(ExecutionManager.chooseArmForTake @object @executionId @armForPick))
	    
	     ELSE
	     (!(= @armForPick @arm))
	     )


					;open gripper if needed
	  (IF(?(Robot.gripper (VAL @armForPick) CLOSE))
	     (!(ArmActions.getFreeId @actionId))
	     (=>(ArmActions.action openGripper @armForPick @actionId))
	     (!(ExecutionManager.handleReport ArmActions.report @actionId @executionId))
	     )
	  
	  ;;plan and execute the trajectory
	  (!(ArmActions.getFreeId @actionId))
	  (=>(ArmActions.action moveToObject @armForPick @object @actionId))

	  (!(ExecutionManager.handleReport ArmActions.report @actionId @executionId))

	  

					;close the gripper
	  (!(ArmActions.getFreeId @actionId))
	  (=>(ArmActions.action closeGripper @armForPick @actionId))
	  (!(ExecutionManager.handleReport ArmActions.report @actionId @executionId))
	  
					;updates knowledge of the robot


	  (=> (Robot.hasObject (VAL @armForPick) (VAL @object))) ;if we arrive here with no FAILED than we've got the item (hopefully XD)

	  (=>(ExecutionManager.report (VAL @executionId) OK))
	  (~>(ExecutionManager.isExecutingAction (VAL @executionId)))

	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request setObjectInHand PR2_ROBOT (VAL @object) (VAL @armForPick) TRUE (VAL @sparkId)))
	  (!(ExecutionManager.handleReport Spark.report @sparkId @executionId))
	  

	  (!(SEM-V ExecutionManager.sem))
	  )
   
   )



 (defop |getHumanObservations|
   :invocation(!(ExecutionManager.getHumanObservations @agent @executionId $armPosition $distance $orientation))
   :documentation "utility procedure that calculates the observations for the POMDP. SHOULD GO TO ANOTHER FILE"
   :body (
	  (?(Spark.robotName @sparkRobotName))
	  (?(Spark.humanWrist @hWrist))
	  (?(Spark.humanHip @hHip))

	  (?(ExecutionManager.oldArmPosition @oldArmPosition))
	  (?(ExecutionManager.oldDistance @oldDistance))

	 (?(Robot.position TORSO @robotTorsoX @robotTorsoY @robotTorsoZ @robotTorsoYaw @robotTorsoPitch @robotTorsoRoll))	 
	  ;;get the human right hip position
	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request getJointAbsPose (VAL @agent) (VAL @hHip) (VAL @sparkId)))
	  (^(Spark.report (VAL @sparkId) @report))

	  (~>(Spark.report (VAL @sparkId) (VAL @report)))

	  (IF(?(~(EQUAL @report "OK")))   ;;the human is not in sight
	     (!(= $distance outOfRange))
	     (!(= $armPosition unknown))
	     (!(= $orientation unknown))
	     (=>(ExecutionManager.oldDistance outOfRange))
	     (=>(ExecutionManager.oldArmPosition uknown))
	     (=>(ExecutionManager.oldOrientation unknown))
	     
	     ELSE   ;human in sight
	     
	     (^(Spark.result (VAL @sparkId) @humanHipX @humanHipY @humanHipZ @humanHipYaw @humanHipPitch @humanHipRoll))
	     (~>(Spark.result (VAL @sparkId) (VAL @humanHipX) (VAL @humanHipY) (VAL @humanHipZ) (VAL @humanHipYaw) (VAL @humanHipPitch) (VAL @humanHipRoll)))
					;get the human wrist position
	     (!(Spark.getFreeId @sparkId))
	     (=>(Spark.request getJointAbsPose (VAL @agent) (VAL @hWrist) (VAL @sparkId)))
	     (!(ExecutionManager.handleReport Spark.report @sparkId @executionId))
	     (^(Spark.result (VAL @sparkId) @humanWristX @humanWristY @humanWristZ @humanWristYaw @humanWristPitch @humanWristRoll))
	     (~>(Spark.result (VAL @sparkId) (VAL @humanWristX) (VAL @humanWristY) (VAL @humanWristZ) (VAL @humanWristYaw) (VAL @humanWristPitch) (VAL @humanWristRoll)))
	     
	     
					;calculate distance between robot and human. The distance is squared because oprs as no SQRT operator and i'm too lazy to implement it at the moment.
	     (!(= @xDiff (- @humanHipX @robotTorsoX)))
	     (!(= @xDiffSquare (* @xDiff @xDiff)))
	     (!(= @yDiff (- @humanHipY @robotTorsoY)))
	     (!(= @YDiffSquare (* @yDiff @yDiff)))
	     (!(= @zDiff (- @humanHipZ @robotTorsoZ)))
	     (!(= @zDiffSquare (* @zDiff @zDiff)))	   
	     (!(= @squareDistance (+ @xDiffSquare @YDiffSquare @zDiffSquare)))
	     

	     
	     (IF(?(> @squareDistance 50))
		(!(= $distance outOfRange))
		(!(= $armPosition unknown))
		(!(= $orientation unknown))
		(=>(ExecutionManager.oldDistance outOfRange))
		(=>(ExecutionManager.oldArmPosition uknown))
		(=>(ExecutionManager.oldOrientation unknown))
		
		
		ELSE
		(IF(?(EQUAL @oldDistance outOfRange))
		   (!(= $distance closer))
		   ELSEIF(?(< @squareDistance (- @oldDistance 0.5)))
		   (!(= $distance closer))
		   ELSEIF(?(> @squareDistance (+ @oldDistance 0.5)))
		   (!(= $distance farther))
		   ELSE
		   (!(= $distance still))
		   )

		(=>(ExecutionManager.oldDistance @squareDistance))
		
		(IF(?(EQUAL @oldOrientation unknown))
		   (!(= $orientation towardRobot))
		   
		   ELSE
		   (!(= $orientation still))
		   )
		(=>(ExecutionManager.oldOrientation (VAL $orientation)))
					;calculate distance between human hand and wrist. The distance is squared because oprs as no SQRT operator and i'm too lazy to implement it at the moment.
		(!(= @xDiff (- @humanHipX @humanWristX)))
		(!(= @xDiffSquare (* @xDiff @xDiff)))
		(!(= @yDiff (-  @humanHipY @humanWristY)))
		(!(= @YDiffSquare (* @yDiff @yDiff)))
		(!(= @zDiff (-  @humanHipZ @humanWristZ)))
		(!(= @zDiffSquare (* @zDiff @zDiff)))	   
		(!(= @squareDistance (+ @xDiffSquare @YDiffSquare @zDiffSquare)))
		

		(IF(?(EQUAL @oldArmPosition unknown))
		   (!(= $armPosition closer))
		   ELSEIF(?(> @squareDistance (+ @oldArmPosition 0.05)))
		   (!(= $armPosition closer))
		   ELSEIF(?(< @squareDistance (- @oldArmPosition 0.05)))
		   (!(= $armPosition farther))
		   ELSE
		   (!(= $armPosition still))
		   )  

		(=>(ExecutionManager.oldArmPosition @squareDistance))
		)
					;	    (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @sparkRobotName) (VAL @sparkAgent) armPosition @armPosition) (. @armPosition .) @result))
					;	    (IF(?(~(EQUAL @result ERROR)))
					;	       (!(= @result (CAR @result)))
					;	       (!(= $armPosition (CAR @result)))
					;	       )

					;	    (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @sparkRobotName) (VAL @sparkAgent) orientation @orientation) (. @orientation .) @result))
					;	    (IF(?(~(EQUAL @result ERROR)))
					;	       (!(= @result (CAR @result)))
					;	       (!(= $orientation (CAR @result)))
					;	       )
	     
	     )
	  
	  
	  )
   )


(defop |getQForHuman|
  :invocation (!(ExecutionManager.getQForHuman @arm @agent $finalQ0))
  :documentation "calculates a q0 value so that the arm is oriented toward the agent. This procedure at the moment is implemented only for the right arm. NEEDS TO BEUPDATED"
  :body (
	 (?(Spark.robotName @sparkRobotName))
	 (?(Spark.humanTorso @hTorso))
	 (?(Robot.position TORSO @robotTorsoX @robotTorsoY @robotTorsoZ @robotTorsoYaw @robotTorsoPitch @robotTorsoRoll))
	 ;;get the human position
	 (!(Spark.getFreeId @sparkId))
	 (=>(Spark.request getJointAbsPose (VAL @agent) (VAL @hTorso) (VAL @sparkId)))
	 (^(Spark.report (VAL @sparkId) @report))
	 
	 (~>(Spark.report (VAL @sparkId) (VAL @report)))
	 
	 (^(Spark.result (VAL @sparkId) @humanTorsoX @humanTorsoY @humanTorsoZ @humanTorsoYaw @humanTorsoPitch @humanTorsoRoll))
	 (~>(Spark.result (VAL @sparkId) (VAL @humanTorsoX) (VAL @humanTorsoY) (VAL @humanTorsoZ) (VAL @humanTorsoYaw) (VAL @humanTorsoPitch) (VAL @humanTorsoRoll)))
	 (!(= @q0 0.4))
	 (!(= @difference (- @robotTorsoX @humanTorsoX)))
	 (!(= @q0 (- @q0 @difference)))

	 (IF(?(> @q0 0.7))
	    (!(= @q0 0.7))
	    ELSEIF(?(< @q0 -0.7))
	    (!(= @q0 0.7))
	    )
	 (!(= $finalQ0 (VAL @q0)))
	 
	 )
  
  )

(defop |give|
  :invocation(ExecutionManager.execute handover @type @object @agent @executionId)
  :documentation "this procedure gives the object @object to the agent @agent. If the robot doesn't have the @item it fails"
  :body (
	 (!(SEM-P ExecutionManager.sem))
	 (!(= @observationWaitTime 0)) ;time to wait to get new observations
	 (!(= @maxEngage 3))           ;number of times the robot will try to re-engage the user before understanding he's not interested
	 (!(= @nEngage 0))             ;number of times the robot has engaged the user
	 (!(= @waitTime 20))          ;time to wait before engaging the user
	 
	 (?(Spark.robotTorso @rTorso))
	 (?(Spark.humanHead @humanHead))

	 (!(= @monitorSuccessConditions (. (. (ExecutionManager.report (VAL @executionId) OK) .) (. .) .)))
	 (!(= @monitorFailureConditions  (. (.(ExecutionManager.report (VAL @executionId) FAILURE) .) (. .) .)))


	 (IF(?(EQUAL @type GIVE))
	    (IF(?(Robot.hasObject @arm  (VAL @object)))  ;if the robot doesn't have the object fail
	       ELSE 
	       (=>(ExecutionManager.report (VAL @executionId) FAILURE))
	       (!(SEM-V ExecutionManager.sem))
	       (!(FAILED))
	       )
	      
	    ELSEIF(?(EQUAL @type GRAB)) ;select an arm for the grab or fail if there are free arms
	    (IF(?(Robot.hasObject RIGHT  @anyObject))
	       (IF(?(Robot.hasObject LEFT  @anyObject))
		  (!(SEM-V ExecutionManager.sem))
		  (!(FAILED))
		  
		  ELSE
		  (!(= @arm LEFT))
		  (!(ArmActions.getFreeId @actionId))
		  (=>(ArmActions.action openGripper @arm @actionId))
		  (!(ExecutionManager.handleReport ArmActions.report @actionId @executionId))
		  )
		    
	       ELSE
	       (!(= @arm RIGHT))
	       (!(ArmActions.getFreeId @actionId))
	       (=>(ArmActions.action openGripper @arm @actionId))
	       (!(ExecutionManager.handleReport ArmActions.report @actionId @executionId))
	       )
	    )
	 
	 
	 (?(Spark.robotName @sparkRobotName))
	
	 ;;get the robot torso position (to compute distance from the user)
	 (?(Spark.freeId @sparkId))
	 (=>(Spark.request getJointAbsPose (VAL @sparkRobotName) (VAL @rTorso) (VAL @sparkId)))
	 (!(ExecutionManager.handleReport Spark.report @sparkId @executionId))
	 (?(Spark.result (VAL @sparkId) @robotTorsoX @robotTorsoY @robotTorsoZ @robotTorsoYaw @robotTorsoPitch @robotTorsoRoll))
	 (~>(Spark.result (VAL @sparkId) (VAL @robotTorsoX) (VAL @robotTorsoY) (VAL @robotTorsoZ) (VAL @robotTorsoYaw) (VAL @robotTorsoPitch) (VAL @robotTorsoRoll)))

	 (=>(Robot.position TORSO @robotTorsoX @robotTorsoY @robotTorsoZ @robotTorsoYaw @robotTorsoPitch @robotTorsoRoll))
	 
	 ;move to rest position
	 (!(ArmActions.getFreeId @actionId))
	 (=>(ArmActions.action moveToRestPosition (VAL @arm) (VAL @actionId)))
	 (!(ExecutionManager.handleReport ArmActions.report @actionId @executionId))
	

	 ;;Set the starting variables. We only compute observations to set inRange at the start.
	 (!(ExecutionManager.getHumanObservations @agent  @executionId @armPosition @distance @orientation))
	 (IF(?(EQUAL @distance outOfRange))
	    (!(= @inRange false))
	    (!(= @q0 0))  ;set the starting q0. This manouvres the robot arm horizontal position so that it can follow the human when it moves.
	    ELSE
	    (!(= @inRange true))
	    (!(ExecutionManager.getQForHuman @arm @agent @q0))
	    (IF(?(EQUAL @type GIVE))
	       (!(Acapela.say "I'm ready to give you the item"))
	       
	       ELSEIF(?(EQUAL @type GRAB))
	       (!(Acapela.say "Could you give me the item?"))
	       )
	    (!(MonitorManager.getFreeId @monitorId))
	    (!(MonitorManager.monitorTarget @agent @humanHead @monitorSuccessConditions @monitorFailureConditions HIGH @monitorId)) 

	    )
	 
	 (!(= @task notCompleted))  
	 (!(= @time ok))
	 (!(= @xState (TERM-STRING-CAT @inRange @task @time)))
	 
	 ;;init the POMDP
	 (!(POMDP.init Handover @xState @action @yState))
	 (!(= @robotState armRest))  ;;possible states are armRest armReady and armExtended
	 
	 (WHILE(?(& (~(ExecutionManager.stop (VAL @executionId))) (~(ExecutionManager.report (VAL @executionId) @anyReport)) (~(EQUAL @action ABANDON)))) ;loop until we are stopped, we get a report (means we fail basically) or we abandon the task
	       
	       ;;we extend the arm if:
	       ;;the arm is not extended and:
	       ;;-we get a continue action
	       ;;we get a wait action and the user is engaged.
	       
	       (IF(?(& (~(EQUAL @robotState armExtended)) (|| (EQUAL @action CONTINUE) (& (EQUAL @action WAIT) (EQUAL @yState engaged)))))  ;if user is engaged and arm is not extended extend it
		  (IF(?(EQUAL @task waitingGrasp)) ;if we are waiting for grasp we close the gripper, move and then relaunch release to avoid it opening because of the arm moving.
		     (!(ArmActions.getFreeId @detectPressionId))
		     (=>(ArmActions.action stopDetectPression @arm @type @detectPressionId))
		     (!(ExecutionManager.handleReport ArmActions.report @detectPressionId @executionId))
		     )

		  (!(ArmActions.getFreeId @armPositionId))
		  (=>(ArmActions.action moveToExtendedPosition @arm @q0 @actionId))
		  (!(ExecutionManager.handleReport ArmActions.report @actionId @executionId))
		       
		  (!(ArmActions.getFreeId @detectPressionId))
		  (=>(ArmActions.action detectPression @arm @type @detectPressionId))

		    		  
		  (!(= @task waitingGrasp))
		  (!(= @robotState armExtended))
		  
		  
		  ;;we put the arm to ready if:
		  ;;the arm is not ready and:
		  ;;the user is not engaged and in range
		  ;;we get a WAIT or ENGAGE command
		  ;;task state is not modified here
		  ELSEIF(?(&(~(EQUAL @robotState armReady)) (EQUAL @yState notEngaged) (EQUAL @inRange true) (|| (EQUAL @action WAIT) (EQUAL @action ENGAGE))))
		  (^(Robot.isMovingArm (VAL @arm) FALSE))
		  (IF(?(EQUAL @task waitingGrasp))
		     (!(ArmActions.getFreeId @detectPressionId))
		     (=>(ArmActions.action stopDetectPression @arm @type @detectPressionId))
		     (!(ExecutionManager.handleReport ArmActions.report @detectPressionId @executionId))
		     )
		  (!(ArmActions.getFreeId @actionId))
		  (=>(ArmActions.action moveToReadyPosition (VAL @arm) @q0 @actionId))
		  (=>(ExecutionManager.handleReport ArmActions.report @actionId @executionId))
		  
		  (!(ArmActions.getFreeId @detectPressionId))
		  (=>(ArmActions.action detectPression @arm @type @detectPressionId))


		  (!(= @robotState armReady))
		  (!(= @task waitingGrasp))
		
		  ;;we go to rest state if
		  ;;we receive a wait command and the user is out of range and the the robot is not in restState
		  ELSEIF(?(& (~(EQUAL @robotState armRest)) (EQUAL @inRange false) (EQUAL @action WAIT)))
		  (^(Robot.isMovingArm (VAL @arm) FALSE))
		  (IF(?(EQUAL @task waitingGrasp))
		     (!(ArmActions.getFreeId @detectPressionId))
		     (=>(ArmActions.action stopDetectPression @arm @type @detectPressionId))
		     (!(ExecutionManager.handleReport ArmActions.report @detectPressionId @executionId))
		     )
		  
		  (!(ArmActions.getFreeId @actionId))
		  (=>(ArmActions.action moveToRestPosition @arm @actionId))
		  (!(= @robotState armRest))
		  (!(= @task notCompleted))
		  )
	       
	       
	       (IF(?(EQUAL @action WAIT)) ;if the action is wait we start the timer (if it's not started already)
		  (IF(?(~(Timer.isRunning (VAL @timerId))))
		     (!(Timer.getFreeId @timerId))                  ;start a timer to edit the state variable time. 
		     (=>(Timer.start @waitTime @timerId))
		     )
		  
		  ELSEIF(?(EQUAL @action ENGAGE))   ;if the action is engage we stop the timer (if started) and talk to the user
		  (IF(?(Timer.isRunning (VAL @timerId)))
		     (=>(Timer.stopTimer (VAL @timerId)))
		     )
		  (IF(?(Timer.elapsedTime (VAL @timerId)))
		     (~>(Timer.elapsedTime (VAL @timerId)))
		     )
		  (!(= @time ok))
		  (IF(?(EQUAL @type GIVE))
		     (!(Acapela.say "I'm ready to give you the item. Are you still interested?"))
		  
		     ELSEIF(?(EQUAL @type GRAB))
		     (!(Acapela.say "I'm ready to take the item. Could you please give it to me?"))
		     )
		  )
	       ;;WAIT before getting the new observations
	       (^(ELAPSED-TIME (TIME) @observationWaitTime))
	       (!(ExecutionManager.getHumanObservations @agent @executionId @armPosition @distance @orientation))
	       
	       
	       (IF(?(EQUAL @distance outOfRange))
		  (!(= @inRange false))
		  (!(= @q0 0))
		  ELSE
		  (!(= @inRange true))
		  (!(ExecutionManager.getQForHuman @arm @agent @qo))
		  )
	       
	       ;;if the user is out of range and the monitor has not failed stop the monitor. If the user is in range and we are not monitoring it start the monitor.
	       
	       (IF(?(EQUAL @inRange true))
		  (IF(?(~(MonitorManager.isMonitoringTarget (VAL @monitorId))))
		     (!(MonitorManager.getFreeId @monitorId))
		     (!(MonitorManager.monitorTarget @agent @humanHead @monitorSuccessConditions @monitorFailureConditions HIGH @monitorId)) 
		     )
		  ELSE
		  (IF(?(MonitorManager.isMonitoringTarget (VAL @monitorId)))
		     (IF(?(~(MonitorManager.report (VAL @monitorId) @report)))
			(=>(MonitorManager.cancelMonitoring (VAL @monitorId)))
			(^(MonitorManager.report (VAL @monitorId) @report))
			(~>(MonitorManager.report (VAL @monitorId) @report))
			ELSE
			(~>(MonitorManager.report (VAL @monitorId) @report))
			)
		     )
		  )
	       (IF(?(EQUAL @task waitingGrasp)) ;if we are waiting a grasp and detecting pressure we open or close the gripper depending on the kind of handover
		  (IF(?(Robot.gripper (VAL @arm) DETECTED_PRESSION))
		     (~>(Robot.gripper (VAL @arm) DETECTED_PRESSION))
		     (~>(ArmActions.report @detectPressionId @report))
		     
		     (IF(?(EQUAL @type GIVE))
			(!(ArmActions.getFreeId @actionId))
			(=>(ArmActions.action openGripper @arm @actionId))
			(!(ExecutionManager.handleReport ArmActions.report @actionId @executionId))
					     	     
			ELSEIF(?(EQUAL @type GRAB))
			(!(ArmActions.getFreeId @actionId))
			(=>(ArmActions.action closeGripper @arm @actionId))
			(!(ExecutionManager.handleReport ArmActions.report @actionId @executionId))
			)
		     (!(= @task completed))
		     (IF(?(EQUAL @type GIVE))
			(~>(Robot.hasObject (VAL @arm) (VAL @object)))
			
			(!(Spark.getFreeId @sparkId))
			(=>(Spark.request placeObjectForSimu (VAL @object) 0 0 0 0 0 0 1 @sparkId)) 
			(!(ExecutionManager.handleReport Spark.report @sparkId @executionId))
	       
			(!(Spark.getFreeId @sparkId))
			(=>(Spark.request setObjectInHand (VAL @sparkRobotName) (VAL @object) (VAL @arm) FALSE (VAL @sparkId)))
			(!(ExecutionManager.handleReport Spark.report @sparkId @executionId))

			(!(Spark.getFreeId @sparkId))
			(=>(Spark.request setObjectInHand (VAL @agent) (VAL @object) (VAL @arm) TRUE (VAL @sparkId)))
			(!(ExecutionManager.handleReport Spark.report @sparkId @executionId))

			(=>(Agent.hasObject (VAL @agent) (VAL @object)))
			
			ELSEIF(?(EQUAL @type GRAB))
					;	       (=>(Robot.hasObject (VAL @arm)  (VAL @object)))  ;explanation in the next comment
			(=>(Robot.hasObjectForThrow (VAL @arm) (VAL @object)))
			(!(Spark.getFreeId @sparkId))
			(=>(Spark.request placeObjectForSimu (VAL @object) 0 0 0 0 0 0 1 @sparkId)) 
			(!(ExecutionManager.handleReport Spark.report @sparkId @executionId))

			(!(Spark.getFreeId @sparkId))
			(=>(Spark.request setObjectInHand (VAL @agent) (VAL @object) (VAL @arm) FALSE (VAL @sparkId)))
			(!(ExecutionManager.handleReport Spark.report @sparkId @executionId))

			(~>(Agent.hasObject (VAL @agent) (VAL @object)))
			;;At this point we should put an inference to tell spark that the robot has an object. The problem is that with handover the robot usually doesn't see the object so it would be attached in the wrong
			;;position. At the moment we just act like if the robot doesn't have the object.
			;; (?(Spark.robotFinger (VAL @arm) @sparkRobotFinger))                

			;; (!(HeadActions.getFreeId @headId))
			;; (=>(HeadActions.action lookAt @sparkRobotName @sparkRobotFinger @headId))
			;; (!(ExecutionManager.handleReport HeadActions.report @headId @executionId))

			;; (!(Spark.getFreeId @sparkId))
			;; (=>(Spark.request setObjectInHand @sparkRobotName (VAL @object) (VAL @arm) TRUE (VAL @sparkId)))
			;; (!(ExecutionManager.handleReport Spark.report @sparkId @executionId))
			
			
			)
		     )
		  )
	       (IF(?(&(Timer.elapsedTime (VAL @timerId)) (~(EQUAL @task completed))))  ;check the timer
		  (!(= @time expired))
		  (~>(Timer.elapsedTime (VAL @timer)))
		  
		  ELSE
		  (!(= @time ok))
		  )
	 
	       ;;update the opmdp
	       (!(= @xState (TERM-STRING-CAT @inRange @task @time)))                       
	       (!(= @obs (TERM-STRING-CAT @armPosition @distance @orientation)))
	       
	       (!(POMDP.update Handover @obs @xState @action @yState))
	       
	       )
	 
	 ;task is over. We go to rest state
	 (IF(?(~(EQUAL @robotState armRest)))  
	    (^(ELAPSED-TIME (TIME) 2)) ;wait some seconds before leaving
	    (!(ArmActions.getFreeId @actionId))
	    (=>(ArmActions.action moveToRestPosition @arm @actionId))
	    (!(ExecutionManager.handleReport ArmActions.report @actionId @executionId))
	    )


	 (IF(?(EQUAL @task completed))
	    (!(Acapela.say "Good! Thank you!"))
	    
	    (=>(ExecutionManager.report @executionId OK))
	   
	    (IF(?(Robot.gripper (VAL @arm) DETECTING_PRESSION))
	       (!(ArmActions.getFreeId @detectPressionId))
	       (=>(ArmActions.action stopDetectPression @arm @type @detectPressionId))
	       (!(ExecutionManager.handleReport ArmActions.report @detectPressionId @executionId))
	       )
	    ELSE
	    (=>(ExecutionManager.report @executionId FAILURE))
	    (!(Acapela.say "Well... too bad. Have a nice day."))
	    )
	 ;;stop any remaining monitor (should not be there actually but still...)
	 (IF(?(MonitorManager.target @any1 (VAL @monitorId) @any2))
	    (^(MonitorManager.report (VAL @monitorId) @report))
	    (~>(MonitorManager.report (VAL @monitorId) @report))
	    
	    ELSEIF(?(MonitorManager.report (VAL @monitorId) @report))
	    (~>(MonitorManager.report (VAL @monitorId) @report))
	    )
	 (IF(?(Timer.isRunning (VAL @timerId)))
	    (=>(Timer.stopTimer @timerId))
	    )
	 (IF(?(Timer.elapsedTime (VAL @timerId)))
	    (~>(ExecutionManager.elapsedTime (VAL @timerId)))
	    )
	 (!(SEM-V ExecutionManager.sem))
	 )
  )




 (defop |throw|
   :invocation(ExecutionManager.execute throw @object @placement @executionId)
   :documentation "throw an object to a certain placement"
   :body (
	  (!(SEM-P ExecutionManager.sem))
	  (IF(?(&(~(Robot.hasObject @arm (VAL @object))) (~(Robot.hasObjectForThrow @arm (VAL @object)))))
	     (=>(ExecutionManager.report (VAL @executionId) FAILURE))
	     (!(SEM-V ExecutionManager.sem))
	     (!(FAILED))
	     )
	  (IF(?(Robot.hasObject @arm (VAL @object)))
	     
	     ELSE
	     (?(Robot.hasObjectForThrow @arm (VAL @object)))
	     )

	  ;;set the parameters for ehe monitor manager
	  (!(= @failureConditions (. (. (ExecutionManager.report (VAL @executionId) FAILURE) .)  (. .) .) )) 	 ; item not there 
	  (!(= @successConditions (. (. (ExecutionManager.report (VAL @executionId) OK) .)  (. .) .) ))     ; when the execution starts the robot is free to monitor something else
	  
	  (!(MonitorManager.getFreeId @monitorId))
					;start the monitoring
	  (!(MonitorManager.monitorTarget (VAL @placement) "NO_NAME" (VAL @successConditions) (VAL @failureConditions) HIGH (VAL @monitorId)))	   
	  (^(MonitorManager.isMonitoringTarget (VAL @monitorId)))


					;get coordinates of the placement
	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request getJointAbsPose (VAL @placement) NO_NAME (VAL @sparkId)))
	  (!(ExecutionManager.handleReport Spark.report (VAL @sparkId) (VAL @executionId)))
	  (^(Spark.result (VAL @sparkId) @xp @yp @zp @yawp @pitchp @rollp))
	  (~>(Spark.result (VAL @sparkId) (VAL @xp) (VAL @yp) (VAL @zp) (VAL @yawp) (VAL @pitchp) (VAL @rollp)))


	  ;;get the actual position for the throw
	  (!(= @zf (+ @zp 0.60)))
	 
	  ;move the arm over the placement
	  (!(ArmActions.getFreeId @actionId))
	  (=>(ArmActions.action moveToX @arm @xp @yp @zf @actionId))
	  (!(ExecutionManager.handleReport ArmActions.report @actionId @executionId))
	  
	  
	  ;;execute the throw
	  (!(ArmActions.getFreeId @actionId))
	  (=>(ArmActions.action openGripper @arm @actionId))
	  (!(ExecutionManager.handleReport ArmActions.report @actionId @executionId))
	  
	  (=>(ExecutionManager.report @executionId OK))
	  (~>(Robot.hasObject (VAL @arm) (VAL @object)))
	  (~>(Robot.hasObjectForThrow (VAL @arm) (VAL @object)))

	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request setObjectInHand PR2_ROBOT (VAL @object) (VAL @armForPick) FALSE (VAL @sparkId)))
	  (!(ExecutionManager.handleReport Spark.report @sparkId @executionId))


	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request getJointAbsPose @placement NO_NAME @sparkId))
	  (!(ExecutionManager.handleReport Spark.report @sparkId @executionId))
	  (^(Spark.result (VAL @sparkId) @x @y @z @yaw @pitch @roll))

	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request setInferrenceForObject @object 1 @placement 0 SPARK_IS_IN 1.0 @sparkId))
	  (!(ExecutionManager.handleReport Spark.report @sparkId @executionId))

	  (!(SEM-V ExecutionManager.sem))

	  )
   
   )

(defop |place|
  :invocation(ExecutionManager.execute place @object @support @placement @executionId)
  :documentation "Places an object on a support in a specific placement or a casual one if placement is NO_NAME. For now the casual version is not implemented"
  :body (
	 (!(SEM-P ExecutionManager.sem))
	 (IF(?(~(Robot.hasObject @arm  (VAL @object))))
	    (=>(ExecutionManager.report (VAL @executionId) FAILURE))
	    (!(SEM-V ExecutionManager.sem))
	    (!(FAILED))
	    )
	 (?(Robot.hasObject @arm (VAL @object)))


					;move the arm over the placement
	  (!(ArmActions.getFreeId @actionId))
	  (=>(ArmActions.action moveToPlaceObject @arm @object @support @placement @actionId))
	  (!(ExecutionManager.handleReport ArmActions.report @actionId @executionId))
	  
	  
	  ;;open the gripper
	  (!(ArmActions.getFreeId @actionId))
	  (=>(ArmActions.action openGripper @arm @actionId))
	  (!(ExecutionManager.handleReport ArmActions.report @actionId @executionId))
	  
	  (=>(ExecutionManager.report @executionId OK))
	  (~>(Robot.hasObject (VAL @arm) (VAL @object)))
  
	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request setObjectInHand (VAL @object) (VAL @armForPick) FALSE (VAL @sparkId)))
	  (!(ExecutionManager.handleReport Spark.report @sparkId @executionId))
	  
	 
	 (!(SEM-V ExecutionManager.sem))	 
	 )
  )
)
