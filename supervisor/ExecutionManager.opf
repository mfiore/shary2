;; -*-Lisp-*-
;;author: Michelangelo Fiore
;;this module contains high-level actions like take an item, give, drop.
(

 (defop |init|
   :invocation(!(ExecutionManager.init))
   :documentation "Inits the module"
   :body (
	  (=>(ExecutionManager.freeId 0))
	  (!(SEM-CREATE ExecutionManager.sem 1 SEM-FIFO))
	  )
   
   )
 
 (defop |getFreeId|
   :invocation(!(ExecutionManager.getFreeId $id))
   :documentation "Returns an id to use in executions"
   :body (
	  (!(SEM-P ExecutionManager.sem))
	  (?(ExecutionManager.freeId $id))
	  (=>(ExecutionManager.freeId (+ $id 1)))
	  (!(SEM-V ExecutionManager.sem))
	 
	 )
   )


(defop |executeAction|
  :invocation(ExecutionManager.executeAction @actionName @actionParameters @executionId)
  :documentation "Launching point to allow other modules to launch actions in a generic way"
  :body (
	 (?(Action.type (VAL @actionName) @type))
	 (IF(?(EQUAL @type MANIPULATION))
	    (!(== (VAL @actionParameters) (. @object .)))
	 
	    ELSEIF(?(EQUAL @type HANDOVER))
	    (!(== (VAL @actionParameters) (. @object @agent1 @agent2 .)))

	    ELSEIF(?(EQUAL @type PLACEMENT))
	    (!(== (VAL @actionParameters) (. @object @placement .)))

	    )
	 (IF(?(EQUAL @actionName take))
	    (=>(ExecutionManager.execute take @object NO_NAME @executionId))
	    
	    ELSEIF(?(EQUAL @actionName throw))
	    (=>(ExecutionManager.execute throw @object @placement @executionId))

	    ELSEIF(?(EQUAL @actionName place))
	    (=>(ExecutionManager.execute place @object @placement @executionId))
	    
	    ELSEIF(?(EQUAL @actionName handover))
	    (IF(?(EQUAL @agent2 PR2_ROBOT))
	       (=>(ExecutionManager.execute handover GRAB @object @agent1 @executionId)) 
		 ELSE 
		 (=>(ExecutionManager.execute handover GIVE @object @agent2 @executionId))
		 )
	    ELSEIF(?(EQUAL @actionName undefined))
	    (=>(ExecutionManager.report (VAL @executionId) OK))
	    
	    )

	 
	 )
  )

(defop |chooseArmForTake|
  :invocation(!(ExecutionManager.chooseArmForTake @object @executionId $armForTake))
  :documentation "Utility procedure to choose an arm for grasping. Returns the arm for the take action"
  :body (
	 (?(Spark.robotName @robotName)) 
	 (?(Spark.robotTorso @torso))
	 
					;If the robot has only one free arm try the take action with that arm. 
	 (IF(?(& (Robot.hasObject RIGHT @anyObject) (~(Robot.hasObject LEFT @anyObject2))))
	    (!(= $armForTake LEFT))
	     
	    ELSEIF(?(&(~(Robot.hasObject RIGHT @anyObject)) (Robot.hasObject LEFT @anyObject2)))
	    (!(= $armForTake RIGHT))
	     
	     ELSE
					;otherwise calculate which is the best arm to use based on the object position relative to the robot
	     
	     
	     (!(Spark.getFreeId @sparkId))
	     (=>(Spark.request getJointAbsPose (VAL @object) "NO_NAME" (VAL @sparkId))) 
	     (^(Spark.report (VAL @sparkId) @sparkReport))
	     (IF(?(~(EQUAL @sparkReport "OK")))
		(=> (ExecutionManager.report (VAL @executionId) (VAL @sparkReport)))
		(!(SEM-V ExecutionManager.sem))
		(~>(ExecutionManager.isExecutingAction (VAL @executionId)))
		(!(FAILED))
		)
	     (^(Spark.result (VAL @sparkId) @xOb @yOb @zOb @yawOb @pitchOb @rollOb))
	     (~>(Spark.result (VAL @sparkId) @xOb @yOb @zOb @yawOb @pitchOb @rollOb))
	     (~>(Spark.report (VAL @sparkId) @sparkReport))
	     
	     (!(Spark.getFreeId @sparkId))
	     (=>(Spark.request getJointAbsPose (VAL @robotName ) (VAL @torso) (VAL @sparkId))) 
	     (^(Spark.report (VAL @sparkId) @sparkReport))
	     (IF(?(~(EQUAL @sparkReport "OK")))
		(=> (ExecutionManager.report (VAL @executionId) (VAL @sparkReport)))
		(!(SEM-V ExecutionManager.sem))
		(~>(ExecutionManager.isExecutingAction (VAL @executionId)))
		(!(FAILED))
		)
	     (^(Spark.result (VAL @sparkId) @xTorso @yTorso @zTorso @yawTorso @pitchTorso @rollTorso))
	     (~>(Spark.result (VAL @sparkId) @xTorso @yTorso @zTorso @yawTorso @pitchTorso @rollTorso))
	     (~>(Spark.report (VAL @sparkId) @sparkReport))
	      
	     (IF(?(> @yOb @yTorso))
		(!(= $armForTake LEFT))
		
		ELSE
		(!(= $armForTake RIGHT))
		)
	     )
	  
	  )
  )


(defop |cleanModuleRequestes|
  :invocation(!(ExecutionManager.cleanModuleRequestes))
  :documentation "When we stop an action we want to stop all the living requestes like detectPression"
  :body (
	 (IF(?(ArmActions.detectPression @gripper @mode @smId))
	    (~>(ArmActions.detectPression (VAL @gripper) (VAL @mode) (VAL @smId)))
	    (?(Softmotion.gripperCancel (VAL @gripper) @state))
	    (!(Softmotion.getFreeId @smId))
	    (=>(Softmotion.request useGripper @state @smId))
	    (^(Softmotion.report (VAL @smId) @report))
	    )
	 (^(Robot.isMovingArm RIGHT FALSE))
	 (^(Robot.isMovingArm LEFT FALSE))
	 )
  )
 (defop |handleReport|
   :invocation(!(ExecutionManager.handleReport @module @id @executionId @stoppable @object))
   :documentation "Utility function to avoid some code duplication when waiting for the response of a genom module. This can't be used when we don't want to fail if the genom request fails"
   :body (
	 (!(= @reportName (TERM-STRING-CAT (VAL @module) ".report")))
	 (!(= @reportName (MAKE-ATOM @reportName)))

	 (^(|| (@reportName (VAL @id) @report) (ExecutionManager.halt (VAL @executionId)) (& (EQUAL @stoppable TRUE) (ExecutionManager.stop (VAL @executionId)) )))
	 
	 (IF(?(@reportName (VAL @id) @report))   
	    (~>(@reportName (VAL @id) (VAL @report)))
	    (IF(?(~(EQUAL @report "OK")))   ; if we have a negative report we quit
	       (!(PRINT @report))
	       (=> (ExecutionManager.report (VAL @executionId) FAILURE))
	       (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
	       (!(ExecutionManager.cleanModuleRequestes))
	       (IF(?(~(EQUAL @object NO_NAME)))
		  (!(DatabaseInterface.setReachabilityFalse (VAL @object) @result)) ;;the robot tought that the object was reachable while, in fact, it was not (shouldn't this be in armactions?)
		  )
	       (!(SEM-V ExecutionManager.sem))
	       (!(FAILED))
	       )
	    ELSEIF(?(ExecutionManager.halt (VAL @executionId)))  ;if we halt we want to pause until we receive a resume or stop order.
	    (~>(ExecutionManager.halt (VAL @executionId)))
	    (IF(?(EQUAL @module ArmActions))
	       (=>(ArmActions.halt (VAL @id)))
	       )
	    (^(|| (& (EQUAL @stoppable TRUE) (ExecutionManager.stop (VAL @executionId))) (ExecutionManager.resume (VAL @executionId))))
	    
	    (IF(?(ExecutionManager.resume (VAL @executionId)))   ;we ask to resume and recall this function to wait for the report
	       (~>(ExecutionManager.resume (VAL @executionId)))
	       (IF(?(EQUAL @module ArmActions))
		  (=>(ArmActions.resume (VAL @id)))
		  )
	       (!(ExecutionManager.handleReport @module @id @executionId @stoppable @object )) 
	       )
	    
	    
	    ELSEIF(?(&(ExecutionManager.stop (VAL @executionId)) (EQUAL @stoppable TRUE)))   ;;if we stop we abandon the action. Possible problem of coherency

	    (~>(ExecutionManager.stop (VAL @executionId)))
	    (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
	       ;; (IF(?(EQUAL @module ArmActions))
	       ;; 	  (=>(ArmActions.stop @id))
		  
	       ;; 	  ELSEIF(?(EQUAL @module Spark))
	       ;; 	  (=>(Spark.stop (VAL @id)))
		  
	       ;; 	  ELSEIF(?(EQUAL @module Viman))
	       ;; 	  (=>(Viman.stop (VAL @id)))      
	       ;; 	  )
	       (^(@reportName (VAL @id) @report))
	       (~>(@reportName (VAL @id) (VAL @report)))
	       (=>(ExecutionManager.report @executionId STOPPED))
	       (!(ExecutionManager.cleanModuleRequestes))
	       (!(SEM-V ExecutionManager.sem))
	       (!(FAILED))
	            
	       )
	 )
   )
   

   

 (defop |take|
   :invocation(ExecutionManager.execute take @object @arm @executionId)
   :documentation "this procedure takes the object @object. @arm can be setted to one of the two arms (RIGHT or LEFT) or to NO_NAME. In that case the robot chooses the arm to compute the action"
   :body (	  
	  (!(SEM-P ExecutionManager.sem))
	  	 


	  ;;check if the action has already been realized
	  (IF(?(~(EQUAL @arm NO_NAME)))
	     (IF(?(Robot.hasObject (VAL @arm) (VAL @object)))
		(=>(ExecutionManager.report (VAL @executionId) OK))
		(!(SEM-V ExecutionManager.sem))

		(!(FAILED))
		
		)
	     ELSEIF(?(Robot.hasObject @anyArm (VAL @object)))
	     (=>(ExecutionManager.report (VAL @executionId) OK))
	     (!(SEM-V ExecutionManager.sem))
	     (!(FAILED))
	     )
	  
	  ;;check if the robot has both hands full (or one hand if @arm was specified)
	  (IF(?(~(EQUAL @arm NO_NAME)))
	     (IF(?(Robot.hasObject (VAL @arm) @anyObject))
		(=>(ExecutionManager.report (VAL @executionId) FAILURE))
		(!(SEM-V ExecutionManager.sem))
		(!(FAILED))
		)
	     ELSEIF(?(|| (Robot.hasObject RIGHT  @anyObject) (Robot.hasObject LEFT  @anyObject)))
	     (=>(ExecutionManager.report (VAL @executionId) FAILURE))
	     (!(SEM-V ExecutionManager.sem))
	     (!(FAILED))
	     )
	  (=>(ExecutionManager.isExecutingAction (VAL @executionId)))
	  ;;set the parameters for the monitor manager
	   (!(= @failureConditions (. (. .)  (. (ExecutionManager.report (VAL @executionId) FAILURE) (ExecutionManager.report (VAL @executionId) STOPPED) .) .) )) 	 ; item not there 
	  (!(= @successConditions (. (. (ExecutionManager.report (VAL @executionId) OK) .)  (. .) .) ))     ; look at the item until execution is completed
	  

	  (!(MonitorManager.getFreeId @monitorId))

	  
	  ;;start the monitoring
	  (!(MonitorManager.monitorTarget @object "NO_NAME" @successConditions @failureConditions HIGH @monitorId))
	  
	  (WHILE(?(~(MonitorManager.isMonitoringTarget (VAL @monitorId)))) ;until the monitor starts
		(^(|| (MonitorManager.isMonitoringTarget (VAL @monitorId)) (MonitorManager.report (VAL @monitorId) @monitorReport ))) ;wait until the monitoring starts or it returns a value (which would be an error, a cancel or a stopped status since it can't succed before execution starts.
		
		(IF(?(MonitorManager.report (VAL @monitorId) @report)) ;;there's an error (like object not present) or the monitoring has being stopped or canceled
		   (~>(MonitorManager.report (VAL @monitorId) @report))
		   (IF(?(EQUAL @report STOPPED))
		      (=>(ExecutionManager.report (VAL @executionId) STOPPED)) ;pause the execution and go back to the loop
		      ELSEIF(?(EQUAL @report CANCELED))
		      (=> (ExecutionManager.report (VAL @executionId) FAILURE))  ;we fail
		      (!(SEM-V ExecutionManager.sem))
		      (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
		      (!(FAILED))
		      
		      ELSE  ;unhandled report
		      (=> (ExecutionManager.report (VAL @executionId) @report)) 
		      (!(SEM-V ExecutionManager.sem))
		      (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
		      (!(FAILED))
		      )
		   )	
		)
	  ;;everything is good. Monitoring has started. We can choose an arm for take if needed
 
	  (IF(?(EQUAL @arm NO_NAME)) 
	     (!(ExecutionManager.chooseArmForTake @object @executionId @armForPick))
	    
	     ELSE
	     (!(= @armForPick @arm))
	     )


					;open gripper if needed
	  (IF(?(Robot.gripper (VAL @armForPick) CLOSE))
	     (!(ArmActions.getFreeId @actionId))
	     (=>(ArmActions.action openGripper @armForPick @actionId))
	     (!(ExecutionManager.handleReport ArmActions @actionId @executionId TRUE NO_NAME))
	     )


	  ;;plan and execute the trajectory
	  (!(ArmActions.getFreeId @actionId))
	  (=>(ArmActions.action moveToObject @armForPick @object @actionId))


	  (!(ExecutionManager.handleReport ArmActions @actionId @executionId TRUE @object))

	  

					;close the gripper
	  (!(ArmActions.getFreeId @actionId))
	  (=>(ArmActions.action closeGripper @armForPick @actionId))
	  (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE NO_NAME))
	  
					;updates knowledge of the robot


	  (=> (Robot.hasObject (VAL @armForPick) (VAL @object))) ;if we arrive here with no FAILED than we've got the item (hopefully XD)

	  (=>(ExecutionManager.report (VAL @executionId) OK))
	  (~>(ExecutionManager.isExecutingAction (VAL @executionId)))

	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request setObjectInHand PR2_ROBOT (VAL @object) (VAL @armForPick) TRUE (VAL @sparkId)))
	  (!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE NO_NAME))
	  
	  (!(DatabaseInterface.add (AGENT-STATEMENT PR2_ROBOT PR2_ROBOT hasInHand (VAL @object)) @result))
	  (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
	  (!(SEM-V ExecutionManager.sem))
	  )
   
   )



 (defop |getHumanObservations|
   :invocation(!(ExecutionManager.getHumanObservations @agent @executionId $armPosition $distance $orientation))
   :documentation "utility procedure that calculates the observations for the POMDP. SHOULD GO TO ANOTHER FILE"
   :body (
	  (?(Spark.robotName @sparkRobotName))
	  (?(Spark.humanWrist @hWrist))
	  (?(Spark.humanHip @hHip))

	  (?(ExecutionManager.oldArmPosition @oldArmPosition))
	  (?(ExecutionManager.oldDistance @oldDistance))

	 (?(Robot.position TORSO @robotTorsoX @robotTorsoY @robotTorsoZ @robotTorsoYaw @robotTorsoPitch @robotTorsoRoll))	 
	  ;;get the human right hip position
	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request getJointAbsPose (VAL @agent) (VAL @hHip) (VAL @sparkId)))
	  (^(Spark.report (VAL @sparkId) @report))

	  (~>(Spark.report (VAL @sparkId) (VAL @report)))

	  (IF(?(~(EQUAL @report "OK")))   ;;the human is not in sight
	     (!(= $distance outOfRange))
	     (!(= $armPosition unknown))
	     (!(= $orientation unknown))
	     (=>(ExecutionManager.oldDistance outOfRange))
	     (=>(ExecutionManager.oldArmPosition unknown))
	     (=>(ExecutionManager.oldOrientation unknown))
	     
	     ELSE   ;human in sight
	     
	     (^(Spark.result (VAL @sparkId) @humanHipX @humanHipY @humanHipZ @humanHipYaw @humanHipPitch @humanHipRoll))
	     (~>(Spark.result (VAL @sparkId) (VAL @humanHipX) (VAL @humanHipY) (VAL @humanHipZ) (VAL @humanHipYaw) (VAL @humanHipPitch) (VAL @humanHipRoll)))
					;get the human wrist position
	     (!(Spark.getFreeId @sparkId))
	     (=>(Spark.request getJointAbsPose (VAL @agent) (VAL @hWrist) (VAL @sparkId)))
	     (!(ExecutionManager.handleReport Spark @sparkId @executionId TRUE NO_NAME))
	     (^(Spark.result (VAL @sparkId) @humanWristX @humanWristY @humanWristZ @humanWristYaw @humanWristPitch @humanWristRoll))
	     (~>(Spark.result (VAL @sparkId) (VAL @humanWristX) (VAL @humanWristY) (VAL @humanWristZ) (VAL @humanWristYaw) (VAL @humanWristPitch) (VAL @humanWristRoll)))
	     
	     
					;calculate distance between robot and human. The distance is squared because oprs as no SQRT operator and i'm too lazy to implement it at the moment.
	     (!(= @xDiff (- @humanHipX @robotTorsoX)))
	     (!(= @xDiffSquare (* @xDiff @xDiff)))
	     (!(= @yDiff (- @humanHipY @robotTorsoY)))
	     (!(= @YDiffSquare (* @yDiff @yDiff)))
	     (!(= @zDiff (- @humanHipZ @robotTorsoZ)))
	     (!(= @zDiffSquare (* @zDiff @zDiff)))	   
	     (!(= @squareDistance (+ @xDiffSquare @YDiffSquare @zDiffSquare)))
	     

	     
	     (IF(?(> @squareDistance 50))
		(!(= $distance outOfRange))
		(!(= $armPosition unknown))
		(!(= $orientation unknown))
		(=>(ExecutionManager.oldDistance outOfRange))
		(=>(ExecutionManager.oldArmPosition unknown))
		(=>(ExecutionManager.oldOrientation unknown))
		
		
		ELSE
		(IF(?(EQUAL @oldDistance outOfRange))
		   (!(= $distance closer))
		   ELSEIF(?(< @squareDistance (- @oldDistance 0.5)))
		   (!(= $distance closer))
		   ELSEIF(?(> @squareDistance (+ @oldDistance 0.5)))
		   (!(= $distance farther))
		   ELSE
		   (!(= $distance still))
		   )

		(=>(ExecutionManager.oldDistance @squareDistance))
		
		(IF(?(EQUAL @oldOrientation unknown))
		   (!(= $orientation towardRobot))
		   
		   ELSE
		   (!(= $orientation still))
		   )
		(=>(ExecutionManager.oldOrientation (VAL $orientation)))
					;calculate distance between human hand and wrist. The distance is squared because oprs as no SQRT operator and i'm too lazy to implement it at the moment.
		(!(= @xDiff (- @humanHipX @humanWristX)))
		(!(= @xDiffSquare (* @xDiff @xDiff)))
		(!(= @yDiff (-  @humanHipY @humanWristY)))
		(!(= @YDiffSquare (* @yDiff @yDiff)))
		(!(= @zDiff (-  @humanHipZ @humanWristZ)))
		(!(= @zDiffSquare (* @zDiff @zDiff)))	   
		(!(= @squareDistance (+ @xDiffSquare @YDiffSquare @zDiffSquare)))
		

		(IF(?(EQUAL @oldArmPosition unknown))
		   (!(= $armPosition closer))
		   ELSEIF(?(> @squareDistance (+ @oldArmPosition 0.05)))
		   (!(= $armPosition closer))
		   ELSEIF(?(< @squareDistance (- @oldArmPosition 0.05)))
		   (!(= $armPosition farther))
		   ELSE
		   (!(= $armPosition still))
		   )  

		(=>(ExecutionManager.oldArmPosition @squareDistance))
		)
					;	    (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @sparkRobotName) (VAL @sparkAgent) armPosition @armPosition) (. @armPosition .) @result))
					;	    (IF(?(~(EQUAL @result ERROR)))
					;	       (!(= @result (CAR @result)))
					;	       (!(= $armPosition (CAR @result)))
					;	       )

					;	    (!(DatabaseInterface.findList (AGENT-STATEMENT (VAL @sparkRobotName) (VAL @sparkAgent) orientation @orientation) (. @orientation .) @result))
					;	    (IF(?(~(EQUAL @result ERROR)))
					;	       (!(= @result (CAR @result)))
					;	       (!(= $orientation (CAR @result)))
					;	       )
	     
	     )
	  
	  
	  )
   )


(defop |getQForHuman|
  :invocation (!(ExecutionManager.getQForHuman @arm @agent $finalQ0))
  :documentation "calculates a q0 value so that the arm is oriented toward the agent. This procedure at the moment is implemented only for the right arm. NEEDS TO BEUPDATED"
  :body (
	 (?(Spark.robotName @sparkRobotName))
	 (?(Spark.humanTorso @hTorso))
	 (?(Robot.position TORSO @robotTorsoX @robotTorsoY @robotTorsoZ @robotTorsoYaw @robotTorsoPitch @robotTorsoRoll))
	 ;;get the human position
	 (!(Spark.getFreeId @sparkId))
	 (=>(Spark.request getJointAbsPose (VAL @agent) (VAL @hTorso) (VAL @sparkId)))
	 (^(Spark.report (VAL @sparkId) @report))
	 
	 (~>(Spark.report (VAL @sparkId) (VAL @report)))
	 
	 (^(Spark.result (VAL @sparkId) @humanTorsoX @humanTorsoY @humanTorsoZ @humanTorsoYaw @humanTorsoPitch @humanTorsoRoll))
	 (~>(Spark.result (VAL @sparkId) (VAL @humanTorsoX) (VAL @humanTorsoY) (VAL @humanTorsoZ) (VAL @humanTorsoYaw) (VAL @humanTorsoPitch) (VAL @humanTorsoRoll)))
	 (!(= @q0 0.4))
	 (!(= @difference (- @robotTorsoX @humanTorsoX)))
	 (!(= @q0 (- @q0 @difference)))

	 (IF(?(> @q0 0.7))
	    (!(= @q0 0.7))
	    ELSEIF(?(< @q0 -0.7))
	    (!(= @q0 0.7))
	    )
	 (!(= $finalQ0 (VAL @q0)))
	 
	 )
  
  )

(defop |give|
  :invocation(ExecutionManager.execute handover @type @object @agent @executionId)
  :documentation "this procedure gives the object @object to the agent @agent. If the robot doesn't have the @item it fails"
  :body (
	 (!(SEM-P ExecutionManager.sem))
	 (!(= @observationWaitTime 0)) ;time to wait to get new observations
	 (!(= @maxEngage 3))           ;number of times the robot will try to re-engage the user before understanding he's not interested
	 (!(= @nEngage 0))             ;number of times the robot has engaged the user
	 (!(= @waitTime 20))          ;time to wait before engaging the user
	 
	 (?(Spark.robotTorso @rTorso))
	 (?(Spark.humanHead @humanHead))

	 (!(= @monitorSuccessConditions (. (. (ExecutionManager.report (VAL @executionId) OK) .) (. .) .)))
	 (!(= @monitorFailureConditions  (. (. .) (. (ExecutionManager.report (VAL @executionId) FAILURE) (ExecutionManager.report (VAL @executionId) STOPPED) .) .)))



	 (IF(?(EQUAL @type GIVE))
	    (IF(?(Robot.hasObject @arm  (VAL @object)))  ;if the robot doesn't have the object fail
	       ELSE 
	       (=>(ExecutionManager.report (VAL @executionId) FAILURE))
	       (!(SEM-V ExecutionManager.sem))
	       (!(FAILED))
	       )
	      
	    ELSEIF(?(EQUAL @type GRAB)) ;select an arm for the grab or fail if there are free arms
	    (IF(?(Robot.hasObject RIGHT  @anyObject))
	       (IF(?(Robot.hasObject LEFT  @anyObject))
		  (!(SEM-V ExecutionManager.sem))
		  (!(FAILED))
		  
		  ELSE
		  (!(= @arm LEFT))
		  (!(ArmActions.getFreeId @actionId))
		  (=>(ArmActions.action openGripper @arm @actionId))
		  (!(ExecutionManager.handleReport ArmActions @actionId @executionId TRUE NO_NAME))
		  )
		    
	       ELSE
	       (!(= @arm RIGHT))
	       (!(ArmActions.getFreeId @actionId))
	       (=>(ArmActions.action openGripper @arm @actionId))

	       (!(ExecutionManager.handleReport ArmActions @actionId @executionId TRUE NO_NAME))
	       )
	    )
	 
	 (=>(ExecutionManager.isExecutingAction (VAL @executionId)))
	 (?(Spark.robotName @sparkRobotName))
	
	 ;;get the robot torso position (to compute distance from the user)
	 (!(Spark.getFreeId @sparkId))
	 (=>(Spark.request getJointAbsPose (VAL @sparkRobotName) (VAL @rTorso) (VAL @sparkId)))
	 (!(ExecutionManager.handleReport Spark @sparkId @executionId TRUE NO_NAME))
	 (?(Spark.result (VAL @sparkId) @robotTorsoX @robotTorsoY @robotTorsoZ @robotTorsoYaw @robotTorsoPitch @robotTorsoRoll))
	 (~>(Spark.result (VAL @sparkId) (VAL @robotTorsoX) (VAL @robotTorsoY) (VAL @robotTorsoZ) (VAL @robotTorsoYaw) (VAL @robotTorsoPitch) (VAL @robotTorsoRoll)))

	 (=>(Robot.position TORSO @robotTorsoX @robotTorsoY @robotTorsoZ @robotTorsoYaw @robotTorsoPitch @robotTorsoRoll))
	 
	 ;move to rest position
;	 (!(ArmActions.getFreeId @actionId))
;	 (=>(ArmActions.action moveToRestPosition (VAL @arm) (VAL @actionId)))
;	 (!(ExecutionManager.handleReport ArmActions @actionId @executionId))
	

	 ;;Set the starting variables. We only compute observations to set inRange at the start.
	 (!(ExecutionManager.getHumanObservations @agent  @executionId @armPosition @distance @orientation))
	 (IF(?(EQUAL @distance outOfRange))
	    (!(= @inRange false))
	    (!(= @q0 0))  ;set the starting q0. This manouvres the robot arm horizontal position so that it can follow the human when it moves.
	    ELSE
	    (!(= @inRange true))
	    (!(ExecutionManager.getQForHuman @arm @agent @q0))
	    (IF(?(EQUAL @type GIVE))
	       (!(Acapela.say "I'm ready to give you the item"))
	       
	       ELSEIF(?(EQUAL @type GRAB))
	       (!(Acapela.say "Could you give me the item?"))
	       )
	    (!(MonitorManager.getFreeId @monitorId))
	    (!(MonitorManager.monitorTarget @agent @humanHead @monitorSuccessConditions @monitorFailureConditions HIGH @monitorId)) 

	    )
	 
	 (!(= @task notCompleted))  
	 (!(= @time ok))
	 (!(= @xState (TERM-STRING-CAT @inRange @task @time)))
	 
	 ;;init the POMDP
	 (!(POMDP.init Handover @xState @action @yState))
	 (!(= @robotState armRest))  ;;possible states are armRest armReady and armExtended
	 
	 (WHILE(?(& (~(ExecutionManager.stop (VAL @executionId))) (~(ExecutionManager.report (VAL @executionId) @anyReport)) (~(EQUAL @action ABANDON)))) ;loop until we are stopped, we get a report (means we fail basically) or we abandon the task
	       
	       ;;we extend the arm if:
	       ;;the arm is not extended and:
	       ;;-we get a continue action
	       ;;we get a wait action and the user is engaged.
	       
	       (IF(?(& (~(EQUAL @robotState armExtended)) (|| (EQUAL @action CONTINUE) (& (EQUAL @action WAIT) (EQUAL @yState engaged)))))  ;if user is engaged and arm is not extended extend it
		  (IF(?(EQUAL @task waitingGrasp)) ;if we are waiting for grasp we close the gripper, move and then relaunch release to avoid it opening because of the arm moving.
		     (!(ArmActions.getFreeId @detectPressionId))
		     (=>(ArmActions.action stopDetectPression @arm @type @detectPressionId))
		     (!(ExecutionManager.handleReport ArmActions @detectPressionId @executionId TRUE NO_NAME))
		     )

		  (!(ArmActions.getFreeId @armPositionId))
		  (=>(ArmActions.action moveToExtendedPosition @arm @q0 @actionId))
		  (!(ExecutionManager.handleReport ArmActions @actionId @executionId TRUE NO_NAME))
		       
		  (!(ArmActions.getFreeId @detectPressionId))
		  (=>(ArmActions.action detectPression @arm @type @detectPressionId))

		    		  
		  (!(= @task waitingGrasp))
		  (!(= @robotState armExtended))
		  
		  
		  ;;we put the arm to ready if:
		  ;;the arm is not ready and:
		  ;;the user is not engaged and in range
		  ;;we get a WAIT or ENGAGE command
		  ;;task state is not modified here
		  ELSEIF(?(&(~(EQUAL @robotState armReady)) (EQUAL @yState notEngaged) (EQUAL @inRange true) (|| (EQUAL @action WAIT) (EQUAL @action ENGAGE))))
		  (^(Robot.isMovingArm (VAL @arm) FALSE))
		  (IF(?(EQUAL @task waitingGrasp))
		     (!(ArmActions.getFreeId @detectPressionId))
		     (=>(ArmActions.action stopDetectPression @arm @type @detectPressionId))
		     (!(ExecutionManager.handleReport ArmActions @detectPressionId @executionId TRUE NO_NAME))
		     )
		  (!(ArmActions.getFreeId @actionId))
		  (=>(ArmActions.action moveToReadyPosition (VAL @arm) @q0 @actionId))
		  (=>(ExecutionManager.handleReport ArmActions @actionId @executionId TRUE NO_NAME))
		  
		  (!(ArmActions.getFreeId @detectPressionId))
		  (=>(ArmActions.action detectPression @arm @type @detectPressionId))


		  (!(= @robotState armReady))
		  (!(= @task waitingGrasp))
		
		  ;;we go to rest state if
		  ;;we receive a wait command and the user is out of range and the the robot is not in restState
		  ELSEIF(?(& (~(EQUAL @robotState armRest)) (EQUAL @inRange false) (EQUAL @action WAIT)))
		  (^(Robot.isMovingArm (VAL @arm) FALSE))
		  (IF(?(EQUAL @task waitingGrasp))
		     (!(ArmActions.getFreeId @detectPressionId))
		     (=>(ArmActions.action stopDetectPression @arm @type @detectPressionId))
		     (!(ExecutionManager.handleReport ArmActions @detectPressionId @executionId TRUE NO_NAME))
		     )
		  
		  (!(ArmActions.getFreeId @actionId))
		  (=>(ArmActions.action moveToRestPosition @arm @actionId))
		  (!(= @robotState armRest))
		  (!(= @task notCompleted))
		  )
	       
	       
	       (IF(?(EQUAL @action WAIT)) ;if the action is wait we start the timer (if it's not started already)
		  (IF(?(~(Timer.isRunning (VAL @timerId))))
		     (!(Timer.getFreeId @timerId))                  ;start a timer to edit the state variable time. 
		     (=>(Timer.start @waitTime @timerId))
		     )
		  
		  ELSEIF(?(EQUAL @action ENGAGE))   ;if the action is engage we stop the timer (if started) and talk to the user
		  (IF(?(Timer.isRunning (VAL @timerId)))
		     (=>(Timer.stopTimer (VAL @timerId)))
		     )
		  (IF(?(Timer.elapsedTime (VAL @timerId)))
		     (~>(Timer.elapsedTime (VAL @timerId)))
		     )
		  (!(= @time ok))
		  (IF(?(EQUAL @type GIVE))
		     (!(Acapela.say "I'm ready to give you the item. Are you still interested?"))
		  
		     ELSEIF(?(EQUAL @type GRAB))
		     (!(Acapela.say "I'm ready to take the item. Could you please give it to me?"))
		     )
		  )
	       ;;WAIT before getting the new observations
	       (^(ELAPSED-TIME (TIME) @observationWaitTime))
	       (!(ExecutionManager.getHumanObservations @agent @executionId @armPosition @distance @orientation))
	       
	       
	       (IF(?(EQUAL @distance outOfRange))
		  (!(= @inRange false))
		  (!(= @q0 0))
		  ELSE
		  (!(= @inRange true))
		  (!(ExecutionManager.getQForHuman @arm @agent @qo))
		  )
	       
	       ;;if the user is out of range and the monitor has not failed stop the monitor. If the user is in range and we are not monitoring it start the monitor.
	       
	       (IF(?(EQUAL @inRange true))
		  (IF(?(~(MonitorManager.isMonitoringTarget (VAL @monitorId))))
		     (!(MonitorManager.getFreeId @monitorId))
		     (!(MonitorManager.monitorTarget @agent @humanHead @monitorSuccessConditions @monitorFailureConditions HIGH @monitorId)) 
		     )
		  ELSE
		  (IF(?(MonitorManager.isMonitoringTarget (VAL @monitorId)))
		     (IF(?(~(MonitorManager.report (VAL @monitorId) @report)))
			(=>(MonitorManager.cancelMonitoring (VAL @monitorId)))
			(^(MonitorManager.report (VAL @monitorId) @report))
			(~>(MonitorManager.report (VAL @monitorId) @report))
			ELSE
			(~>(MonitorManager.report (VAL @monitorId) @report))
			)
		     )
		  )
	       (IF(?(EQUAL @task waitingGrasp)) ;if we are waiting a grasp and detecting pressure we open or close the gripper depending on the kind of handover
		  (IF(?(Robot.gripper (VAL @arm) DETECTED_PRESSION))
		     (~>(Robot.gripper (VAL @arm) DETECTED_PRESSION))
		     (~>(ArmActions.report @detectPressionId @report))
		     
		     (IF(?(EQUAL @type GIVE))
			(!(ArmActions.getFreeId @actionId))
			(=>(ArmActions.action openGripper @arm @actionId))
			(!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE NO_NAME))
					     	     
			ELSEIF(?(EQUAL @type GRAB))
			(!(ArmActions.getFreeId @actionId))
			(=>(ArmActions.action closeGripper @arm @actionId))
			(!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE NO_NAME))
			)
		     (!(= @task completed))
		     (IF(?(EQUAL @type GIVE))
			(~>(Robot.hasObject (VAL @arm) (VAL @object)))
			
			(!(Spark.getFreeId @sparkId))
			(=>(Spark.request placeObjectForSimu (VAL @object) 0 0 0 0 0 0 1 @sparkId)) 
			(!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE NO_NAME))
	       
			(!(Spark.getFreeId @sparkId))
			(=>(Spark.request setObjectInHand (VAL @sparkRobotName) (VAL @object) (VAL @arm) FALSE (VAL @sparkId)))
			(!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE NO_NAME))

			(!(Spark.getFreeId @sparkId))
			(=>(Spark.request setObjectInHand (VAL @agent) (VAL @object) (VAL @arm) TRUE (VAL @sparkId)))
			(!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE NO_NAME))

			(=>(Agent.hasObject (VAL @agent) (VAL @object)))
			(!(DatabaseInterface.remove (AGENT-STATEMENT PR2_ROBOT PR2_ROBOT hasInHand (VAL @object)) @result))
			(!(DatabaseInterface.add (AGENT-STATEMENT PR2_ROBOT (VAL @agent) hasInHand (VAL @object)) @result))
			ELSEIF(?(EQUAL @type GRAB))
					;	       (=>(Robot.hasObject (VAL @arm)  (VAL @object)))  ;explanation in the next comment
			(=>(Robot.hasObjectForThrow (VAL @arm) (VAL @object)))
			(!(Spark.getFreeId @sparkId))
			(=>(Spark.request placeObjectForSimu (VAL @object) 0 0 0 0 0 0 1 @sparkId)) 
			(!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE NO_NAME))

			(!(Spark.getFreeId @sparkId))
			(=>(Spark.request setObjectInHand (VAL @agent) (VAL @object) (VAL @arm) FALSE (VAL @sparkId)))
			(!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE NO_NAME))

			(~>(Agent.hasObject (VAL @agent) (VAL @object)))
			(!(DatabaseInterface.add (AGENT-STATEMENT PR2_ROBOT PR2_ROBOT hasInHand (VAL @object)) @result))
			(!(DatabaseInterface.remove (AGENT-STATEMENT PR2_ROBOT (VAL @agent) hasInHand (VAL @object)) @result))
			;;At this point we should put an inference to tell spark that the robot has an object. The problem is that with handover the robot usually doesn't see the object so it would be attached in the wrong
			;;position. At the moment we just act like if the robot doesn't have the object.
			;; (?(Spark.robotFinger (VAL @arm) @sparkRobotFinger))                

			;; (!(HeadActions.getFreeId @headId))
			;; (=>(HeadActions.action lookAt @sparkRobotName @sparkRobotFinger @headId))
			;; (!(ExecutionManager.handleReport HeadActions.report @headId @executionId))

			;; (!(Spark.getFreeId @sparkId))
			;; (=>(Spark.request setObjectInHand @sparkRobotName (VAL @object) (VAL @arm) TRUE (VAL @sparkId)))
			;; (!(ExecutionManager.handleReport Spark.report @sparkId @executionId))
			
			
			)
		     )
		  )
	       (IF(?(&(Timer.elapsedTime (VAL @timerId)) (~(EQUAL @task completed))))  ;check the timer
		  (!(= @time expired))
		  (~>(Timer.elapsedTime (VAL @timer)))
		  
		  ELSE
		  (!(= @time ok))
		  )
	 
	       ;;update the opmdp
	       (!(= @xState (TERM-STRING-CAT @inRange @task @time)))                       
	       (!(= @obs (TERM-STRING-CAT @armPosition @distance @orientation)))
	       
	       (!(POMDP.update Handover @obs @xState @action @yState))
	       
	       )
	 
	 ;task is over. We go to rest state
	 (IF(?(~(EQUAL @robotState armRest)))  
	    (^(ELAPSED-TIME (TIME) 2)) ;wait some seconds before leaving
	    (!(ArmActions.getFreeId @actionId))
	    (=>(ArmActions.action moveToRestPosition @arm @actionId))
	    (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE NO_NAME))
	    )

	 
	 (IF(?(EQUAL @task completed))
	    (!(Acapela.say "Good! Thank you!"))
	    
	    (=>(ExecutionManager.report @executionId OK))
	   
	    ELSE
	    (=>(ExecutionManager.report @executionId FAILURE))
	    (!(Acapela.say "Well... too bad. Have a nice day."))
	    )
	 (!(ExecutionManager.cleanModuleRequestes))
	 ;;stop any remaining monitor (should not be there actually but still...)
	 (IF(?(MonitorManager.target @any1 (VAL @monitorId) @any2))
	    (^(MonitorManager.report (VAL @monitorId) @report))
	    (~>(MonitorManager.report (VAL @monitorId) @report))
	    
	    ELSEIF(?(MonitorManager.report (VAL @monitorId) @report))
	    (~>(MonitorManager.report (VAL @monitorId) @report))
	    )
	 (IF(?(Timer.isRunning (VAL @timerId)))
	    (=>(Timer.stopTimer @timerId))
	    )
	 (IF(?(Timer.elapsedTime (VAL @timerId)))
	    (~>(ExecutionManager.elapsedTime (VAL @timerId)))
	    )

	 (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
	 (!(SEM-V ExecutionManager.sem))
	 )
  )




 (defop |throw|
   :invocation(ExecutionManager.execute throw @object @placement @executionId)
   :documentation "throw an object to a certain placement"
   :body (
	  (!(SEM-P ExecutionManager.sem))

	  (IF(?(&(~(Robot.hasObject @arm (VAL @object))) (~(Robot.hasObjectForThrow @arm (VAL @object)))))
	     (=>(ExecutionManager.report (VAL @executionId) FAILURE))
	     (!(SEM-V ExecutionManager.sem))
	     (!(FAILED))
	     )
	  (IF(?(Robot.hasObject @arm (VAL @object)))
	     
	     ELSE
	     (?(Robot.hasObjectForThrow @arm (VAL @object)))
	     )

	  (=>(ExecutionManager.isExecutingAction (VAL @executionId)))

	  ;;set the parameters for ehe monitor manager
	  (!(= @failureConditions (. (. .)   (. (ExecutionManager.report (VAL @executionId) FAILURE) (ExecutionManager.report (VAL @executionId) STOPPED) .) .) )) 	 ; item not there 
	  (!(= @successConditions (. (. (ExecutionManager.report (VAL @executionId) OK) .)  (. .) .) ))     ; when the execution starts the robot is free to monitor something else
	  
	  (!(MonitorManager.getFreeId @monitorId))
					;start the monitoring
	  (!(MonitorManager.monitorTarget (VAL @placement) "NO_NAME" (VAL @successConditions) (VAL @failureConditions) HIGH (VAL @monitorId)))	   
	  (^(MonitorManager.isMonitoringTarget (VAL @monitorId)))


					;get coordinates of the placement
	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request getJointAbsPose (VAL @placement) NO_NAME (VAL @sparkId)))
	  (!(ExecutionManager.handleReport Spark (VAL @sparkId) (VAL @executionId) TRUE NO_NAME))
	  (^(Spark.result (VAL @sparkId) @xp @yp @zp @yawp @pitchp @rollp))
	  (~>(Spark.result (VAL @sparkId) (VAL @xp) (VAL @yp) (VAL @zp) (VAL @yawp) (VAL @pitchp) (VAL @rollp)))


	  ;;get the actual position for the throw
	  (!(= @zf (+ @zp 0.60)))
	 
	  ;move the arm over the placement
	  (!(ArmActions.getFreeId @actionId))
	  (=>(ArmActions.action moveToX @arm @xp @yp @zf @actionId))
	  (!(ExecutionManager.handleReport ArmActions @actionId @executionId TRUE NO_NAME))
	  
	  
	  ;;execute the throw
	  (!(ArmActions.getFreeId @actionId))
	  (=>(ArmActions.action openGripper @arm @actionId))
	  (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE @placement))

	  (=>(ExecutionManager.report @executionId OK))
	  (~>(Robot.hasObject (VAL @arm) (VAL @object)))
	  (~>(Robot.hasObjectForThrow (VAL @arm) (VAL @object)))

	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request setObjectInHand PR2_ROBOT (VAL @object) (VAL @armForPick) FALSE (VAL @sparkId)))
	  (!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE NO_NAME))


	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request getJointAbsPose @placement NO_NAME @sparkId))
	  (!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE NO_NAME))
	  (^(Spark.result (VAL @sparkId) @x @y @z @yaw @pitch @roll))

	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request setInferrenceForObject @object 1 @placement 0 SPARK_IS_IN 1.0 @sparkId))
	  (!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE NO_NAME))
	  (!(DatabaseInterface.remove (AGENT-STATEMENT PR2_ROBOT PR2_ROBOT hasInHand (VAL @object)) @result))

	  (!(SEM-V ExecutionManager.sem))
	  
	  (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
	  )
   
   )

(defop |place|
  :invocation(ExecutionManager.execute place @object @support @placement @executionId)
  :documentation "Places an object on a support in a specific placement or a casual one if placement is NO_NAME. For now the casual version is not implemented"
  :body (
	 (!(SEM-P ExecutionManager.sem))


	 (IF(?(~(Robot.hasObject @arm  (VAL @object))))
	    (=>(ExecutionManager.report (VAL @executionId) FAILURE))
	    (!(SEM-V ExecutionManager.sem))
	    (!(FAILED))
	    )
	 (?(Robot.hasObject @arm (VAL @object)))
	 
	 (=>(ExecutionManager.isExecutingAction (VAL @executionId)))


					;move the arm over the placement
	  (!(ArmActions.getFreeId @actionId))
	  (=>(ArmActions.action moveToPlaceObject @arm @object @support @placement @actionId))
	  (!(ExecutionManager.handleReport ArmActions @actionId @executionId TRUE NO_NAME))
	  
	  
	  ;;open the gripper
	  (!(ArmActions.getFreeId @actionId))
	  (=>(ArmActions.action openGripper @arm @actionId))
	  (!(ExecutionManager.handleReport ArmActions @actionId @executionId FALSE NO_NAME))
	  
	  (=>(ExecutionManager.report @executionId OK))
	  (~>(Robot.hasObject (VAL @arm) (VAL @object)))
  
	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request setObjectInHand (VAL @object) (VAL @armForPick) FALSE (VAL @sparkId)))
	  (!(ExecutionManager.handleReport Spark @sparkId @executionId FALSE NO_NAME))

	  (~>(ExecutionManager.isExecutingAction (VAL @executionId)))
		  
	 (!(SEM-V ExecutionManager.sem))	 
	 )
  )
)
