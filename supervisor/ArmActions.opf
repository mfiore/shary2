; -*-Lisp-*-
;;author: Michelangelo Fiore
;;this module contains common actions for arm movements, using both mhp and softmotion. 

(

 (defop |init|
   :invocation(!(ArmActions.init))
   :documentation "Inits the module "
   :body (
	  (!(SEM-CREATE ArmActions.sem 1 SEM-FIFO))
	  
	  (=>(ArmActions.freeId 0))
	  )
   )

(defop |getFreeId|
  :invocation(!(ArmActions.getFreeId $id))
  :documentation "gets a new id for requestes"
  :body (
	 (!(SEM-P ArmActions.sem))
	 (?(ArmActions.freeId $id))
	 (=>(ArmActions.freeId (+ $id 1)))
	 (!(SEM-V ArmActions.sem))
	  )
   )

(defop |getMoveParameters|
  :invocation(!(ArmActions.getMoveParameters $task $object $support))
  :documentation "Gets the parameters of an MHP move request based on the robot position and eventual grabbed object. All variables are output only"
  :body (
	  (IF(?(Robot.hasObject (VAL @arm) @object))
	     (?(Robot.hasObject (VAL @arm) $object))
	     ELSE
	     (!(= $object NO_NAME))
	     )
	  (?(Robot.pose (VAL @arm) @closeToObject $support @pose)) 
	  (IF(?(EQUAL $object NO_NAME))
	     (!(= $task MHP_ARM_FREE))
	     
	     ELSE
	     (!(= $task MHP_ARM_TAKE_TO_FREE))
	     )
	  
	  )
  )

 (defop |moveTo|
   :invocation  (ArmActions.action moveTo @arm @task @armGoto @object @support @placement @useObjGoto @objGoto @pose @actionId)
   :documentation "generic procedure to move arm (note that arm start and objstart are not supported)
                   @arm= RIGHT, LEFT
                   @task, @armgoto ... @objGoto = check mhp documentation.
                   @pose we want to set the robot to EXTENDED, REST, OTHER. 
                   "
   :body (
	  (IF(?(~(EQUAL @object NO_NAME)))
	     (!(= @result NULL))
	     ;;this is done because in take requestes MHP doesn't need the support that the object is on but we still want to record this information in the system
	     (!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT (VAL @object) isOn @realSupport) (. @realSupport .) @result) )
	     
	     (IF(?(~(NULL @result)))
		(!(= @realSupport (CAR(CAR @result))))
		   
		ELSE
		(!(= @realSupport NO_NAME))
		)
	     ELSE
	     (!(= @realSupport NO_NAME))
	     )
	  
	  ;make parameters
	  (?(Mhp.arm (VAL @arm) @mhpArm))
	  (?(Softmotion.arm (VAL @arm) @smArm))

	  (!(Mhp.makeArmStartParameter 0 0 0 0 0 0 0 @armStart))
	  (!(= @objStart (objStart 0.0 0.0 0.0 0.0 0.0 0.0)))
	  
	  ;make request to mhp and softmotion
	  (!(Mhp.getFreeId @mhpId))
	  (=>(Mhp.request setTrajectory GEN_TRUE (VAL @task) (VAL @mhpArm) (VAL @armStart) (VAL @armGoto) (VAL @object) (VAL @support) (VAL @placement) GEN_FALSE 0 (VAL @objStart) (VAL @useObjGoto) (VAL @objGoto) (VAL @mhpId)))
	  
	  (!(ArmActions.handleReport Mhp @mhpId @actionId))
	  

	  (!(Softmotion.getFreeId @smId))
	  (=>(Softmotion.request moveArm @smArm @smId))
	  (!(ArmActions.handleReport Softmotion @smId @actionId))
	  ;everything went okay
	  (=>(ArmActions.report (VAL @actionId) "OK"))
	  (=>(Robot.pose (VAL @arm) (VAL @realSupport) (VAL @object) (VAL @pose)))

	  )
	  	  
   )

 (defop |escapeObject|
   :invocation(ArmActions.action escapeObject @arm @object @actionId)
   :documentation "Moves the arm away from a placed object"
   :body (
	  (!(Mhp.makeArmGotoParameter 0 0 0 0 0 0 0 @armGoto))
	  (!(= @objGoto (objGoto 0.0 0.0 0.0 0.0 0.0 0.0)))
	  
	  (=>(ArmActions.action moveTo @arm MHP_ARM_ESCAPE_OBJECT @armGoto @object NO_NAME NO_NAME 0 @objGoto OTHER @actionId))
	  )
   )
 (defop |moveToX|
   :invocation(ArmActions.action moveToX @arm  @x @y @z @actionId)
   :documentation "Moves the arm to the point specified"
   :body (
	  (!(ArmActions.checkAndEscapeObject @arm))
	  (!(ArmActions.getMoveParameters @task @object @support))
	  
	  (!(Mhp.makeArmGotoParameter 0 0 0 0 0 0 0 @armGoto))
	  (!(= @objGoto (objGoto (VAL @x) (VAL @y) (VAL @z) 0.0 0.0 0.0)))

	  (=>(ArmActions.action moveTo @arm @task @armGoto @object @support NO_NAME 15 @objGoto OTHER @actionId))
	  
	  )
   )


 (defop |moveToQ|
   :invocation(ArmActions.action moveToQ @arm  @q0 @q1 @q2 @q3 @q4 @q5 @q6 @pose @actionId)
   :documentation "Moves the arm to the q configuration"
   :body (
	  (!(ArmActions.checkAndEscapeObject @arm))
	  (!(ArmActions.getMoveParameters @task @object @support))	  
	  (!(Mhp.makeArmGotoParameter @q0 @q1 @q2 @q3 @q4 @q5 @q6 @armGoto))
	  (!(= @objGoto (objGoto 0.0 0.0 0.0 0.0 0.0 0.0)))

	  (=>(ArmActions.action moveTo @arm @task @armGoto @object @support NO_NAME 0 @objGoto @pose @actionId))
	  
	  )
   )


					;ARM_PICK_UP_GOTO FUNCTIONS
 (defop |moveToObject|
   :invocation(ArmActions.action moveToObject @arm @object @actionId)
   :documentation "Moves the arm in a pick position to a specified object"
   :body (
	  
	  (!(ArmActions.checkAndEscapeObject @arm))	  
	  (!(= @objStart (objStart 0.0 0.0 0.0 0.0 0.0 0.0)))
	  (!(= @objGoto (objGoto 0.0 0.0 0.0 0.0 0.0 0.0)))
	  (!(Mhp.makeArmGotoParameter 0 0 0 0 0 0 0 @armGoto))
	
	  (=>(ArmActions.action moveTo @arm MHP_ARM_PICK_GOTO @armGoto @object NO_NAME NO_NAME 0 @objGoto OTHER @actionId))

	  
	  
	  )
   )


 (defop |moveToPlaceObject|
   :invocation(ArmActions.action moveToPlaceObject @arm @placement @actionId)
   :documentation "moves to the placement position with the object"
   :body (
	  (!(ArmActions.checkAndEscapeObject @arm))
	  (?(Robot.pose (VAL @arm) @object @support @pose))
	  (IF(?(EQUAL @support NO_NAME))
	     (!(= @task MHP_ARM_PLACE_FROM_FREE))

	     ELSE
	     (!(= @task MHP_ARM_TAKE_TO_PLACE))
	     )
	  (!(Mhp.makeArmGotoParameter 0 0 0 0 0 0 0 @armGoto))
	  
	  ;get the position of the placement
	  (!(Spark.getFreeId @sparkId))
	  (=>(Spark.request getJointAbsPose @placement NO_NAME @sparkId))
	  (!(ArmActions.handleReport Spark @sparkId @actionId))
	  (^(Spark.result (VAL @sparkId) @xp @yp @zp @yawp @pitchp @rollp))
	  (~>(Spark.result (VAL @sparkId) (VAL @xp) (VAL @yp) (VAL @zp) (VAL @yawp) (VAL @pitchp) (VAL @rollp))) 
	  (!(= @objGoto (objGoto @xp @yp @zp 0.0 0.0 0.0)))

	  (=>(ArmActions.action moveTo @arm @task @armGoto @object @support @placement 9 @objGoto OTHER @actionId))
	  )
   )

 ;;ROBOT POSES

(defop |moveToRestPosition|
   :invocation(ArmActions.action moveToRestPosition @arm @actionId)
   :documentation "Goes to a rest pose with the arm nearby the body"
   :body (
	  (!(ArmActions.checkAndEscapeObject @arm))
	  (!(PRINT "going to rest position"))
;	  (=>(ArmActions.action moveToQ (VAL @arm)  0.6 0.4 -1.2 -1.0 0.0 -0.4 0.0 (VAL @actionId))) 
	  (=>(ArmActions.action moveToQ (VAL @arm) -1.7 -0.098069 -0.8 -1.8 0.5 -0.432614 -1.730387 REST (VAL @actionId)))

	  )
   )

 (defop |moveToExtendedPosition|
   :invocation(ArmActions.action moveToExtendedPosition @arm @q0 @actionId)
   :documentation "Utility function to extend the arm"
   :body (
	  (!(ArmActions.checkAndEscapeObject @arm))
	  (!(PRINT "going to extended position"))

	  (=>(ArmActions.action moveToQ (VAL @arm) @q0 0 0 0 0 0 0 EXTENDED (VAL @actionId)))

	  )
   )

 (defop |moveToReadyPosition|
   :invocation (ArmActions.action moveToReadyPosition @arm @q0 @actionId)
   :documentation "For now just utility function but should become an actual request. Goes to a rest pose with the arm nearby the body"
   :body (
	  (!(ArmActions.checkAndEscapeObject @arm))
	  (!(PRINT "going to ready position"))
	  (=>(ArmActions.action moveToQ @arm @q0 0.5 -0.4 -1.3 0.0 -0.5 0.0 READY (VAL @actionId)))
	  )
   )

(defop |moveToManipulationPosition|
  :invocation (ArmActions.action moveToManipulationPosition @actionId)
  :documentation "Moves to a position suitable for manipulation with the right arm"
  :body (
	 (!(ArmActions.checkAndEscapeObject @arm))
	 (=>(ArmActions.action moveToQ RIGHT -1.7 -0.098069 -0.8 -1.8 0.5 -0.432614 -1.730387 MANIPULATION (VAL @actionId)))
	 )
  )

 ;;GRIPPER FUNCTIONS


 (defop |closeGripper|
   :invocation(ArmActions.action closeGripper @gripper @actionId)
   :documentation "closes the gripper"
   :body (
	  (?(Softmotion.gripperClose (VAL @gripper) @state))
	  (=>(ArmActions.action useGripper  (VAL @state) (VAL @actionId)))
	  )
   )

 (defop |openGripper|
   :invocation(ArmActions.action openGripper @gripper @actionId)
   :documentation "opens the gripper"
   :body (
	  (?(Softmotion.gripperOpen (VAL @gripper) @state))
	  (=>(ArmActions.action useGripper  (VAL @state) (VAL @actionId)))
	  )
   )

 (defop |openGripperOnPressure|
   :invocation(ArmActions.action openGripperOnPressure @gripper @actionId)
   :documentation "opens the gripper"
   :body (
	  (?(Softmotion.gripperRelease (VAL @gripper) @state))
	  (=>(ArmActions.action useGripper (VAL @state) (VAL @actionId)))

	  )
   )
 (defop |useGripper|
   :invocation(ArmActions.action useGripper @state @actionId)
   :documentation "Moves the gripper to state @state"
   :body (
	  
	  (!(Softmotion.getFreeId @smId))
	  
	  (=>(Softmotion.request useGripper (VAL @state) (VAL @smId)))
	  (IF(?(EQUAL @state RRELEASE))
	     (=>(ArmActions.hasGripperReleaseRequest RIGHT (VAL @smId) (VAL @actionId)))
	     ELSEIF(?(EQUAL @state LRELEASE))
	     (=>(ArmActions.hasGripperReleaseRequest LEFT (VAL @smId) (VAL @actionId)))
	     
	     ELSEIF(?(EQUAL @state RGRAB))
	     (=>(ArmActions.hasGripperGrabRequest RIGHT (VAL @smId) (VAL @actionId)))
	     
	     ELSEIF(?(EQUAL @state LGRAB))
	     (=>(ArmActions.hasGripperGrabRequest LEFT (VAL @smId) (VAL @actionId)))
	     )
	  (!(ArmActions.handleReport Softmotion @smId @actionId))
	  (=>(ArmActions.report @actionId "OK")) 
	  
	  )
   )
(defop |stopOpenGripperOnPressure|
  :invocation (ArmActions.action stopOpenGripperOnPressure  @gripper @actionId)
  :documentation "Utility function to stop a gribber grab release request"
  :body (
	 (IF(?(ArmActions.hasGripperReleaseRequest (VAL @gripper) @smId @gripperActionId))
	     (=>(Softmotion.stop (VAL @smId)))
	     (^(Softmotion.report (VAL @smId) @report))
	     (^(ArmActions.report (VAL @gripperActionId) @report))
	     (~>(ArmActions.report (VAL @smGripperActionId) @report))
	     (~>(ArmActions.hasGripperReleaseRequest (VAL @gripper) (VAL @smId) (VAL @smGripperActionId)))
	     )
	  
	  (?(Softmotion.gripperCancel (VAL @gripper) @state))
	  (=>(ArmActions.action useGripper  @state (VAL @actionId)))
	  
	  )
   )

(defop |stopGripperGrab|
  :invocation(ArmActions.action stopGripperGrab @gripper @actionId)
  :documentation "Stops a gripper grab action"
  :body (
 	 (IF(?(ArmActions.hasGripperGrabRequest (VAL @gripper) @smId @gripperActionId))
	    (IF(?(Robot.gripperStatus (VAL @gripper) WAITING_CONTACT))
	       (=>(Softmotion.stop (VAL @smId)))
	       (^(Softmotion.report (VAL @smId) @report))
	       (^(ArmActions.report (VAL @gripperActionId) @report))
	       (~>(ArmActions.report (VAL @smGripperActionId) @report))
	       )
 	    (~>(ArmActions.hasGripperGrabRequest (VAL @gripper) (VAL @smId) (VAL @smGripperActionId)))
 	     )
	 (IF(?(Robot.gripperStatus (VAL @gripper) WAITING_CONTACT)))
	    (?(Softmotion.gripperCancel (VAL @gripper) @state))
	    (=>(ArmActions.action useGripper  @state (VAL @actionId)))
	    (=>(ArmActions.report @actionId "OK"))
	    )
  )

(defop |gripperGrab|
  :invocation(ArmActions.action gripperGrab @gripper @actionId)
  :documentation "Closes the gripper when pressure sensor detect something"
  :body (
	 (?(Softmotion.gripperGrab (VAL @gripper) @state))
	 (=>(ArmActions.action useGripper (VAL @state) (VAL @actionId)))
	 
	 )
  
  )

(defop |detectPression|
  :invocation(ArmActions.action detectPression @gripper @mode @actionId)
  :documentation "Detects when there is a pressure in the gripper. Mode can be GRAB or RELEASE. I don't
actually know if this really changes something... pressure is pressur."
  :body (
	 (IF(?(EQUAL @mode GRAB))
	    (?(Softmotion.gripperGrab (VAL @gripper) @state))
	    ELSE 
	    (?(Softmotion.gripperRelease (VAL @gripper) @state))
	 )
	  (!(Softmotion.getFreeId @smId))
	  (=>(Softmotion.request detectPression @state @smId))
	  (=>(ArmActions.hasDetectPressionRequest (VAL @gripper) (VAL @mode) (VAL @smId))) ;remember the request for stopdetectPressionRequestes
	  (!(ArmActions.handleReport Softmotion @smId @actionId))
	  (=>(ArmActions.report @actionId "OK")) 
	  (~>(ArmActions.hasDetectPressionRequest (VAL @gripper) (VAL @mode) (VAL @smId)))

	 
	 )

  )

(defop |stopDetectPression|
  :invocation(ArmActions.action stopDetectPression @gripper @mode @actionId)
  :documentation "Stops a detect pression request"
  :body (
	 (IF(?(ArmActions.hasDetectPressionRequest (VAL @gripper) (VAL @mode) @detectPressionId))
	    (~>(ArmActions.hasDetectPressionRequest (VAL @gripper) (VAL @mode) @detectPressionId))
	    (?(Softmotion.gripperCancel (VAL @gripper) @state))
	    (!(Softmotion.getFreeId @smId))
	    (=>(Softmotion.request detectPression @state @smId))
	    (^(Softmotion.report (VAL @smId) @report))
	    )
	 (=>(ArmActions.report @actionId "OK"))
	 )
  
)

(defop |checkAndEscapeObject|
  :invocation(!(ArmActions.checkAndEscapeObject @arm))
  :documentation "checks if there is an object near the arm and eventually escapes it"
  :body (
	 (?(Robot.pose (VAL @arm) @object @support @pose))
	 (IF(?(~(EQUAL @object NO_NAME)))
	    (IF(?(~(Robot.hasObject (VAL @arm) (VAL @object))))
	       (!(ArmActions.getFreeId @escapeId))
	       (=>(ArmActions.action escapeObject (VAL @arm) (VAL @object) @escapeId))
	       (^(ArmActions.report (VAL @escapeId) @report))
	       (~>(ArmActions.report (VAL @escapeId) (VAL @report)))
	       
	       )
	    )
	 )
  )


  (defop |handleReport|
     :invocation(!(ArmActions.handleReport @module @id @actionId))
     :documentation "Utility function to avoid some code duplication when waiting for the response of a genom module. This can't be used when we don't want to fail if the genom request fails"
     :body (
	  (!(= @reportName (TERM-STRING-CAT (VAL @module) ".report")))
	  (!(= @reportName (MAKE-ATOM @reportName)))

	  ;wait for a report or until we are paused or until we are stopped
	  (^(|| (@reportName (VAL @id) @report) (ArmActions.halt (VAL @actionId)) (ArmActions.stop (VAL @actionId))))
		
	  ;if we are paused we give a halt request if we were doing a softmotion request or simply wait for a resume
	  (IF(?(ArmActions.halt (VAL @actionId)))
	     (~>(ArmActions.halt (VAL @actionId)))
	     (IF(?(EQUAL @module Softmotion))
		(!(Softmotion.getFreeId @smId))
		(=>(Softmotion.request halt (VAL @smId)))
		(^(Softmotion.report (VAL @smId) @smReport))
		(~>(Softmotion.report (VAL @smId) (VAL @smReport)))
		(^(@reportName (VAL @id) @report))
		(~>(@reportName (VAL @id) (VAL @report)))
		)
	     ;we wait for a stop or for a resume
	     (^(|| (ArmActions.stop (VAL @actionId)) (ArmActions.resume (VAL @actionId))))
	     (IF(?(ArmActions.resume (VAL @actionId)))   ;we ask to resume and recall this function to wait for the report
		(~>(ArmActions.resume (VAL @actionId)))
		(IF(?(EQUAL @module Softmotion))
		     (!(Softmotion.getFreeId @smId))
		     (=>(Softmotion.request resume @smId))
		     (^(Softmotion.report (VAL @smId) @smReport))
		     (~>(Softmotion.report (VAL @smId) (VAL @smReport)))
		     (^(ELAPSED-TIME (TIME) 3))
		     )

		)

	     ELSEIF(?(ArmActions.stop (VAL @actionId)))
	     (~>(ArmActions.stop (VAL @actionId)))
	     
	     (IF(?(EQUAL @module Softmotion))
		;;we stopx
		(=>(Softmotion.stop (VAL @id)))    
		(!(Softmotion.getFreeId @smId))
		(=>(Softmotion.request stop (VAL @smId)))
		(^(Softmotion.report (VAL @smId) @smReport))
		(~>(Softmotion.report (VAL @smId) (VAL @smReport)))
	      
		ELSEIF(?(EQUAL @module Mhp))
		(=>(Mhp.stop (VAL @id)))
		)
	     ;we wait for the stopped report and then fail
	     (^(|| (@reportName (VAL @id) @report)))
	     (~>(@reportName (VAL @id) @report))
	     (=>(ArmActions.report @actionId STOPPED))
	     (!(FAILED))
	    
	     
	     ELSE	 ;we got a report. If it's a good report we continue if not we report a fail and exit.
	     (~>( @reportName (VAL @id) (VAL @report)))
	     (IF(?(~(EQUAL @report "OK")))
		(!(PRINT @report))
		(=> (ArmActions.report (VAL @actionId) @report))
		(!(FAILED))
		)
	     )
	  )
     )

)



