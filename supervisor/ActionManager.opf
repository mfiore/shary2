;; -*-Lisp-*-
;;author: Michelangelo Fiore
;; this file contains procedures for the ActionManager, the module responsible to manage the robot actions.
(

(defop |init|
  :invocation (!(ActionManager.init))
  :documentation "inits the queue of the module"
  :body (
	 (!(Queue.init ActionManager.queue))
	 (=>(ActionManager.isStopped FALSE))
	 (=>(ActionManager.isCanceled FALSE))
	 )
)
 (defop |AddActionListToQueue|
   :invocation (!(ActionManager.addActionListToQueue @actionList @id))
   :documentations "this procedure takes a list of actions as input and puts them into the action queue"
   :body (
	  (WHILE(?(~(NULL @actionList)))
		(!(= @action (CAR @actionList)))
		(!(= @actionList (CDR @actionList)))
		(!(= @id (+ @id 1)))
		(!(Queue.push (. @action @id .) ActionManager.queue))
				
		)
	  )
   )
 (defop |ActionLoop|
   :invocation (actionList.isEmpty FALSE)
   :documentation "this procedure is the main loop for the Action Manager. The procedure starts automatically when there are actions to manage. It communicates with the Monitor Manager and Execution Manager to achieve them.
A big mistep of this module is that at the moment we can't execute an action while we monitor something else. THIS NEEDS TO BE CORRECTED. A solution would be to insert other postconditions in the monitor manager (for example
a correct result from the execution manager)"
   :body (
	  
	  (WHILE(?(ActionManager.actionList isEmpty FALSE))  ;;while there are actions to execute
		(^ (& (ActionManager.isStopped FALSE) (ActionManager.isCanceled FALSE) (Queue.isEmpty ActionManager.queue FALSE))   ;; wait until it's not stopped, not canceled and has still actions to execute. This canceled should be handled better and in some RARE cases could provide problems
		   
		   (!(Queue.head @head ActionManager.queue))
		   (!(== (VAL @head) (. @action @id .)))
		
		   ;;get the values of the action
		   (! (== (VAL @action) (ACTION (ACTION-ID @actionId) (ACTION-NAME @actionName) (ACTOR @actor) (START-TIME @startTime) (END-TIME @endTime) (PARAMETERS @actionParameters))))
		
		   (?(ExecutionManager.freeId @executionId))
		   
		   (=>(ExecutionManager.execute @actionName @executionId))
		   (^(||(ExecutionManager.result @executionId @result) (ActionManager.isStopped TRUE) (ActionManager.isCanceled TRUE)))   ;;TO IMPLEMENT
		   )
		(IF(?(ActionManager.isStopped TRUE))
		   (IF(?(ExecutionManager.isExecuting @id))
		      ((!(SEND-MESSAGE @executionManager (STOP @executionId))))
		      (^(ExecutionManager.result @executionId @result))
		      
		      )
		   )
		(IF(?(ExecutionManager.result @id ACHIEVED))
		   (!(Queue.pop ActionManager.queue))
	    	   
		   )
		(IF(?(ExecutionManager.result @id FAILED))
		   (!(Queue.init ActionManager.queue)))  ;;we reset the queue, waiting for replanning. Maybe we could try different strategies for execution here.
		   )
		(IF(?(ActionManager.isCanceled TRUE))
		   (!(Queue.init ActionManager.queue))
		   (!(= @result @id CANCELED))
		     
		   )
		(IF(?(ActionManager.isStopped TRUE))
		   (!(= @result @id STOPPED))
		   )

		(=> (ActionManager.result @id @result))

		)
	  )
   )
)
