;; -*-Lisp-*-
;;author: Michelangelo Fiore
;;This file contains procedures to handle a priority queue in a thread-safe way. Element are ordered from lowest priority (head) to highest (tail)
;; Queue elements must be lisp-lists where the last element is the priority. In general they could be list like (. (. actual element .) priority .)


(
 
 (defop |init| 
   :invocation (!(PriorityQueue.init $queueName))
   :documentation "creates an empty queue"
   :body (
	  (=>($queueName (. .)))
	  (=>(PriorityQueue.isEmpty $queueName TRUE))

	  (!(SEM-CREATE $queueName 1 SEM-FIFO)) 
	  
	  (=>(PriorityQueue.lowestPriority $queueName 0))
	  (=>(PriorityQueue.highestPriority $queueName 0))
	  )
   )
 (defop |push|
  :invocation (!(PriorityQueue.push $newElement $queueName))
  :documentation "adds an element to the queue"
  :body (
	 (!(SEM-P $queueName)) 
	 
	 
	  
	  ;;get the values of the element to add
	  (!(== (VAL $newElement) (. @newElementData @newElementPriority .)))
	  (?($queueName @originalQueue))  ;;get the queue
	  (!(= @queue (VAL @originalQueue)))  ;we need to versions of the queue, one that is going to be modified and one for comparisons at the end of the algorithm
	  (!(= @done FALSE))
	  (!(= @prevElements (. .)))
	  
	  (WHILE(?(EQUAL @done FALSE)) ;;in this loop we are going to put the new element at the correct position, based on the priority. The variable @queue is going to shrink and we are going to save every element before $queueElement into @prevElements and the rest of the queue+$queueElements in @queue. After the while we will join these lists.
		(IF(?(~(NULL @queue)))  ;;if there are still elements in the queue 
		   (!(= @actualElement (CAR @queue)))  
		   (!(== (VAL @actualElement) (. @actualElementData  @actualElementPriority .)))
		   
		   (IF(?(< @newElementPriority @actualElementPriority)) ;;the new element should be the head of the queue
		      (!(= @queue (CONS $newElement @queue)))
		      (!(= @done TRUE))
		      ELSE
		      (IF(?(NULL @prevElements))  ;;we are in the middle of the queue. We must record the elements until this point into another list
			 (!(= @prevElements (.(CAR @queue).)))
			 
			 ELSE
			 (!(= @prevElements (CONS-TAIL (CAR @queue) @prevElements )))
			 
			 )
		      (!(= @queue (CDR @queue))) ;;and erase the current element from the list
		      )  		
		   
		   ELSE
		   (!(= @queue (. (VAL $newElement) .))) ;;we are at the end of the queue. 
		   (!(= @done TRUE))
		   )
		)
	  (IF(?(~( NULL @prevElements))) ;;the element has not been inserted in front of the queue
	     (!(= @newQueue  @prevElements))
	     (!(= @newQueue (REVERSE @newQueue)))   ;;the reverse are put for a strange behavior of the LISP-UNION which appereantly reverses the two lists before uniting them
	     (!(= @queue (REVERSE @queue)))
	     (!(= @newQueue (LIST-UNION @queue @newQueue)))
	     
	     
	     ELSE
	     (=> (PriorityQueue.lowestPriority $queueName @newElementPriority))  ;;if the element is the new head than it has the lowest priority
	     (!(= @newQueue (VAL @queue)))
	     )
	  (IF(?(EQUAL @prevElements @originalQueue)) ;;the element is the new tail so it has the highest priority
	     (=> (PriorityQueue.highestPriority $queueName @newElementPriority))
	     )
	  (=> ($queueName @newQueue))
	  (IF(?(PriorityQueue.isEmpty (VAL $queueName) TRUE))
	     (=> (PriorityQueue.isEmpty $queueName FALSE))   ;;the queue is not empty anymore
	     )
	  
	  
	  (!(SEM-V $queueName))
	  )
 )
 (defop |pop|
   :invocation (!(PriorityQueue.pop $queueName))
   :documentation "pops the first element of the queue"
   :body (
	 
	  (!(SEM-P $queueName))
	  
	  (?($queueName @queue))
	  (!(= @queue (CDR @queue)))    
	  (IF(?(NULL @queue))
	     (=> (PriorityQueue.isEmpty $queueName TRUE))
	     ELSE
	     (!(= @head (CAR @queue)))
	     (!(== (VAL @head) (. @queueElement @priority .)))
	     (=> (PriorityQueue.lowestPriority $queueName @priority)) ;the new head has the lowest priority
	     )
	  (=>($queueName @queue))
	  (!(SEM-V $queueName))
	  )
   )
 (defop |head|
   :invocation (!(PriorityQueue.head $head $queueName))
   :documentation "returns in $head the first element of the queue."
   :body (
	  (!(SEM-P $queueName))

	  (?($queueName @queue))
	  (!(= $head (CAR @queue)))
	    
	  (!(SEM-V $queueName))
	  )
   )
 )
