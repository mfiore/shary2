;; -*-Lisp-*-
;;author: Michelangelo Fiore
;;this files contains procedures to move the robot

(

(defop |init|
  :invocation(!(BaseActions.init))
  :documentation "Inits the module"
  :body (
	 (=>(BaseActions.freeId 0))
	 (!(SEM-CREATE BaseActions.sem 1 SEM-FIFO))
	 )
  )

(defop |getFreeId|
  :invocation(!(BaseActions.getFreeId $id))
  :documentation "returns an available id for requestes"
  :body (
	 (!(SEM-P BaseActions.sem))
	 (?(BaseActions.freeId $id))
	 (=>(BaseActions.freeId (+ $id 1)))
	 (!(SEM-V BaseActions.sem))
	 )
  )
(defop |move|
  :invocation(BaseActions.action move @waypoints @id)
  :documentation "moves the robot through a list of waypoints"
  :body (
	 (!(SEM-P BaseActions.sem))
	 (?(BaseActions.bridgeName @name))
	 (?(BaseActions.timeToWait @time))
	 (!(SEND-MESSAGE @name (move @waypoints)))  ;;contact the ros module to start the navigation
	 (!(= @nextLocation (CAR @waypoints)))
	 (!(= @waypoints (CDR @waypoints)))
	 (!(= @completed FALSE))
	 (WHILE(?(EQUAL @completed FALSE)) ;;we loop until we complete the navigation or we fail
	       ;;we wait for the final response of the module, for an update, for a stop command or if too much time passes withouth receiving updates
	       (^(|| (BaseActions.response (VAL @name) @response) (BaseActions.update (VAL @name) @status) (BaseActions.stop (VAL@id)) (ELAPSED-TIME (TIME) @time)))  

	       ;;if stopped we... stop! surprise! 
	       (IF(?(BaseActions.stop (VAL @id)))
		  (!(BaseActions.stop))
		  (=>(BaseActions.report @id "STOPPED"))
		  
		  ;;if we receive an update we update the robot location to the next waypoint 
		  ELSEIF(?(BaseActions.update (VAL @name) OK))
		  (=>(Robot.location (VAL @nextLocation)))
		  (!(= @nextLocation (CAR @waypoints)))
		  (!(= @waypoints (CDR @waypoints)))
		  
		  ;;if we have a response we issue a report and quit
		  ELSEIF(?(BaseActions.response (VAL @name) OK))
		  (=>(BaseActions.report @id "OK"))   
		  (!(= @completed TRUE))
		  ELSE
		  (=>(BaseActions.report @id "FAILURE"))
		  (!(= @completed TRUE))
		  )
	       )
	 (~>(BaseActions.response @name @response))
	 (!(SEM-V BaseActions.sem))
	 )
  )

(defop |stop|
  :invocation(BaseActions.action stop @id)
  :documentation "halts the robot movement"
  :body (
	 (?(BaseActions.bridgeName @name))
	 (?(BaseActions.timeToWait @time))
	 (!(SEND-MESSAGE @name (stop)))
	 (^(||(BaseActions.response (VAL @name @response) (ELAPSED-TIME (TIME) @time))))  ;;could lead to inconsistency if we issue a message and we reach elapsed time. But I guess if we reach elapsed time after sending a stop and the robot is still moving then it could be wise to ignore the code and run to the security switch =)
	 (~>(BaseActions.response @name @response))
	 (=>(BaseActions.report @id "OK"))
	 )
  )



   
)
