;; -*-Lisp-*-
;;author: Michelangelo Fiore
;;this files contains procedures to manage plans in the supervision system.

(

 (defop |unificationTry|
   :invocation (!(unificationTry))
   :documentation
   :body (
	  (!(= @fact (. a b c .)))
	  (!(== (VAL @fact) (. @a @b @c .)))
	  (!(PRINT @a))
	  
	  )
   )
 (defop |managePlans|
   :invocation (!(PlanManager.managePlans))
   :documentation "this is the main procedure of the Plan Manager. It's constantly running, receiving goals from the higher level, asking the planner for plans, breaking them into actions and sending those to the Action Manager
                  for execution"
   :body (
					;get the constants for failures
	  (?(MAX_PLANNING_WAIT $MAX_PLANNING_WAIT))
	  (?(MAX_PLANNING_FAILURES $MAX_PLANNING_FAILURES))
	  (?(TIME_TO_RETRY $TIME_TO_RETRY))
	  (WHILE(?(PlanManager.shouldRun true))
					;wait until you receive a goal (a registered event from the DB) or the system is shut down. At the moment we have a single goal at a time but we could implement a priority mechanism.
		(^ (|| (PlanManager.newGoal true) (PlanManager.shouldRun false)))                                                                            
		(IF(?(PlanManager.newGoal true))
		   (=>(PlanManager.newGoal false)) ;we are managing the goal so it's not new anymore
		   (!(= @planningFailures 0))
		   (!(Database.findLast goal))     ;find the last received goal in the Database
		   (?(Database.result @status @result)) 
		   (~> (Database.result @anyStatus @anyResult)) 
		   (IF(?(EQUAL @status OK))  ;the else is not handled. It would mean it's a mistake and we don't have a goal in the Database so we go back at waiting    
		      (!(= @goal (last @result)))             
		      (? (Planner.result @plannerResult))
		      (WHILE(?(& (~ (EQUAL @plannerResult ACHIEVED)) (< @planningFailures $MAX_PLANNING_FAILURES))) 
					;note that achieved is obtained by the planner. Even when we execute all the actions the system 
					;calls again the planner to see if the plan has actually been completed.
			    (~>(Planner.result @plannerResult)) 
			    (=>(Planner.createPlan @goal))
			    (^(|| (Planner.result @plannerResult) (ELAPSED-TIME (TIME) $MAX_PLANNING_WAIT)))
			    (IF(?(EQUAL @plannerResult OK))  ;we have a plxan and we can proceed
			       	;the plan is a list of actions for the human and for the robot. Note: the idea is that this plan can be produced by the robot or by the human. Perhaps the planner could take into account
				;the possibility that the human creates the plan so that the PlanManager uses the same interface. At the moment we don't take into account the possibility that the robot observes the
				;user and starts helping him. This would require a good reasoner and maybe a different kind of planner. The robot and human act simultaneously at the moment.
			       (?(Planner.plan @plan))
			       (!(= @robotActions (CAR @plan))) 
					;the robot and user actions are divided between the Monitor Manager and Action Manager
			       (=> (MonitorManager.humanActionMonitorStatus NOT_STARTED))
			       (=> (MonitorManager.humanActions (last @plan)))  
			       (WHILE (? (~ (NULL @robotActions)))  ;there are still actions.
				      (!(= @currentRobotAction (CAR @robotActions)))  
				      (~> (ActionManager.result @actionManagerStatus))
				      (=> (ActionManager.action @currentRobotAction))
				      (^ (ActionManager.result @actionManagerStatus))
				      (IF(? (EQUAL @actionManagerStatus OK))
					 (!(= @robotActions (CDR @robotActions))) ;removes the robot action from the list since it's been executed correctly.
					  
					 ELSEIF(? (EQUAL @actionManagerStatus ERROR))
					 (!(= @planningFailures (+ planningFailures 1)))
					 (^ (ELAPSED-TIME (TIME) $TIME_TO_RETRY))
					  
					 ELSE    ;we have a critical error. We set to MAX_PLANNING_FAILURE so that the system doesn't replan.
					 (!(= @planningFailures $MAX_PLANNING_FAILURES))
					 )
				      )
			       (^ (|| (MonitorManager.humanActionMonitorStatus ACHIEVED) (MonitorManager.humanActionMonitorStatus ERROR)))
				;(IF(?(MonitorManager.humanActionMonitorStatus ERROR)) ;we don't wait because we assume that the monitor manager calls error after this having already waited for the human to realize the action.
	;		   	  (!(= @planningFailures (+ planningFailures 1)))    ;should we actually increase planning failures here? 
				 ; )					
				
			       ELSEIF(? (~ (EQUAL @plannerResult ACHIEVED)))
			       (!(= @planningFailures (+ planningFailures 1)))
			       (^ (ELAPSED-TIME (TIME) $TIME_TO_RETRY))
			       ) 
			    )
		    ;the plan has been completed. There should be some verbalization.	   			
		      )
		   )
		)
	  )	 
   )
 )
