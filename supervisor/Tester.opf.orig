; -*-Lisp-*-
;;author: Michelangelo Fiore

;;This file contains procedures to test the single modules of the
;system.

(

 (defop |testTablet|
   :invocation(!(Tester.testTablet))
   :body (
	  (!(Controller.initAll))
	  (=>(TabletConnector.shouldRun TRUE))
	  (!(TabletConnector.getCommand))
	  )
   )
 (defop |testStringCat|
   :invocation(!(Tester.testStringCat))
   :body (
	  (!(= @a "take" ))
	  (!(= @b "object"))
	  (!(= @c (TERM-STRING-CAT @a " " @b)))
	  (!(PRINT @c))
	  )
   )
 (defop |testDatabaseMonitor|
   :invocation (!(Tester.testDbMonitor))
   :body (
;	  (!(DatabaseInterface.addMonitor (Prova a @var) (event) @result))
;	  (!(DatabaseInterface.add (Prova a b) @result))


	  )
   )
 (defop |testMonitorSpheres|
   :invocation (!(Tester.testMonitorSpheres))
   :body (
	  (!(Controller.initAll))

	  (!(AgentActionMonitor.activateMonitorSpheres (. GREY_TAPE PINK_TRASHBIN .) HERAKLES_HUMAN1))
;	  (^(ELAPSED-TIME (TIME) 1))
;	  (!(AgentActionMonitor.cleanMonitorSphere 1))
;	  (^(ELAPSED-TIME (TIME) 1))
;	  (!(AgentActionMonitor.cleanAgentMonitorSpheres HERAKLES_HUMAN1))
	  (=>(AgentActionMonitor.startMonitorSphereLoop))
	  
	  )
   )

 (defop |testPlan|
   :invocation(!(Tester.testPlan))
   :body (
	  (!(Controller.initAll))
	   (=>(PlanManager.goal Clean (. META_TABLE .)))
	   (=>(PlanManager.newGoal TRUE))
	   (=>(PlanManager.managePlans))
	  )
   )
 (defop |testFactPoster|
   :invocation(!(Tester.testFactPoster))
   :body (
	  (!(Attention.init))
	  (!(Attention.posterLoop))
	  )
   )
 
 ;; (defop |testPlan| 
 ;;   :invocation(!(Tester.testPlan))
 ;;   :body (
 ;; 	  (!(Controller.initAll))
 ;; 	  (=>(PlanManager.newGoal TRUE))
 ;; 	  (=>(PlanManager.goal provaGoal))
 ;; 	  (=>(PlannerInterface.report OK))
 ;; 	  (!(= @actionTake (. take (. GREY_TAPE NO_NAME NO_NAME 300 .) .)))
	  
 ;; 	  (!(= @action1 (. (VAL @actionTake) 1 (. .) .)))
 ;; 	  (!(= @actionThrow (. throw (. GREY_TAPE TABLE_4 PINK_TRASHBIN 300 .) .)))
 ;; 	  (!(= @action2 (. (VAL @actionThrow) 2 (. 1 .) .)))
 ;; 	  (=>(PlannerInterface.result (. (. (VAL @action1) (VAL @action2) .) (. .) .)))
 ;; 	  (=>(PlanManager.managePlans))
 ;; 	  (^(PlanManager.actionReport 1 @report))
 ;; 	  (=>(PlannerInterface.report ACHIEVED))
 ;; 	  )
 ;;   )

 (defop |testPlace|
   :invocation(!(Tester.testPlace))
   :body (
	  (!(Controller.initAll))
	  (=>(Robot.hasObject RIGHT GREY_TAPE))
	  (=>(Robot.armPosition RIGHT FREE))
	  (=>(ExecutionManager.execute placeObject GREY_TAPE TABLE_4 PLACEMAT_BLUE 1))
	  )
   )

 (defop |testArmActions|
   :invocation(!(Tester.testArmActions))
   :documentation "PLACE OBJECT HAS NOT BEEN TESTED "
   :body (
	  (!(ArmActions.init))
	  (!(Controller.initAll))
	  (=>(Robot.armInAir RIGHT TRUE))


;	  (!(PRINT "MovetoX"))
;	  (=>(ArmActions.action moveToX RIGHT 3.3 2.65 1.2 1))
;	  (^(ArmActions.report 1 @report))
;	  (~>(ArmActions.report 1 @report))
	  (!(Tester.breakpoint))
	  (!(PRINT "MoveToQ"))
	  (=>(ArmActions.action moveToQ RIGHT NO_NAME NO_NAME 0 0 0 0 0 0 0 1))
	  (^(ArmActions.report 1 @report))
  	  (~>(ArmActions.report 1 @report))
	  
	  (!(PRINT "MoveToObject"))
	  (=>(ArmActions.action moveToObject RIGHT GREY_TAPE 1))
	  (^(ArmActions.report 1 @report))
	  (~>(ArmActions.report 1 @report))
	
	  (!(PRINT "EscapeObject"))
	  (=>(ArmActions.action escapeObject RIGHT GREY_TAPE 1))
	  (^(ArmActions.report 1 @report))
	  (~>(ArmActions.report 1 @report))

	 ; (=>(ArmActions.action gotoPlaceObject RIGHT GREY_TAPE TABLE_4 NO_NAME 1))
	  ;(^(ArmActions.report 1 @report))

	  (!(PRINT "MoveToRest"))
	  (=>(ArmActions.action moveToRestPosition RIGHT 1))
	  (^(ArmActions.report 1 @report))
	  (~>(ArmActions.report 1 @report))

	  (!(PRINT "MoveToReady"))
	  (=>(ArmActions.action moveToReadyPosition RIGHT 0 1))
	  (^(ArmActions.report 1 @report))
	  (~>(ArmActions.report 1 @report))	  


	  (!(PRINT "MoveToExtended"))
	  (=>(ArmActions.action moveToExtendedPosition RIGHT 0 1))
	  (^(ArmActions.report 1 @report))
	  (~>(ArmActions.report 1 @report))
	  )
   )

(defop |testGripperActions|
  :invocation(!(Tester.testGripperActions))
  :body (

	  (=>(ArmActions.action closeGripper RIGHT 1))
	  (^(ArmActions.report 1 @report))


	  (=>(ArmActions.action openGripper RIGHT 1))
	  (^(ArmActions.report 1 @report))

	  (=>(ArmActions.action openGripperOnPressure RIGHT 1))
	  (^(ArmActions.report 1 @report))

	  (=>(ArmActions.action stopOpenGripperOnPressure RIGHT 1))
	  (^(ArmActions.report 1 @report))
	 )
  )

(defop |testHeadActions|
  :invocation(!(Tester.testHeadActions))
  :body (
	 (!(HeadActions.init))
	 (!(Controller.initAll))

	 (=>(HeadActions.action lookAt GREY_TAPE NO_NAME 1))
	 (^(HeadActions.report 1 @report))
	 )
  )
 
 (defop |testString|
   :invocation(!(Tester.testString))
   :body (
	  (!(= @a MonitorQueue.priorityQueue))
	  (!(= @b (TERM-STRING-CAT @a "Sem")))
	  (!(PRINT @b))
	  (!(SEM-CREATE (VAL @b) 1 SEM-FIFO))
	  (!(SEM-P (VAL @b)))
	  (!(SEM-V (VAL @b)))
	  )
   )
 (defop |testGenomInterface|
   :invocation(!(Tester.testGenomInterface))
   :body (
	  (=>(Softmotion.request useGripper RRELEASE 1))
	  (^(Softmotion.report 1 @report))
	  (!(PRINT @report))
	  )
   )
 (defop |testObservations|
   :invocation(!(Tester.testObservations))
   :documentation
   :body (
	  (?(Spark.robotTorso @rTorso))
	 (?(Spark.robotName @sparkRobotName))

	  
	 (?(Spark.freeId @sparkId))
	 (=>(Spark.request getJointAbsPose (VAL @sparkRobotName) (VAL @rTorso) (VAL @sparkId)))
	 (!(ExecutionManager.handleReport Spark.report @sparkId @executionId))
	 (?(Spark.result (VAL @sparkId) @robotTorsoX @robotTorsoY @robotTorsoZ @robotTorsoYaw @robotTorsoPitch @robotTorsoRoll))
	 (~>(Spark.result (VAL @sparkId) (VAL @robotTorsoX) (VAL @robotTorsoY) (VAL @robotTorsoZ) (VAL @robotTorsoYaw) (VAL @robotTorsoPitch) (VAL @robotTorsoRoll)))
	 (=>(ExecutionManager.oldArmPosition unknown))
	 (=>(ExecutionManager.oldDistance outOfRange))
	 (=>(ExecutionManager.oldOrientation unknown))
	 (!(= @i 0))
	 (WHILE(?(~(EQUAL @i 10)))
					;Set the starting state variables. We need to get the first row of observations to set the state variable inRange
	       (!(ExecutionManager.getHumanObservations HERAKLES_HUMAN1 @robotTorsoX @robotTorsoY @robotTorsoZ 1 @armPosition @distance @orientation))
	       (^(ELAPSED-TIME (TIME) 1))
	       (!(= @i (+ @i 1)))
	       )
	 )
   )
 (defop |testMonitorHead|
   :invocation(!(Tester.testMonitorHead))
   :body (
	  (?(Spark.humanHead @head))
	  (!(MonitorManager.init))
	  (!(MonitorManager.monitorTarget HERAKLES_HUMAN1 @head (. (. (fact) .) (. .) .) (. (. .) (. .) .) 1 1)) 
		    
	  )
   )

 (defop |testGive|
   :invocation(!(Tester.testGive))
   :documentation " "
   :body (
	  (!(Controller.initAll))
	  (=>(Robot.hasObject GREY_TAPE RIGHT))
	  (=>(ExecutionManager.execute handover give GREY_TAPE HERAKLES_HUMAN1 1))

	    
	  )
   )

(defop |testGrab|
  :invocation(!(Tester.testGrab))
  :documentation " "
  :body (
	 (!(Controller.initAll))
	 (=>(ExecutionManager.execute handover take GREY_TAPE HERAKLES_HUMAN1 1))
	 )
  )
 (defop |testFailed|
   :invocation(!(Tester.testFailed))
   :documentation " "
   :body (
	  (!(Tester.supportTestFailed))
	  (^ (fact))
	  )
   )

 (defop |supportTestFailed|
   :invocation(!(Tester.supportTestFailed))
   :documentation " "
   :body (
	  (!(FAILED))
	  )
   )
 (defop |testGeneric|
   :invocation (!(Tester.testGeneric))
   :documentation " "
   :body (
	 ;works if fact with no || or && and wait or if with variable and not VAL. 
	  ;weirder and weirder. If we have a composed term it works with VAL...
	  (!(= @a (fact)))
	  (IF(?(VAL @a))
	     (!(PRINT "ok"))
	     )
	  ;(!(Tester.testGeneric2 FALSE))
	  )
   )
 (defop |testGeneric2|
   :invocation (!(Tester.testGeneric2 @a))
   :documentation ""
   :body (
	  (^ (|| (fact) (VAL @a )))
	     (!(PRINT "ok"))
	     
	     )
   )
 (defop |testWhile|
   :invocation(!(Tester.testWhile))
   :body (
	  (!(= @a 0))
	  (WHILE(?(~(fact (VAL @a))))
		(!(= @a (+ @a 1)))
		)
	  )
   )

 (defop |testTake|
   :invocation (!(Tester.testTake))
   :documentation ""
   :body (
	  (!(Controller.initAll))
	  (?(Spark.freeId @sparkId))
	  (=>(Spark.request setGraspedObject GREY_TAPE 0 0 (VAL @sparkId)))
	  (!(ExecutionManager.handleReport Spark.report @sparkId @executionId))

	  (?(Spark.freeId @sparkId))
	  (=>(Spark.request setInferrenceForObject GREY_TAPE 0 PR2_ROBOT 0 SPARK_PRECISE_ROBOT_HAND 1.0 (VAL @sparkId)))  
	  (!(ExecutionManager.handleReport Spark.report @sparkId @executionId))
	  
	  (=>(ExecutionManager.execute take GREY_TAPE RIGHT 1))

	  )
   )
(defop |testTakeThrow|
  :invocation(!(Tester.testTakeThrow))
  :documentation " "
  :body (
	  (!(Controller.initAll))
	  (?(Spark.freeId @sparkId))
	  (=>(Spark.request setGraspedObject GREY_TAPE 0 0 (VAL @sparkId)))
	  (!(ExecutionManager.handleReport Spark.report @sparkId @executionId))

	  (?(Spark.freeId @sparkId))
	  (=>(Spark.request setInferrenceForObject GREY_TAPE 0 PR2_ROBOT 0 SPARK_PRECISE_ROBOT_HAND 1.0 (VAL @sparkId)))  
	  (!(ExecutionManager.handleReport Spark.report @sparkId @executionId))
	  
	  (=>(ExecutionManager.execute take GREY_TAPE RIGHT 1))
	  
	  (^(ExecutionManager.report (VAL @executionId) @report))
	  
	  (=>(ExecutionManager.throw GREY_TAPE PINK_TRASHBIN 2))
	  )
  )

(defop |testThrow|
  :invocation(!(Tester.testThrow))
  :body (
	 (!(Controller.initAll))
	 ;; (?(Spark.freeId @sparkId))
	 ;; (=>(Spark.request placeObjectForSimu GREY_TAPE 0 0 0 0 0 0 1 (VAL @sparkId)))
	 ;; (!(ExecutionManager.handleReport Spark.report @sparkId 1))
	  
	 ;;  (?(Spark.robotHand RIGHT @sparkHand))
	 ;;  (?(Spark.freeId @sparkId))
	 ;;  (=>(Spark.request setGraspedObject GREY_TAPE 1 (VAL @sparkHand) (VAL @sparkId)))
	 ;;  (!(ExecutionManager.handleReport Spark.report @sparkId 1))
	  
	 ;;  (?(Spark.freeId @sparkId))
	 ;;  (=>(Spark.request setInferrenceForObject GREY_TAPE 1 PR2_ROBOT (VAL @sparkHand) SPARK_PRECISE_ROBOT_HAND 1.0 (VAL @sparkId)))  
	 ;;  (!(ExecutionManager.handleReport Spark.report @sparkId 1))

<<<<<<< HEAD
	  (=>(Robot.hasObject RIGHT GREY_TAPE))
=======
	 ;; (=>(Robot.hasObject RIGHT GREY_TAPE))
>>>>>>> 2716516a4eb14a47bb2f6ec3b0d468fd26a53c61

	 ;; (=>(Robot.armPosition RIGHT TABLE_4))
	 
	 (=>(ExecutionManager.execute throw GREY_TAPE TABLE_4 PINK_TRASHBIN 1))
	 )
  )

 (defop |testLispList|
   :invocation (!(Tester.testLispList))
   :documentation " "
   :body (
	  (!(= @a (. a b .)))
	  (!(= @c (CAR @a)))
	  (!(PRINT @c))
	  (!(= @b (LAST @a)))
	  (!(PRINT @b))
	  )
   )

 (defop |testUnification|
   :invocation (!(Tester.testUnification))
   :documentation ""
   :body (
	  (!(= @var (action a parameters b) ))
	  (!(= @var2 (. a b c d .)))
	  (!(== (VAL @var2) (. @primo @secondo @terzo @quarto .)))
	  (!(PRINT @primo))
	  (!(PRINT @terzo))
	  (! (== (VAL @var) (action @actionName parameters @parameters)))
;	     (! (== @action (ACTION-NAME @action-name) (ACTOR @action-actor) (START-TIME @start-time) (END-TIME @end-time) (PARAMETERS @actionParameters)))
;	  (IF(! (== $ACTION (ACTION (ACTION-ID $ACTION-ID) (ACTION-NAME $ACTION-NAME) (ACTOR $ACTOR) (START-TIME $START-TIME) (END-TIME $END-TIME) (PARAMETERS $ActionParams))))
;	    )
	  (!(PRINT @var))
	  (!(PRINT @actionName))
	  (!(PRINT @parameters))
	  )
   )

 (defop |breakpoint|
   :invocation (!(Tester.breakpoint))
   :documentation "hack to implement breakpoints. The system waits for 5 seconds when it reaches one so you have the time to press halt =) "
   :body (
	  (!(PRINT "breakpoint reached"))
	  (^(ELAPSED-TIME(TIME) 5))
	  )
   )
 (defop |testQueue|
   :invocation (!(Tester.testQueue))
   :documentation "test the standard operations of the queue"
   :body (
	  (!(Queue.init Tester.queue))
	  (!(Queue.push fact Tester.queue))
	  (!(Queue.push otherFact Tester.queue))
	  (!(Queue.head @head Tester.queue))
	  (!(PRINT @head))
	  (!(Queue.pop Tester.queue))
	  (!(Queue.head @head Tester.queue))
	  (!(PRINT @head))
	  )
   )

(defop |testPickPlace|
  :invocation (!(Tester.testPickPlace))
  :body (
	 (!(Controller.initAll))
	 (?(Spark.freeId @sparkId))
	 (=>(Spark.request setGraspedObject GREY_TAPE 0 0 (VAL @sparkId)))
	 (!(ExecutionManager.handleReport Spark.report @sparkId @executionId))

	 (?(Spark.freeId @sparkId))
	 (=>(Spark.request setInferrenceForObject GREY_TAPE 0 PR2_ROBOT 0 SPARK_PRECISE_ROBOT_HAND 1.0 (VAL @sparkId)))  
	 (!(ExecutionManager.handleReport Spark.report @sparkId @executionId))
	 
	 (=>(ExecutionManager.execute take GREY_TAPE RIGHT 1))
	 (^(ExecutionManager.report 1 @report))
	 (=>(ExecutionManager.execute place GREY_TAPE TABLE_4 PLACEMAT_BLUE 2))
	 )
  )

 (defop |testPriorityQueue|
   :invocation(!(Tester.testPriorityQueue))
   :documentation "thest the standard operations of the priority queue"
   :body (
	  (!(PriorityQueue.init Tester.priorityQueue))
	  (!(PriorityQueue.push (. fact 3 .) Tester.priorityQueue))   ;inserimento coda vuota
	  (?(Tester.priorityQueue @queue))
	  (!(PRINT @queue))
	  (!(PriorityQueue.push (. secondFact 6 .) Tester.priorityQueue))  ;inserimento in coda
	  (?(Tester.priorityQueue @queue))
 	  (!(PRINT @queue))
	  (!(PriorityQueue.push (. thirdFact 1 .) Tester.priorityQueue))  ;inserimento in testa
	  (?(Tester.priorityQueue @queue))
	  (!(PRINT @queue))
	 ; (!(= @queue (. (. thirdFact 1 .) (. fact 3 .) (. secondFact 5 .) .)))
	 ; (=> (Tester.priorityQueue @queue))
	  (!(PriorityQueue.push (. fourthFact 4 .) Tester.priorityQueue)) ;inserimento secondo posto
	  (?(Tester.priorityQueue @queue))
	  (!(PRINT @queue))
	  (!(PriorityQueue.pop Tester.priorityQueue ))
	  (!(PriorityQueue.pop Tester.priorityQueue))
	  (!(PriorityQueue.head Tester.priorityQueue @head))
	  (!(PRINT @head))
	 )
   )

 (defop |testLists|
   :invocation(!(Tester.testLists))
   :documentation
   :body (
	  (!(= @lista (. factc facte facta .)))
	  (!(= @listb (. factf factb factz .)))
	  (!(= @uniona (LIST-UNION @lista @listb)))
	  (!(= @unionb (LIST-UNION @listb @lista)))
	  (!(PRINT @uniona))
	  (!(PRINT @unionb))
	  )
   )

 (defop |testMonitorManager|
   :invocation (!(Tester.testMonitorManager))
   :documentation
   :body (
	  (!(Controller.initAll))
	  (!(= @sparkRobotName PR2_ROBOT))
	  (!(= @executionId 1))
	  (!(= @object GREY_TAPE))
	  
	  (!(DatabaseInterface.addMonitor (~(AGENT-STATEMENT (VAL @sparkRobotName) (VAL @object) isVisibleBy (VAL @sparkRobotName))) (objectNotVisible (VAL @object)) @result))
	  ;;set the parameters for the monitor manager
	  (! (= @timeTolerance 50))  ;;time that the system can wait to see the item
	  (!(= @failureConditions (. (. (objectNotVisible (VAL @object))  (ELAPSED-TIME (TIME) (VAL @timeTolerance))   .)  (. .) .) )) 	 ; item not there 
	  (!(= @successConditions (. (. (ExecutionManager.report (VAL @executionId) OK) .)  (. .) .) ))     ; when the execution starts the robot is free to monitor something else
	  
	  (?(MonitorManager.lastPriority @lastPriority))
	  (!(MonitorManager.getFreeId @monitorId))
	  (!(= @priority (+ @lastPriority 1)))
	  
					;start the monitoring
	  (!(MonitorManager.monitorTarget @object "NO_NAME" @successConditions @failureConditions @priority @monitorId))
	  

	  )
   )

 (defop |testCondition|
   :invocation (!(Tester.testCondition))
   :documentation
   :body (
	  (!(= @fact (fact a)))
	  (!(= @factb (fact b)))
	  (!(= @conditions (. @fact @factb .)))
	  (!(= @failed FALSE))
	  (=> (fact a))
	  (=> (fact b))

	  )
   )

 (defop |TestFindList|
   :invocation(!(Tester.testFindList))
   :documentation " "
   :body (

	  (!(DatabaseInterface.findList (AGENT-STATEMENT PR2_ROBOT @agent isPresent true) (. @agent .) @result))
	  (!(= @agents (CAR @result)))
	  (WHILE(?(~(NULL @agents)))
		(!(= @agent (CAR @agents)))
		(!(= @agent (CDR @agents)))
		(!(AgentActionMonitor.activateMonitorSpheres (. @object .) @agent))
		)
 
	  )
   )
 
)
