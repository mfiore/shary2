;; -*-Lisp-*-
;;author: Michelangelo Fiore
;;this files contains procedures to manage the Database in the supervision system.
;; GENERAL INFO
;; $facts are always composed terms like (fact a)
;; each procuder sends back a message (Database.result $RESULT)

(

 
 (defop |checkAndApplyDbRules| 
   :invocation (!(CheckAndApplyDbRules $fact $newFact))
   :documentation "this procedure looks into the database rules (used at the moment because the planner or other modules may require that the facts are expressed in a different form) for a given fact and applies them. At the
moment we keep the original fact. This is because different modules could want the facts formatted in different ways and we could need the original formatting too. Doing this procedure in a generic way it's really not
easy if we want to keep the rules list small. For know I will do a series of IF and then i'll think on how to make it better.
The result is returned into $newFact. If it's not bounded than no rules have been applied"
   :body
   (
    (IF(!(== $fact (AGENT-STATEMENT $agentModel $subject $predicate $value)))
       (IF(?(dbRule @typeSubject $subject))
	  (IF(?(dbRule @typeValue $value))
	     (IF(?(dbRule @typeSubject $predicate @typeValue @typeSubject @newPredicate @typeValue))
		(!(= $newFact (AGENT-STATEMENT $agentModel $subject @newPredicate $value)))
		)
	     )
	  )
       )
    
    )
)

 (defop |find| 
   :invocation (Database.find $fact)
   :documentation "this procedure checks if a fact is present in the Database and send back the message TRUE
or FALSE to the supervisor"
   :body
   (
    (?(SUP_NAME $SUP_NAME))
    (IF(?(VAL $fact))
       (!(= @message (Database.result TRUE)))
       
       ELSE
       (!(= @message (Database.result FALSE)))
       )
    (!(SEND-MESSAGE $SUP_NAME @message))
    
    )
)
 (defop |findList|
   :invocation (Database.findList $request $unboundVariables)
   :documentation "this procedure returns in the variable $result a list of list, containing the values of the unbound variables. It's used parameters must be set as follows. $request= composed term like (fact 1 @b 3)  
$unboundVariables= lisp-list containing the variables for which we want to find values. Continuing from the previous examples this would be (. @b .)"
   :body 
   (
    
					;    (!(= @request (fact 1 @b)))
					;   (!(= @result (N-ALL (. @a @b .)
    (? (SUP_NAME $SUP_NAME))
       
   
    (!(= $result (N-ALL $unboundVariables $request)))
    (!(PRINT $result))
    (!(SEND-MESSAGE $SUP_NAME (Database.result $result)))

    )

   )
 (defop |add|
   :invocation (Database.add $fact)
   :documentation "this procedure adds $fact into the database and returns $result. $fact= a composed term like (isOn cup_0 table_0). SHOULD CHECK FOR RULES BEFORE ADDING (What are these rules? To check)" 
   :body (
	  (? (SUP_NAME $SUP_NAME))
	  (!(Database.checkAndApplyDbRules $fact $newFact))
	  (=> (VAL $fact))	  
	  (IF(?(BOUNDP $newFact))
	     (=> (VAL $newFact))
	     IF(? (toMonitor (VAL $newFact) @event))
	     (! (SEND-MESSAGE $SUP_NAME @event))
	     )
	    	 
	  (IF (? (toMonitor (VAL $fact) @event))
	      (! (SEND-MESSAGE $SUP_NAME @event))
	      
	      )
	  (!(SEND-MESSAGE $SUP_NAME (Database.result OK)))
	  )

   )

 (defop |remove|
   :invocation (Database.remove $fact)
   :documentation "this procedure removes $fact from the database. $fact= a composed termi like (isOn cup_0 table_0)"
   :body (
	  (? (SUP_NAME $SUP_NAME))
	  (~> (VAL $fact))
	  (!(SEND-MESSAGE $SUP_NAME (Database.result OK)))
	  )
   )
 (defop |monitorFact|
   :invocation (Database.addMonitor $factToMonitor $event)
   :documentation "this procedure sets up a monitor for a given fact. When this fact is first added to the Database it returns $eventName to the current kernel. $fact and $event are both composed terms"
   :body (
	  (? (SUP_NAME $SUP_NAME))
	  (IF (?(toMonitor (VAL $factToMonitor) @unEvent))
	      (!(SEND-MESSAGE $SUP_NAME (Database.result ERROR)))
		      
	      ELSE
	      (=> (toMonitor (VAL $factToMonitor) (VAL $event)))
	      (!(SEND-MESSAGE $SUP_NAME (Database.result OK)))
	      
	      )	  
	  )
   )
 (defop |removeMonitorFact|
   :invocation (Database.removeMonitor $factToMonitor)
   :documentation "this procedure removes a monitor for a given fact."
   :body (
	  (? (SUP_NAME $SUP_NAME))
	  (~> (toMonitor (VAL $factToMonitor) $event))
	  (!(SEND-MESSAGE $SUP_NAME (Database.result OK)))	  
	  )
   )

 
 (defop |DbCopyBMWithSenderId|
   :invocation (DbCopyBM $senderId $DbCopyId $agent $DbCopyRequestsList)
   :documentation "MATTHIEU'S CODE. Appereantly this procedure handles HATP requests in the ontology. This 
fact is sent by the msgconnector-OPRS-bridge. Looks like the request is hardcoded there to be this way."
   :body (
	  
	  (!(PRINTF (FORMAT "DbCopyBM Start : %s %s %s %s\n"  $senderId $DbCopyId $agent $DbCopyRequestsList)))  
	 
	  (!(= @statusTmp OK))
	  (!(= @DbCopyRequestsList $DbCopyRequestsList))
	  (!(= @DbCopyResultsList (. .)))
	  
	  (!(= @iterOnDbCopyRequests 0))
	  ;;(! (SEM-P ORO-SIMULATOR-SEM))
	  
	  (WHILE(?(~ (NULL @DbCopyRequestsList)))
		(!(= @curDbCopyRequest (CAR @DbCopyRequestsList)))		
		
		(!(= @iterOnDbCopyRequests (+ @iterOnDbCopyRequests 1)))
		;;;;;;;;;;
		;;
		;;;;;;;;;;;;;
		(!(= @iterOnCurDbCopyRequest 0))
		(WHILE(?(~ (NULL @curDbCopyRequest)))
		      (IF(?(EQUAL @iterOnCurDbCopyRequest 0))
			 (!(= @subject (CAR @curDbCopyRequest)))
			 ELSE
			 (!(= @predicate (CAR @curDbCopyRequest)))
			 (!(= @resultList (ALL @someValue (AGENT-STATEMENT (VAL $agent) (VAL @subject) (VAL @predicate) @someValue @anyTime))))
			 (!(= @DbCopyResultsList (CONS-TAIL @resultList @DbCopyResultsList)))
			 )
		      (!(= @iterOnCurDbCopyRequest (+ @iterOnCurDbCopyRequest 1)))
		      (!(= @curDbCopyRequest (CDR @curDbCopyRequest)))
		      )
		
		(IF(?(< @iterOnCurDbCopyRequest 2))
		   (!(PRINTF (FORMAT "To few values (les than two) for @iterOnDbCopyRequests th list in list of list %s\n"  $senderId $DbCopyId $agent $DbCopyRequestsList @iterOnDbCopyRequests $DbCopyRequestsList)))  	  
		   (!(= @statusTmp ERROR))
		   )
		
		
		(!(= @DbCopyRequestsList (CDR @DbCopyRequestsList)))
		)

	  
	  ;;(! (SEM-V ORO-SIMULATOR-SEM))
	  
	  (IF(?(EQUAL @statusTmp OK))
	     (!(= $status ok))
	     ELSE
	     (!(= $status @statusTmp))
	     )

	  (!(= $DbCopyResult (DbCopyRes $DbCopyId $status @DbCopyResultsList)))	  
	  (!(SEND-MESSAGE $senderId $DbCopyResult))

	  (!(PRINTF (FORMAT "DbCopyBM  End : %s %s %s %s %s %s\n"  $senderId $DbCopyId $agent $DbCopyRequestsList $status $DbCopyResult)))  
	  )
   )
 
 


 )
